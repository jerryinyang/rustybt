# Story 1.5: Add Advanced Order Types

## Status
Draft

## Story
**As a** quantitative trader,
**I want** support for Stop-Loss, Stop-Limit, Trailing Stop, OCO, and Bracket orders,
**so that** I can implement realistic risk management strategies in backtests.

## Acceptance Criteria
1. Stop-Loss order type implemented with trigger price and execution logic
2. Stop-Limit order type implemented combining stop trigger with limit price
3. Trailing Stop order implemented with trailing percentage/amount logic
4. OCO (One-Cancels-Other) order type implemented with linked order cancellation
5. Bracket order type implemented (entry + stop-loss + take-profit as single unit)
6. Order state machine extended to handle all new order states (Triggered, PartiallyFilled, Canceled, Rejected)
7. Order lifecycle tests validate correct state transitions for each order type
8. Commission and slippage models apply correctly to all new order types
9. Documentation added with examples for each order type usage
10. Integration tests demonstrate realistic strategy using advanced orders (e.g., bracket order for entry with risk management)

## Tasks / Subtasks
- [ ] Extend Order class with new order types (AC: 1, 2, 3, 4, 5)
  - [ ] Add order type enum: STOP_LOSS, STOP_LIMIT, TRAILING_STOP, OCO, BRACKET
  - [ ] Add stop_price field for stop-based orders
  - [ ] Add trail_amount and trail_percent fields for trailing stops
  - [ ] Add linked_order_ids field for OCO and bracket orders
  - [ ] Add parent_order_id field for child orders in brackets
  - [ ] Update Order class in rustybt/finance/execution.py
  - [ ] Use Decimal type for all price fields

- [ ] Implement Stop-Loss order logic (AC: 1, 6)
  - [ ] Add StopLossOrder class extending Order
  - [ ] Implement trigger logic: Execute market order when price <= stop_price (for short) or >= stop_price (for long)
  - [ ] Add state transition: Open → Triggered → Filled/Rejected
  - [ ] Handle slippage in stop order execution
  - [ ] Update Blotter to check stop conditions on each bar
  - [ ] Add tests for stop-loss execution scenarios

- [ ] Implement Stop-Limit order logic (AC: 2, 6)
  - [ ] Add StopLimitOrder class with stop_price and limit_price
  - [ ] Implement trigger logic: When price crosses stop_price, convert to limit order
  - [ ] Add state transition: Open → Triggered → (Filled|PartiallyFilled|Canceled)
  - [ ] Handle partial fills with limit price constraints
  - [ ] Add expiration handling for unfilled limit orders
  - [ ] Add tests for stop-limit execution scenarios

- [ ] Implement Trailing Stop order logic (AC: 3, 6)
  - [ ] Add TrailingStopOrder class with trail_amount or trail_percent
  - [ ] Implement dynamic stop price adjustment as price moves favorably
  - [ ] Track highest price (for long) or lowest price (for short) since order placed
  - [ ] Calculate stop_price = highest_price - trail_amount (or trail_percent * highest_price)
  - [ ] Trigger execution when price crosses dynamic stop_price
  - [ ] Add state transition: Open → Triggered → Filled/Rejected
  - [ ] Add tests for trailing stop adjustment and execution

- [ ] Implement OCO (One-Cancels-Other) order logic (AC: 4, 6)
  - [ ] Add OCOOrder class linking two orders
  - [ ] Implement cancellation logic: When one order fills, cancel the other
  - [ ] Support OCO combinations: stop-loss + take-profit, multiple entry orders
  - [ ] Add linked_order_ids field to track relationships
  - [ ] Handle state synchronization between linked orders
  - [ ] Add state transition: Open → (Filled → Cancel Sibling) or Canceled
  - [ ] Add tests for OCO execution and cancellation

- [ ] Implement Bracket order logic (AC: 5, 6)
  - [ ] Add BracketOrder class containing entry, stop-loss, and take-profit orders
  - [ ] Implement parent-child relationship: Entry order → Child orders (stop, limit)
  - [ ] Submit child orders only after entry order fills
  - [ ] Implement OCO logic between stop-loss and take-profit
  - [ ] Cancel remaining orders when one child fills
  - [ ] Calculate position-based stop/target prices
  - [ ] Add state transition: EntryOpen → EntryFilled → ChildrenOpen → OneFilled → AllCanceled
  - [ ] Add tests for complete bracket lifecycle

- [ ] Extend order state machine (AC: 6)
  - [ ] Add new states: Triggered, PartiallyFilled, Canceled, Rejected
  - [ ] Document state transition diagram for each order type
  - [ ] Implement state validation (prevent invalid transitions)
  - [ ] Add state change callbacks for strategy notifications
  - [ ] Update Blotter to track state for all order types
  - [ ] Add logging for all state transitions

- [ ] Integrate with Blotter execution engine (AC: 7, 8)
  - [ ] Extend Blotter to process advanced order types
  - [ ] Add order monitoring loop to check trigger conditions each bar
  - [ ] Implement priority queue for pending orders (by trigger price)
  - [ ] Apply commission models to all order types
  - [ ] Apply slippage models to all order types
  - [ ] Handle edge cases (insufficient liquidity, market gaps)
  - [ ] Add transaction logging with full order details

- [ ] Write comprehensive tests (AC: 7, 10)
  - [ ] Unit tests for each order type (stop-loss, stop-limit, trailing stop, OCO, bracket)
  - [ ] Unit tests for state transitions
  - [ ] Unit tests for commission/slippage application
  - [ ] Integration test: Strategy with stop-loss risk management
  - [ ] Integration test: Bracket order complete lifecycle
  - [ ] Integration test: Trailing stop following price movement
  - [ ] Property-based tests for edge cases using Hypothesis

- [ ] Create documentation and examples (AC: 9)
  - [ ] Document each order type in docs/api/order-types.md
  - [ ] Create example strategies using advanced orders
  - [ ] Add docstrings to all order classes
  - [ ] Create tutorial notebook: "Advanced Order Types Guide"
  - [ ] Document state machine with diagrams
  - [ ] Add API reference to main documentation

## Dev Notes

### Existing Project Analysis
[Source: architecture/existing-project-analysis.md]

**Zipline Order Management:**
- Existing order types: Market, Limit
- Order class: `zipline/finance/order.py`
- Blotter: `zipline/finance/blotter.py` (handles order execution)
- Commission models: `zipline/finance/commission.py`
- Slippage models: `zipline/finance/slippage.py`

**Extension Strategy:**
- Extend existing Order class with new types
- Modify Blotter to check trigger conditions
- Maintain backward compatibility with existing order types

### Component Architecture
[Source: architecture/component-architecture.md]

**Files to Extend:**
- `rustybt/finance/execution.py`: Add advanced order type classes
- `rustybt/finance/blotter.py`: Extend execution logic for new order types
- `rustybt/finance/commission.py`: Ensure commission applies to new orders
- `rustybt/finance/slippage.py`: Ensure slippage applies to new orders

**Order Class Structure:**
```python
from decimal import Decimal
from dataclasses import dataclass
from typing import Optional, List
from enum import Enum

class OrderType(Enum):
    MARKET = 'market'
    LIMIT = 'limit'
    STOP_LOSS = 'stop_loss'
    STOP_LIMIT = 'stop_limit'
    TRAILING_STOP = 'trailing_stop'
    OCO = 'oco'
    BRACKET = 'bracket'

class OrderState(Enum):
    OPEN = 'open'
    TRIGGERED = 'triggered'
    PARTIALLY_FILLED = 'partially_filled'
    FILLED = 'filled'
    CANCELED = 'canceled'
    REJECTED = 'rejected'

@dataclass
class Order:
    id: str
    asset: Asset
    amount: Decimal  # Positive = buy, negative = sell
    order_type: OrderType
    limit_price: Optional[Decimal] = None
    stop_price: Optional[Decimal] = None
    trail_amount: Optional[Decimal] = None
    trail_percent: Optional[Decimal] = None
    linked_order_ids: List[str] = None
    parent_order_id: Optional[str] = None
    state: OrderState = OrderState.OPEN
    filled_amount: Decimal = Decimal(0)
    commission: Decimal = Decimal(0)
    dt: pd.Timestamp = None
```

**Decimal Integration:**
- All prices use Decimal type for precision
- Commission and slippage calculations in Decimal
- Position updates with Decimal arithmetic

### Coding Standards
[Source: architecture/coding-standards.md]

**Type Hints:**
```python
from decimal import Decimal
from typing import Optional, List

def submit_stop_loss_order(
    asset: Asset,
    amount: Decimal,
    stop_price: Decimal
) -> str:
    """Submit stop-loss order."""
    pass

def check_stop_trigger(
    order: Order,
    current_price: Decimal
) -> bool:
    """Check if stop order should trigger."""
    pass
```

**Docstrings:**
```python
def submit_bracket_order(
    self,
    asset: Asset,
    amount: Decimal,
    entry_price: Decimal,
    stop_loss_price: Decimal,
    take_profit_price: Decimal
) -> str:
    """Submit bracket order (entry + stop-loss + take-profit).

    Args:
        asset: Asset to trade
        amount: Order quantity (positive=buy, negative=sell)
        entry_price: Entry limit price
        stop_loss_price: Stop-loss trigger price
        take_profit_price: Take-profit limit price

    Returns:
        Parent order ID

    Example:
        >>> # Buy 100 shares with stop at $95 and target at $105
        >>> order_id = algo.submit_bracket_order(
        ...     asset=AAPL,
        ...     amount=Decimal("100"),
        ...     entry_price=Decimal("100.00"),
        ...     stop_loss_price=Decimal("95.00"),
        ...     take_profit_price=Decimal("105.00")
        ... )
    """
```

**Error Handling:**
```python
class OrderRejectedError(RustyBTError):
    """Order rejected by execution engine."""

try:
    order_id = blotter.submit_order(order)
except OrderRejectedError as e:
    logger.error("order_rejected", order_id=order.id, reason=str(e))
    raise
```

### Zero-Mock Enforcement
[Source: architecture/coding-standards.md#zero-mock-enforcement-mandatory]

**Real Implementations Required:**
- Stop trigger logic must check actual prices (not hardcoded triggers)
- Trailing stop adjustment must calculate from real price movements
- OCO cancellation must actually cancel linked orders
- Bracket order lifecycle must execute real state transitions
- Commission/slippage must calculate from real order parameters

**Forbidden Patterns:**
```python
# ❌ FORBIDDEN
def check_stop_trigger(order, current_price):
    return True  # Always triggers

# ✅ CORRECT
def check_stop_trigger(order: Order, current_price: Decimal) -> bool:
    """Check if stop order should trigger."""
    if order.amount > 0:  # Long position
        return current_price <= order.stop_price
    else:  # Short position
        return current_price >= order.stop_price
```

### Testing Strategy
[Source: architecture/testing-strategy.md]

**Unit Tests:**
```python
def test_stop_loss_triggers_correctly():
    """Stop-loss order triggers when price crosses stop price."""
    order = StopLossOrder(
        asset=AAPL,
        amount=Decimal("100"),
        stop_price=Decimal("95.00")
    )

    # Price above stop: should not trigger
    assert not check_stop_trigger(order, Decimal("100.00"))

    # Price at stop: should trigger
    assert check_stop_trigger(order, Decimal("95.00"))

    # Price below stop: should trigger
    assert check_stop_trigger(order, Decimal("94.00"))

def test_trailing_stop_adjusts_with_price():
    """Trailing stop price adjusts as price moves favorably."""
    order = TrailingStopOrder(
        asset=AAPL,
        amount=Decimal("100"),
        trail_amount=Decimal("5.00")
    )

    # Initial price: $100, stop at $95
    update_trailing_stop(order, Decimal("100.00"))
    assert order.stop_price == Decimal("95.00")

    # Price rises to $105, stop adjusts to $100
    update_trailing_stop(order, Decimal("105.00"))
    assert order.stop_price == Decimal("100.00")

    # Price falls to $103, stop stays at $100
    update_trailing_stop(order, Decimal("103.00"))
    assert order.stop_price == Decimal("100.00")

def test_bracket_order_lifecycle():
    """Bracket order complete lifecycle test."""
    bracket = BracketOrder(
        asset=AAPL,
        amount=Decimal("100"),
        entry_price=Decimal("100.00"),
        stop_loss_price=Decimal("95.00"),
        take_profit_price=Decimal("105.00")
    )

    # Initially, only entry order is open
    assert bracket.entry_order.state == OrderState.OPEN
    assert bracket.stop_loss_order is None
    assert bracket.take_profit_order is None

    # Entry fills
    fill_order(bracket.entry_order, Decimal("100.00"))
    assert bracket.entry_order.state == OrderState.FILLED
    assert bracket.stop_loss_order.state == OrderState.OPEN
    assert bracket.take_profit_order.state == OrderState.OPEN

    # Take-profit fills
    fill_order(bracket.take_profit_order, Decimal("105.00"))
    assert bracket.take_profit_order.state == OrderState.FILLED
    assert bracket.stop_loss_order.state == OrderState.CANCELED

def test_oco_cancels_sibling():
    """OCO order cancels sibling when one fills."""
    oco = OCOOrder(
        order1=LimitOrder(asset=AAPL, amount=Decimal("100"), limit_price=Decimal("95.00")),
        order2=LimitOrder(asset=AAPL, amount=Decimal("100"), limit_price=Decimal("105.00"))
    )

    # Both orders initially open
    assert oco.order1.state == OrderState.OPEN
    assert oco.order2.state == OrderState.OPEN

    # order1 fills
    fill_order(oco.order1, Decimal("95.00"))
    assert oco.order1.state == OrderState.FILLED
    assert oco.order2.state == OrderState.CANCELED
```

**Integration Tests:**
```python
@pytest.mark.integration
def test_strategy_with_stop_loss():
    """Test strategy using stop-loss for risk management."""
    class StopLossStrategy(TradingAlgorithm):
        def initialize(self, context):
            context.asset = self.symbol('AAPL')
            context.entry_price = None

        def handle_data(self, context, data):
            current_price = data.current(context.asset, 'close')

            if context.portfolio.positions[context.asset].amount == 0:
                # Enter position with stop-loss
                entry_price = current_price
                stop_price = entry_price * Decimal("0.95")  # 5% stop

                self.order(context.asset, Decimal("100"))
                self.submit_stop_loss_order(
                    context.asset,
                    Decimal("-100"),  # Sell to close
                    stop_price
                )
                context.entry_price = entry_price

    # Run backtest
    result = run_algorithm(
        algorithm=StopLossStrategy(),
        start='2023-01-01',
        end='2023-12-31',
        data_frequency='daily'
    )

    # Verify stop-loss executed when price dropped
    assert result.transactions.count() > 0

@pytest.mark.integration
def test_bracket_order_strategy():
    """Test complete bracket order strategy."""
    class BracketStrategy(TradingAlgorithm):
        def handle_data(self, context, data):
            if self.portfolio.positions_value == 0:
                current_price = data.current(context.asset, 'close')

                self.submit_bracket_order(
                    asset=context.asset,
                    amount=Decimal("100"),
                    entry_price=current_price,
                    stop_loss_price=current_price * Decimal("0.95"),
                    take_profit_price=current_price * Decimal("1.05")
                )

    result = run_algorithm(
        algorithm=BracketStrategy(),
        start='2023-01-01',
        end='2023-12-31'
    )

    # Verify bracket orders executed
    assert len(result.orders) >= 3  # Entry + stop + target
```

**Property-Based Tests:**
```python
from hypothesis import given, strategies as st

@given(
    entry_price=st.decimals(min_value=Decimal("1"), max_value=Decimal("1000")),
    trail_percent=st.decimals(min_value=Decimal("0.01"), max_value=Decimal("0.20"))
)
def test_trailing_stop_never_increases_loss(entry_price, trail_percent):
    """Trailing stop price should never widen the stop distance."""
    order = TrailingStopOrder(
        asset=AAPL,
        amount=Decimal("100"),
        trail_percent=trail_percent
    )

    initial_stop = entry_price * (Decimal("1") - trail_percent)
    update_trailing_stop(order, entry_price)

    # Simulate price movement
    for price in [entry_price * Decimal("1.1"), entry_price * Decimal("0.95")]:
        update_trailing_stop(order, price)
        # Stop should never be worse than initial
        assert order.stop_price >= initial_stop
```

**Test Coverage Target:**
- Unit tests: ≥95% coverage for order execution logic
- Integration tests: Test realistic strategies with advanced orders
- Property tests: 1000+ examples for edge cases

### Order State Machine Diagram

**Stop-Loss Order:**
```
OPEN → (price crosses stop_price) → TRIGGERED → (market execution) → FILLED or REJECTED
```

**Stop-Limit Order:**
```
OPEN → (price crosses stop_price) → TRIGGERED → (limit order placed) → FILLED or PARTIALLY_FILLED or CANCELED
```

**Trailing Stop Order:**
```
OPEN → (continuous adjustment of stop_price) → (price crosses stop_price) → TRIGGERED → FILLED or REJECTED
```

**OCO Order:**
```
BOTH_OPEN → (one order fills) → ONE_FILLED → (cancel sibling) → SIBLING_CANCELED
```

**Bracket Order:**
```
ENTRY_OPEN → (entry fills) → ENTRY_FILLED → CHILDREN_OPEN → (one child fills) → ONE_CHILD_FILLED → OTHER_CANCELED
```

### Testing

**Test File Location:**
- Unit tests: `tests/finance/test_execution.py`, `tests/finance/test_blotter.py`
- Integration tests: `tests/integration/test_advanced_orders.py`
- Property tests: `tests/finance/test_order_properties.py`

**Test Standards:**
- Test each order type independently
- Test order state transitions
- Test commission/slippage application
- Test integration with strategy execution
- Test edge cases (market gaps, insufficient liquidity)

**Testing Frameworks:**
- pytest for test framework
- hypothesis for property-based testing
- Decimal for all price/amount assertions

**Manual Verification:**
1. Create test strategy with stop-loss orders
2. Run backtest and verify stop executions
3. Test bracket order lifecycle manually
4. Verify commission/slippage applied correctly
5. Check all state transitions logged properly

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-30 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated by dev agent_

### Completion Notes List
_To be populated by dev agent_

### File List
_To be populated by dev agent_

## QA Results
_To be populated by QA agent_
