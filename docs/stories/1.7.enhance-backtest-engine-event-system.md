# Story 1.7: Enhance Backtest Engine Event System

## Status
Draft

## Story
**As a** developer,
**I want** improved event system with custom triggers and sub-second resolution support,
**so that** the engine can support high-frequency strategies and flexible event-driven logic.

## Acceptance Criteria
1. Simulation clock extended to support millisecond and microsecond resolutions
2. Custom event triggers implementable via plugin API (e.g., `on_price_threshold`, `on_time_interval`)
3. Event priority system implemented to control event processing order within same timestamp
4. Event system maintains temporal isolation (events cannot see future data)
5. Real-time mode switching capability added for live trading preparation
6. Performance impact measured: sub-second resolution adds <10% overhead vs. daily resolution
7. Tests validate event ordering and temporal isolation with sub-second data
8. Example strategy demonstrates custom event trigger usage

## Tasks / Subtasks
- [ ] Extend simulation clock for sub-second resolution (AC: 1)
  - [ ] Modify MinuteSimulationClock to support millisecond/microsecond timestamps
  - [ ] Add resolution parameter: 'daily', 'minute', 'second', 'millisecond', 'microsecond'
  - [ ] Update timestamp generation to use pd.Timestamp with appropriate precision
  - [ ] Ensure backward compatibility with existing daily/minute strategies
  - [ ] Test clock accuracy with high-frequency timestamps
  - [ ] Measure memory impact of storing microsecond timestamps

- [ ] Implement custom event trigger plugin API (AC: 2)
  - [ ] Create EventTrigger base class with abstract methods
  - [ ] Add register_trigger() method to event system
  - [ ] Implement example triggers: PriceThresholdTrigger, TimeIntervalTrigger
  - [ ] Support multiple triggers per strategy
  - [ ] Add trigger priority/ordering configuration
  - [ ] Document plugin API with examples

- [ ] Create event priority system (AC: 3)
  - [ ] Add priority field to Event class (integer 0-100)
  - [ ] Implement priority queue for events at same timestamp
  - [ ] Define default priorities: MarketOpen=100, BarData=50, MarketClose=10, Custom=25
  - [ ] Allow strategies to override event priorities
  - [ ] Ensure deterministic ordering for same-priority events
  - [ ] Add tests for priority ordering

- [ ] Validate temporal isolation (AC: 4)
  - [ ] Add timestamp validation to DataPortal data access
  - [ ] Raise LookaheadError if future data accessed
  - [ ] Add debug mode to log all data access timestamps
  - [ ] Create test suite for temporal isolation violations
  - [ ] Add property-based tests using Hypothesis
  - [ ] Document temporal isolation guarantees

- [ ] Implement real-time mode switching (AC: 5)
  - [ ] Add simulation_mode flag: 'backtest', 'live', 'paper'
  - [ ] Create LiveClock for real-time progression
  - [ ] Implement clock abstraction: SimulationClock vs LiveClock
  - [ ] Add mode-specific event handling (live: async, backtest: sync)
  - [ ] Support seamless transition between modes
  - [ ] Test mode switching with sample strategy

- [ ] Measure and optimize performance (AC: 6)
  - [ ] Benchmark daily resolution backtest baseline
  - [ ] Benchmark minute resolution backtest
  - [ ] Benchmark second/millisecond resolution backtests
  - [ ] Measure memory usage for different resolutions
  - [ ] Profile hotspots using cProfile or py-spy
  - [ ] Optimize if overhead exceeds 10% threshold
  - [ ] Document performance characteristics

- [ ] Write comprehensive tests (AC: 7)
  - [ ] Unit tests for sub-second clock accuracy
  - [ ] Unit tests for custom event triggers
  - [ ] Unit tests for event priority ordering
  - [ ] Integration test: High-frequency strategy with millisecond bars
  - [ ] Integration test: Custom event trigger strategy
  - [ ] Temporal isolation tests with property-based testing
  - [ ] Performance tests comparing resolutions

- [ ] Create example strategy (AC: 8)
  - [ ] Implement strategy with custom event trigger (e.g., price threshold alert)
  - [ ] Demonstrate sub-second data handling
  - [ ] Show event priority usage
  - [ ] Document strategy thoroughly
  - [ ] Add to examples/ directory

## Dev Notes

### Existing Project Analysis
[Source: architecture/existing-project-analysis.md]

**Zipline Event System:**
- MinuteSimulationClock: Cython implementation (`gens/sim_engine.pyx`)
- Event types: BeforeTrading, BarData, AfterTrading
- Resolution: Daily or minute (no sub-second)
- AlgorithmSimulator: Orchestrates event dispatch
- TradeSimulation: Main simulation loop

**Extension Strategy:**
- Extend MinuteSimulationClock to support sub-second timestamps
- Add plugin system for custom event triggers
- Maintain backward compatibility with existing strategies

### Component Architecture
[Source: architecture/component-architecture.md]

**Files to Modify:**
- `rustybt/gens/sim_engine.pyx`: Extend clock for sub-second resolution
- `rustybt/gens/tradesimulation.py`: Add custom event trigger support
- `rustybt/gens/clock.py`: Create unified clock abstraction (sim + live)
- `rustybt/data/data_portal.py`: Add timestamp validation for temporal isolation

**Event System Architecture:**
```python
from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Optional, Callable
import pandas as pd
from decimal import Decimal
from enum import IntEnum

class EventPriority(IntEnum):
    MARKET_OPEN = 100
    BAR_DATA = 50
    CUSTOM = 25
    MARKET_CLOSE = 10

@dataclass
class Event:
    dt: pd.Timestamp
    event_type: str
    priority: int = EventPriority.BAR_DATA
    data: dict = None

class EventTrigger(ABC):
    """Base class for custom event triggers."""

    @abstractmethod
    def should_trigger(
        self,
        current_time: pd.Timestamp,
        data: dict
    ) -> bool:
        """Check if event should trigger."""
        pass

    @abstractmethod
    def on_trigger(self, context, data):
        """Callback when event triggers."""
        pass

class PriceThresholdTrigger(EventTrigger):
    """Trigger when price crosses threshold."""

    def __init__(
        self,
        asset: Asset,
        threshold: Decimal,
        direction: str = 'above'  # 'above' or 'below'
    ):
        self.asset = asset
        self.threshold = threshold
        self.direction = direction
        self.last_price = None

    def should_trigger(
        self,
        current_time: pd.Timestamp,
        data: dict
    ) -> bool:
        current_price = data.get(self.asset, {}).get('close')
        if current_price is None:
            return False

        if self.last_price is None:
            self.last_price = current_price
            return False

        # Check crossing
        if self.direction == 'above':
            triggered = (self.last_price < self.threshold and
                        current_price >= self.threshold)
        else:  # below
            triggered = (self.last_price > self.threshold and
                        current_price <= self.threshold)

        self.last_price = current_price
        return triggered

    def on_trigger(self, context, data):
        """User-defined callback when price crosses threshold."""
        pass  # Implemented by strategy

class TimeIntervalTrigger(EventTrigger):
    """Trigger at regular time intervals."""

    def __init__(
        self,
        interval: pd.Timedelta,
        callback: Callable
    ):
        self.interval = interval
        self.callback = callback
        self.last_trigger = None

    def should_trigger(
        self,
        current_time: pd.Timestamp,
        data: dict
    ) -> bool:
        if self.last_trigger is None:
            self.last_trigger = current_time
            return True

        if current_time - self.last_trigger >= self.interval:
            self.last_trigger = current_time
            return True

        return False

    def on_trigger(self, context, data):
        self.callback(context, data)
```

**Clock Abstraction:**
```python
from abc import ABC, abstractmethod
import pandas as pd

class BaseClock(ABC):
    """Base class for simulation and live clocks."""

    @abstractmethod
    def __iter__(self):
        """Iterate over timestamps."""
        pass

    @abstractmethod
    def get_current_time(self) -> pd.Timestamp:
        """Get current simulation/real time."""
        pass

class SimulationClock(BaseClock):
    """Fast-forward simulation clock."""

    def __init__(
        self,
        start: pd.Timestamp,
        end: pd.Timestamp,
        resolution: str = 'minute'  # 'daily', 'minute', 'second', 'millisecond', 'microsecond'
    ):
        self.start = start
        self.end = end
        self.resolution = resolution
        self.current_time = start

    def __iter__(self):
        # Generate timestamps based on resolution
        if self.resolution == 'daily':
            freq = pd.DateOffset(days=1)
        elif self.resolution == 'minute':
            freq = pd.DateOffset(minutes=1)
        elif self.resolution == 'second':
            freq = pd.DateOffset(seconds=1)
        elif self.resolution == 'millisecond':
            freq = pd.DateOffset(milliseconds=1)
        elif self.resolution == 'microsecond':
            freq = pd.DateOffset(microseconds=1)

        current = self.start
        while current <= self.end:
            self.current_time = current
            yield current
            current += freq

    def get_current_time(self) -> pd.Timestamp:
        return self.current_time

class LiveClock(BaseClock):
    """Real-time clock for live trading."""

    def __init__(self):
        self.current_time = pd.Timestamp.now(tz='UTC')

    def __iter__(self):
        # Infinite loop for live trading
        while True:
            self.current_time = pd.Timestamp.now(tz='UTC')
            yield self.current_time
            # Sleep briefly to avoid tight loop
            time.sleep(0.001)  # 1ms

    def get_current_time(self) -> pd.Timestamp:
        return pd.Timestamp.now(tz='UTC')
```

### Tech Stack
[Source: architecture/tech-stack.md]

**Existing:**
- Cython: Performance-critical clock implementation (sim_engine.pyx)
- pandas: Timestamp handling with nanosecond precision

**Enhancements:**
- Python asyncio: For live mode event handling
- APScheduler: Custom interval triggers (already in tech stack)

### Coding Standards
[Source: architecture/coding-standards.md]

**Type Hints:**
```python
from typing import Iterator, Callable
import pandas as pd

def create_clock(
    start: pd.Timestamp,
    end: pd.Timestamp,
    resolution: str
) -> Iterator[pd.Timestamp]:
    """Create simulation clock."""
    pass
```

**Temporal Isolation Validation:**
```python
class LookaheadError(RustyBTError):
    """Raised when strategy attempts to access future data."""

class TemporalValidator:
    """Validates data access is temporally valid."""

    def __init__(self, current_time: pd.Timestamp):
        self.current_time = current_time

    def validate_access(
        self,
        requested_time: pd.Timestamp,
        data_type: str
    ):
        """Validate data access does not look ahead."""
        if requested_time > self.current_time:
            raise LookaheadError(
                f"Attempted to access {data_type} at {requested_time}, "
                f"but current time is {self.current_time}"
            )
```

### Zero-Mock Enforcement
[Source: architecture/coding-standards.md#zero-mock-enforcement-mandatory]

**Real Implementations Required:**
- Clock must generate actual timestamps (not hardcoded sequence)
- Event triggers must check real conditions (not always trigger)
- Temporal validation must compare real timestamps (not fake validation)
- Performance measurements must be actual benchmarks (not mock metrics)

**Forbidden Patterns:**
```python
# ❌ FORBIDDEN
def should_trigger(self, current_time, data):
    return True  # Always triggers

def validate_temporal_isolation(requested_time, current_time):
    return True  # Never validates

# ✅ CORRECT
def should_trigger(
    self,
    current_time: pd.Timestamp,
    data: dict
) -> bool:
    """Check if price threshold crossed."""
    current_price = Decimal(str(data.get(self.asset, {}).get('close', 0)))
    if current_price == 0:
        return False

    if self.direction == 'above':
        return current_price >= self.threshold and self.last_price < self.threshold
    else:
        return current_price <= self.threshold and self.last_price > self.threshold

def validate_temporal_isolation(
    requested_time: pd.Timestamp,
    current_time: pd.Timestamp
):
    """Validate no lookahead bias."""
    if requested_time > current_time:
        raise LookaheadError(
            f"Cannot access data at {requested_time} "
            f"(current time: {current_time})"
        )
```

### Testing Strategy
[Source: architecture/testing-strategy.md]

**Unit Tests:**
```python
def test_clock_sub_second_resolution():
    """Test clock generates sub-second timestamps."""
    start = pd.Timestamp('2023-01-01 09:30:00.000')
    end = pd.Timestamp('2023-01-01 09:30:00.100')  # 100ms window

    clock = SimulationClock(start, end, resolution='millisecond')
    timestamps = list(clock)

    assert len(timestamps) == 101  # 0-100ms inclusive
    assert timestamps[0] == start
    assert timestamps[-1] == end
    assert timestamps[1] - timestamps[0] == pd.Timedelta(milliseconds=1)

def test_price_threshold_trigger():
    """Test price threshold trigger detects crossings."""
    trigger = PriceThresholdTrigger(
        asset=AAPL,
        threshold=Decimal("100.00"),
        direction='above'
    )

    # Below threshold
    assert not trigger.should_trigger(
        pd.Timestamp('2023-01-01'),
        {AAPL: {'close': Decimal("99.00")}}
    )

    # Cross above threshold
    assert trigger.should_trigger(
        pd.Timestamp('2023-01-02'),
        {AAPL: {'close': Decimal("101.00")}}
    )

    # Stay above threshold (no trigger)
    assert not trigger.should_trigger(
        pd.Timestamp('2023-01-03'),
        {AAPL: {'close': Decimal("102.00")}}
    )

def test_event_priority_ordering():
    """Test events processed in priority order."""
    events = [
        Event(pd.Timestamp('2023-01-01 10:00'), 'bar', EventPriority.BAR_DATA),
        Event(pd.Timestamp('2023-01-01 10:00'), 'open', EventPriority.MARKET_OPEN),
        Event(pd.Timestamp('2023-01-01 10:00'), 'custom', EventPriority.CUSTOM),
    ]

    sorted_events = sorted(events, key=lambda e: -e.priority)

    assert sorted_events[0].event_type == 'open'  # Highest priority
    assert sorted_events[1].event_type == 'bar'
    assert sorted_events[2].event_type == 'custom'  # Lowest priority

def test_temporal_isolation_validation():
    """Test temporal isolation prevents lookahead."""
    validator = TemporalValidator(current_time=pd.Timestamp('2023-01-01 10:00'))

    # Valid access (past data)
    validator.validate_access(pd.Timestamp('2023-01-01 09:00'), 'price')

    # Valid access (current data)
    validator.validate_access(pd.Timestamp('2023-01-01 10:00'), 'price')

    # Invalid access (future data)
    with pytest.raises(LookaheadError):
        validator.validate_access(pd.Timestamp('2023-01-01 11:00'), 'price')
```

**Property-Based Tests:**
```python
from hypothesis import given, strategies as st

@given(
    resolution=st.sampled_from(['daily', 'minute', 'second', 'millisecond']),
    duration_days=st.integers(min_value=1, max_value=10)
)
def test_clock_monotonic_progression(resolution, duration_days):
    """Clock timestamps should always increase monotonically."""
    start = pd.Timestamp('2023-01-01')
    end = start + pd.Timedelta(days=duration_days)

    clock = SimulationClock(start, end, resolution=resolution)
    timestamps = list(clock)

    # Verify monotonic increase
    for i in range(1, len(timestamps)):
        assert timestamps[i] > timestamps[i-1]

@given(
    current_times=st.lists(
        st.datetimes(min_value=datetime(2020, 1, 1), max_value=datetime(2023, 12, 31)),
        min_size=10,
        max_size=100
    )
)
def test_temporal_isolation_invariant(current_times):
    """Future data access should always raise LookaheadError."""
    sorted_times = sorted(current_times)

    for i in range(len(sorted_times) - 1):
        current = pd.Timestamp(sorted_times[i])
        future = pd.Timestamp(sorted_times[i + 1])

        validator = TemporalValidator(current_time=current)

        # Accessing future should fail
        with pytest.raises(LookaheadError):
            validator.validate_access(future, 'test')
```

**Performance Tests:**
```python
@pytest.mark.benchmark
def test_daily_resolution_baseline(benchmark):
    """Benchmark daily resolution backtest."""
    def run_backtest():
        return run_algorithm(
            start='2023-01-01',
            end='2023-12-31',
            data_frequency='daily',
            capital_base=100000
        )

    result = benchmark(run_backtest)
    baseline_time = result.duration
    return baseline_time

@pytest.mark.benchmark
def test_minute_resolution_performance(benchmark):
    """Benchmark minute resolution backtest."""
    def run_backtest():
        return run_algorithm(
            start='2023-01-01',
            end='2023-01-31',  # Shorter duration for minute data
            data_frequency='minute',
            capital_base=100000
        )

    result = benchmark(run_backtest)
    minute_time = result.duration

    # Compare to baseline (should be <10x slower)
    # Note: Would need actual baseline from daily test
    # assert minute_time / baseline_time < 10

@pytest.mark.benchmark
def test_millisecond_resolution_overhead(benchmark):
    """Measure overhead of millisecond resolution."""
    def run_backtest():
        return run_algorithm(
            start='2023-01-01 09:30:00',
            end='2023-01-01 16:00:00',  # Single trading day
            data_frequency='millisecond',
            capital_base=100000
        )

    result = benchmark(run_backtest)

    # Verify <10% overhead vs minute (for equivalent data size)
    # This would require baseline comparison
```

**Integration Tests:**
```python
@pytest.mark.integration
def test_high_frequency_strategy():
    """Test strategy with millisecond data."""
    class HFStrategy(TradingAlgorithm):
        def initialize(self, context):
            context.asset = self.symbol('AAPL')
            context.last_trade_time = None

        def handle_data(self, context, data):
            current_time = self.get_datetime()

            # Trade at most once per second
            if (context.last_trade_time is None or
                current_time - context.last_trade_time >= pd.Timedelta(seconds=1)):
                self.order(context.asset, 1)
                context.last_trade_time = current_time

    result = run_algorithm(
        algorithm=HFStrategy(),
        start='2023-01-01 09:30:00',
        end='2023-01-01 16:00:00',
        data_frequency='millisecond'
    )

    # Verify trades happened at appropriate intervals
    assert len(result.transactions) > 0

@pytest.mark.integration
def test_custom_trigger_strategy():
    """Test strategy with custom price threshold trigger."""
    class TriggerStrategy(TradingAlgorithm):
        def initialize(self, context):
            context.asset = self.symbol('AAPL')

            # Register price threshold trigger
            trigger = PriceThresholdTrigger(
                asset=context.asset,
                threshold=Decimal("150.00"),
                direction='above'
            )
            self.register_trigger(trigger, self.on_threshold_crossed)

        def on_threshold_crossed(self, context, data):
            # Buy when price crosses above $150
            self.order(context.asset, 100)

    result = run_algorithm(
        algorithm=TriggerStrategy(),
        start='2023-01-01',
        end='2023-12-31',
        data_frequency='daily'
    )

    # Verify trigger executed when price crossed threshold
    assert len(result.transactions) > 0
```

**Test Coverage Target:**
- Unit tests: ≥95% coverage for event system
- Property tests: 1000+ examples for temporal isolation
- Integration tests: Test with real strategies
- Performance tests: Benchmark all resolutions

### Testing

**Test File Location:**
- Unit tests: `tests/gens/test_clock.py`, `tests/gens/test_events.py`
- Integration tests: `tests/integration/test_high_frequency.py`
- Property tests: `tests/gens/test_temporal_isolation.py`
- Performance tests: `tests/benchmarks/test_resolution_performance.py`

**Test Standards:**
- Test clock accuracy at all resolutions
- Test custom event triggers
- Test event priority ordering
- Test temporal isolation enforcement
- Benchmark performance at each resolution

**Testing Frameworks:**
- pytest for test framework
- hypothesis for property-based testing
- pytest-benchmark for performance testing
- cProfile/py-spy for profiling

**Manual Verification:**
1. Create test strategy with custom trigger
2. Run with different resolutions
3. Verify event ordering
4. Check temporal isolation prevents lookahead
5. Measure performance overhead
6. Profile hotspots if overhead >10%

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-30 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated by dev agent_

### Completion Notes List
_To be populated by dev agent_

### File List
_To be populated by dev agent_

## QA Results
_To be populated by QA agent_
