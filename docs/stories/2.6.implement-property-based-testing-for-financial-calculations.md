# Story 2.6: Implement Property-Based Testing for Financial Calculations

## Status
Approved for development

## Story
**As a** developer,
**I want** comprehensive property-based tests using Hypothesis framework,
**so that** Decimal implementation correctness is validated across wide input ranges.

## Acceptance Criteria
1. Hypothesis test suite created for core financial calculations
2. Portfolio value property: sum(position_values) + cash == total_portfolio_value (invariant)
3. Returns property: (end_value / start_value) - 1 == returns (consistent calculation)
4. Commission property: commission >= 0 and commission <= order_value (bounds check)
5. Drawdown property: max_drawdown <= 0 and max_drawdown >= -1.0 (valid range)
6. Decimal precision property: operations maintain configured precision without silent rounding
7. Associativity property: (a + b) + c == a + (b + c) for Decimal operations
8. Order execution property: fill_value = fill_price × fill_quantity (exact, no rounding error)
9. Tests run with Hypothesis shrinking to find minimal failing cases
10. All property-based tests pass with 1000+ generated examples per test

## Tasks / Subtasks

- [ ] Setup Hypothesis testing infrastructure (AC: 1)
  - [ ] Add hypothesis to dependencies in `pyproject.toml` (version ≥6.x)
  - [ ] Create `tests/property_tests/` directory for all property tests
  - [ ] Create Hypothesis configuration in `tests/conftest.py`
  - [ ] Set max_examples=1000 for thorough testing
  - [ ] Set deadline=None for complex calculations (no timeout)
  - [ ] Enable Hypothesis database for shrinking cache
  - [ ] Configure Hypothesis profiles: quick (100 examples), thorough (1000), CI (500)
  - [ ] Document property testing strategy in `docs/testing/property-based-testing.md`
  - [ ] Create custom Hypothesis strategies for Decimal generation
  - [ ] Strategy: `decimal_prices()` for price generation (positive, reasonable range)
  - [ ] Strategy: `decimal_quantities()` for order quantities (fractional support)

- [ ] Test portfolio value invariant (AC: 2)
  - [ ] Create `tests/property_tests/test_ledger_properties.py`
  - [ ] Property: portfolio_value = sum(position_values) + cash (accounting identity)
  - [ ] Generate random portfolios: varying cash, position counts, prices
  - [ ] Hypothesis strategy: generate 1-20 positions with random prices
  - [ ] Verify invariant holds after each transaction (buy/sell)
  - [ ] Test with fractional shares (crypto precision)
  - [ ] Test with zero cash, zero positions, negative positions (shorts)
  - [ ] Ensure exact Decimal equality (no epsilon tolerance)
  - [ ] Hypothesis shrinking finds minimal portfolio violating invariant
  - [ ] Test passes with 1000+ randomly generated portfolios

- [ ] Test returns calculation consistency (AC: 3)
  - [ ] Create property: (1 + return) × start_value = end_value
  - [ ] Generate random start/end portfolio values
  - [ ] Hypothesis strategy: generate values in range [1000, 1000000]
  - [ ] Calculate returns: (end_value / start_value) - 1
  - [ ] Reconstruct end_value from returns: (1 + return) × start_value
  - [ ] Verify reconstructed = original (exact Decimal equality)
  - [ ] Test with gains (positive returns), losses (negative returns)
  - [ ] Test edge case: 100% loss (return = -1.0)
  - [ ] Test edge case: 0% return (start_value = end_value)
  - [ ] Test passes with 1000+ random value pairs

- [ ] Test commission bounds and calculation (AC: 4)
  - [ ] Create property: commission >= 0 (non-negative)
  - [ ] Create property: commission <= order_value (sanity check)
  - [ ] Generate random orders: varying prices, quantities, commission models
  - [ ] Test PerShareCommission: commission = shares × rate
  - [ ] Test PerDollarCommission: commission = order_value × rate
  - [ ] Test CryptoCommission: commission = order_value × (maker_rate or taker_rate)
  - [ ] Test minimum commission enforcement: max(calculated, minimum)
  - [ ] Test commission with fractional shares (crypto orders)
  - [ ] Verify commission precision matches asset class
  - [ ] Test passes with 1000+ random orders

- [ ] Test drawdown valid range (AC: 5)
  - [ ] Create property: max_drawdown <= 0 (always non-positive)
  - [ ] Create property: max_drawdown >= -1.0 (cannot exceed 100% loss)
  - [ ] Generate random return series: varying volatility, drift
  - [ ] Hypothesis strategy: generate returns in range [-0.1, 0.1]
  - [ ] Calculate cumulative returns and max drawdown
  - [ ] Verify drawdown in valid range [-1.0, 0.0]
  - [ ] Test with all positive returns (drawdown = 0)
  - [ ] Test with severe losses (drawdown approaches -1.0)
  - [ ] Test with multiple drawdown periods (find maximum)
  - [ ] Test passes with 1000+ random return series

- [ ] Test Decimal precision preservation (AC: 6)
  - [ ] Create `tests/property_tests/test_decimal_precision.py`
  - [ ] Property: Decimal operations maintain configured precision
  - [ ] Generate random Decimal values with specific precision
  - [ ] Perform arithmetic operations: add, subtract, multiply, divide
  - [ ] Verify result precision matches configured precision
  - [ ] Test rounding mode application (ROUND_HALF_EVEN, ROUND_DOWN)
  - [ ] Test with very small values (0.00000001 for crypto)
  - [ ] Test with very large values (millions for portfolio value)
  - [ ] Verify no silent rounding (all rounding explicit and logged)
  - [ ] Test passes with 1000+ random arithmetic operations

- [ ] Test Decimal arithmetic properties (AC: 7)
  - [ ] Property: Associativity - (a + b) + c == a + (b + c)
  - [ ] Generate random Decimal triples (a, b, c)
  - [ ] Verify associativity for addition
  - [ ] Verify associativity for multiplication
  - [ ] Property: Commutativity - a + b == b + a
  - [ ] Verify commutativity for addition
  - [ ] Verify commutativity for multiplication
  - [ ] Property: Distributivity - a × (b + c) == a × b + a × c
  - [ ] Verify distributivity holds with Decimal precision
  - [ ] Test passes with 1000+ random Decimal value combinations

- [ ] Test order execution precision (AC: 8)
  - [ ] Create `tests/property_tests/test_order_execution_properties.py`
  - [ ] Property: fill_value = fill_price × fill_quantity (exact equality)
  - [ ] Generate random orders: varying prices, quantities
  - [ ] Execute orders and verify fill value calculation
  - [ ] Property: sum(partial_fills) = total_filled (partial fill invariant)
  - [ ] Generate random partial fill sequences
  - [ ] Verify sum of partial fill amounts equals total filled
  - [ ] Property: average_fill_price = weighted_average(fill_prices)
  - [ ] Calculate average fill price from multiple partial fills
  - [ ] Verify weighted average calculation is exact
  - [ ] Test with fractional quantities (crypto orders)
  - [ ] Test passes with 1000+ random order executions

- [ ] Test metrics calculation properties (AC: 1-10)
  - [ ] Create `tests/property_tests/test_metrics_properties.py`
  - [ ] Property: Sharpe = (mean_return - rf) / std_return (definition)
  - [ ] Generate random return series and verify Sharpe calculation
  - [ ] Property: Sortino >= Sharpe when negative returns exist
  - [ ] Property: Calmar = annual_return / abs(max_drawdown)
  - [ ] Property: CVaR <= VaR (risk measure ordering)
  - [ ] Property: win_rate in range [0, 1] (probability bounds)
  - [ ] Property: profit_factor = gross_profit / gross_loss
  - [ ] Property: sum(attribution) = total_return (accounting identity)
  - [ ] Property: excess_return = strategy_return - benchmark_return
  - [ ] Test all properties with 1000+ random metric inputs

- [ ] Test data pipeline properties (AC: 1-10)
  - [ ] Create `tests/property_tests/test_data_pipeline_properties.py`
  - [ ] Property: OHLCV relationships always valid (H >= max(O,C), L <= min(O,C))
  - [ ] Generate random OHLCV data and verify relationships
  - [ ] Property: resample(minute_to_daily) preserves OHLCV relationships
  - [ ] Property: adjustment(split) preserves price ratios
  - [ ] Test split adjustment: adjusted_price = price / split_ratio
  - [ ] Property: adjustment(dividend) reduces price by dividend amount
  - [ ] Property: roundtrip(CSV → Parquet → read) preserves precision
  - [ ] Generate random price data and verify roundtrip preservation
  - [ ] Test passes with 1000+ random data pipeline operations

- [ ] Configure Hypothesis shrinking and debugging (AC: 9)
  - [ ] Enable Hypothesis shrinking to find minimal failing examples
  - [ ] Configure shrinking strategy: simplify inputs while preserving failure
  - [ ] Add `@example()` decorator with known edge cases
  - [ ] Example: zero values, boundary values, extreme values
  - [ ] Enable Hypothesis verbosity for debugging: `--hypothesis-verbosity=verbose`
  - [ ] Configure Hypothesis database: store shrunk examples for regression
  - [ ] Database location: `tests/.hypothesis/` (git-ignored)
  - [ ] Add Hypothesis statistics reporting in CI/CD
  - [ ] Report: number of examples, shrinking iterations, failures
  - [ ] Document debugging workflow in property test documentation

- [ ] Create custom Hypothesis strategies (AC: 1)
  - [ ] Create `tests/property_tests/strategies.py` for reusable strategies
  - [ ] Strategy: `decimal_prices(min_value, max_value, scale)` for price generation
  - [ ] Strategy: `decimal_quantities(min_value, max_value, scale)` for quantities
  - [ ] Strategy: `decimal_returns(min_return, max_return)` for return series
  - [ ] Strategy: `asset_portfolios(num_positions)` for portfolio generation
  - [ ] Strategy: `ohlcv_bars(num_bars)` for valid OHLCV data generation
  - [ ] Strategy: `order_sequences(num_orders)` for order execution sequences
  - [ ] Strategy: `commission_models()` for commission model generation
  - [ ] Strategy: `slippage_models()` for slippage model generation
  - [ ] Document strategies with examples and usage guidelines

- [ ] Integrate property tests into CI/CD (AC: 10)
  - [ ] Add property tests to GitHub Actions workflow
  - [ ] Run property tests in separate CI job: `property-tests`
  - [ ] Configure Hypothesis profile: `CI` with 500 examples (balance speed/coverage)
  - [ ] Set timeout: 30 minutes for full property test suite
  - [ ] Fail build if any property test fails (no exceptions)
  - [ ] Report Hypothesis statistics in CI output
  - [ ] Archive shrunk examples as CI artifacts
  - [ ] Schedule weekly full run with 10000 examples (thorough profile)
  - [ ] Add property test coverage to quality gates
  - [ ] Require property tests pass before merge to main

## Dev Notes

### Previous Story Insights
[Dependency: Story 2.1 - Design Decimal Precision Configuration System]
[Dependency: Story 2.2 - Replace Float with Decimal in Core Calculation Engine]
[Dependency: Story 2.3 - Replace Float with Decimal in Order Execution System]
[Dependency: Story 2.4 - Replace Float with Decimal in Performance Metrics]
[Dependency: Story 2.5 - Replace Float with Decimal in Data Pipelines]

**Integration Requirements:**
This story validates ALL Decimal implementations from Stories 2.1-2.5:
- Story 2.1: DecimalConfig precision management
- Story 2.2: DecimalLedger portfolio calculations
- Story 2.3: DecimalOrder and DecimalTransaction execution
- Story 2.4: Decimal performance metrics (Sharpe, drawdown, etc.)
- Story 2.5: Decimal data pipelines (OHLCV, adjustments)

**Purpose:**
Property-based testing ensures Decimal implementations are correct across wide input ranges, catching edge cases that unit tests might miss. This is critical for financial applications where precision errors can compound.

**Design Decisions:**
- Use Hypothesis for property-based testing (industry standard)
- Run 1000+ examples per test for thorough validation
- Enable shrinking to find minimal failing cases
- Test mathematical properties (associativity, commutativity)
- Test domain-specific invariants (accounting identities, bounds)
- Test precision preservation throughout pipeline

### Component Architecture
[Source: architecture/component-architecture.md]

**Property Test Integration Points:**
- DecimalLedger: portfolio value invariant, returns calculation
- DecimalOrder/Transaction: order value calculation, partial fills
- DecimalMetrics: Sharpe ratio, drawdown, VaR calculations
- PolarsDataPortal: OHLCV relationships, precision preservation
- Commission/Slippage models: bounds checking, calculation properties

### Tech Stack
[Source: architecture/tech-stack.md]

**Core Dependencies:**
- **hypothesis** (≥6.x): Property-based testing framework
  - `@given` decorator for property test definition
  - `strategies` module for data generation
  - Shrinking engine for minimal failing examples
  - Database for regression test storage

- **pytest** (≥7.2.0): Test framework integration
  - Hypothesis pytest plugin
  - Property test discovery and execution
  - Statistics reporting

**Testing Infrastructure:**
- **pytest-xdist** (≥2.5.0): Parallel test execution
- **pytest-cov** (≥3.0.0): Coverage reporting
- **pytest-benchmark** (≥3.4.1): Performance benchmarks

### Source Tree
[Source: architecture/source-tree.md]

**New Files to Create:**
```
tests/property_tests/
├── __init__.py
├── conftest.py                       # Hypothesis configuration
├── strategies.py                     # Custom Hypothesis strategies
├── test_ledger_properties.py         # Portfolio value, returns properties
├── test_order_execution_properties.py # Order execution properties
├── test_metrics_properties.py        # Metrics calculation properties
├── test_data_pipeline_properties.py  # Data pipeline properties
└── test_decimal_precision.py         # Decimal arithmetic properties
```

**Documentation Files:**
```
docs/testing/
└── property-based-testing.md         # Property testing guide
```

**Hypothesis Database:**
```
tests/.hypothesis/
└── examples/                         # Shrunk examples (git-ignored)
```

### Coding Standards
[Source: architecture/coding-standards.md]

**Hypothesis Test Structure:**
```python
from hypothesis import given, strategies as st, assume, example
from decimal import Decimal
import polars as pl

@given(
    starting_cash=st.decimals(
        min_value=Decimal("1000"),
        max_value=Decimal("1000000"),
        places=2
    ),
    position_count=st.integers(min_value=1, max_value=20)
)
@example(starting_cash=Decimal("0"), position_count=0)  # Edge case
@example(starting_cash=Decimal("100000"), position_count=1)  # Simple case
def test_portfolio_value_invariant(starting_cash, position_count):
    """Portfolio value must equal sum of positions plus cash.

    Property:
        portfolio_value = sum(position_values) + cash

    This invariant must hold for all portfolios regardless of:
    - Starting cash amount
    - Number of positions
    - Position prices and quantities
    - Buy/sell transactions
    """
    ledger = DecimalLedger(starting_cash=starting_cash)

    # Generate random positions
    for i in range(position_count):
        asset = Equity(sid=i, symbol=f"STOCK{i}")
        amount = Decimal(str(st.integers(min_value=1, max_value=1000).example()))
        price = Decimal(str(st.decimals(min_value=Decimal("1"), max_value=Decimal("500"), places=2).example()))

        position = DecimalPosition(
            asset=asset,
            amount=amount,
            cost_basis=price,
            last_sale_price=price
        )
        ledger.positions[asset] = position

    # Verify invariant
    expected_positions_value = sum(
        (pos.market_value for pos in ledger.positions.values()),
        start=Decimal("0")
    )
    expected_portfolio_value = expected_positions_value + ledger.cash

    # Exact Decimal equality (no epsilon)
    assert ledger.portfolio_value == expected_portfolio_value
```

**Custom Hypothesis Strategies:**
```python
from hypothesis import strategies as st
from decimal import Decimal

# Strategy for generating valid prices
def decimal_prices(
    min_value: Decimal = Decimal("0.01"),
    max_value: Decimal = Decimal("10000"),
    scale: int = 2
) -> st.SearchStrategy[Decimal]:
    """Generate Decimal prices with specified scale.

    Args:
        min_value: Minimum price (default: $0.01)
        max_value: Maximum price (default: $10,000)
        scale: Decimal places (default: 2 for equities)

    Returns:
        Hypothesis strategy generating Decimal prices
    """
    return st.decimals(
        min_value=min_value,
        max_value=max_value,
        places=scale,
        allow_nan=False,
        allow_infinity=False
    )

# Strategy for generating valid OHLCV bars
@st.composite
def ohlcv_bars(draw, num_bars: int = 10) -> pl.DataFrame:
    """Generate valid OHLCV bars satisfying H >= max(O,C), L <= min(O,C).

    Args:
        draw: Hypothesis draw function
        num_bars: Number of bars to generate

    Returns:
        Polars DataFrame with valid OHLCV data
    """
    bars = []
    for _ in range(num_bars):
        # Generate open and close
        open_price = draw(decimal_prices(scale=8))
        close_price = draw(decimal_prices(scale=8))

        # Generate high >= max(open, close)
        max_oc = max(open_price, close_price)
        high_price = draw(st.decimals(
            min_value=max_oc,
            max_value=max_oc + Decimal("10"),
            places=8
        ))

        # Generate low <= min(open, close)
        min_oc = min(open_price, close_price)
        low_price = draw(st.decimals(
            min_value=max(Decimal("0.01"), min_oc - Decimal("10")),
            max_value=min_oc,
            places=8
        ))

        volume = draw(st.decimals(
            min_value=Decimal("100"),
            max_value=Decimal("1000000"),
            places=2
        ))

        bars.append({
            "open": open_price,
            "high": high_price,
            "low": low_price,
            "close": close_price,
            "volume": volume
        })

    return pl.DataFrame(bars)
```

**Hypothesis Configuration:**
```python
# tests/conftest.py
from hypothesis import settings, Verbosity, Phase

# Configure Hypothesis profiles
settings.register_profile("quick", max_examples=100, deadline=None)
settings.register_profile("thorough", max_examples=1000, deadline=None)
settings.register_profile("ci", max_examples=500, deadline=None, verbosity=Verbosity.verbose)
settings.register_profile("debug", max_examples=10, verbosity=Verbosity.debug, phases=[Phase.generate, Phase.shrink])

# Load profile from environment
import os
settings.load_profile(os.getenv("HYPOTHESIS_PROFILE", "quick"))
```

### Zero-Mock Enforcement
[Source: architecture/coding-standards.md#zero-mock-enforcement-mandatory]

**Real Implementations Required:**
- Property tests must exercise real implementations (not mocked components)
- Property tests must generate actual random data (not predetermined sequences)
- Property tests must perform actual calculations (not simplified stubs)
- Property tests must verify actual invariants (not trivial tautologies)

**Forbidden Patterns:**
```python
# ❌ ABSOLUTELY FORBIDDEN
@given(value=st.decimals())
def test_portfolio_value_always_positive(value):
    # Trivial test: always passes by construction
    assert value >= Decimal("0") or value < Decimal("0")

@given(x=st.integers())
def test_identity(x):
    # Tautology: tests nothing
    assert x == x

# Using mocked components in property test
@given(cash=st.decimals())
def test_portfolio_with_mock(cash):
    mock_ledger = Mock()
    mock_ledger.cash = cash
    # Not testing real implementation!
    assert mock_ledger.cash == cash

# ✅ CORRECT IMPLEMENTATION
@given(
    starting_cash=st.decimals(min_value=Decimal("0"), max_value=Decimal("1000000"), places=2),
    positions=st.lists(
        st.tuples(
            st.decimals(min_value=Decimal("1"), max_value=Decimal("1000"), places=2),  # amount
            st.decimals(min_value=Decimal("1"), max_value=Decimal("500"), places=2)    # price
        ),
        min_size=0,
        max_size=20
    )
)
def test_portfolio_value_accounting_identity(starting_cash, positions):
    """Test actual accounting identity with real DecimalLedger."""
    # Create real ledger
    ledger = DecimalLedger(starting_cash=starting_cash)

    # Add real positions
    total_position_value = Decimal("0")
    for i, (amount, price) in enumerate(positions):
        asset = Equity(sid=i, symbol=f"STOCK{i}")
        position = DecimalPosition(
            asset=asset,
            amount=amount,
            cost_basis=price,
            last_sale_price=price
        )
        ledger.positions[asset] = position
        total_position_value += amount * price

    # Test real calculation
    expected = total_position_value + starting_cash
    actual = ledger.portfolio_value

    # Verify exact equality (testing real implementation)
    assert actual == expected, (
        f"Portfolio value accounting identity violated: "
        f"{actual} != {expected} "
        f"(positions: {total_position_value}, cash: {starting_cash})"
    )
```

### Testing Strategy

**Hypothesis Test Examples:**

```python
# Portfolio Value Invariant
@given(
    starting_cash=st.decimals(min_value=Decimal("1000"), max_value=Decimal("1000000"), places=2),
    transactions=st.lists(
        st.tuples(
            st.sampled_from(["buy", "sell"]),
            st.decimals(min_value=Decimal("1"), max_value=Decimal("100"), places=2),  # amount
            st.decimals(min_value=Decimal("1"), max_value=Decimal("500"), places=2)   # price
        ),
        min_size=0,
        max_size=50
    )
)
def test_portfolio_value_maintained_through_transactions(starting_cash, transactions):
    """Portfolio value equation must hold after any sequence of transactions."""
    ledger = DecimalLedger(starting_cash=starting_cash)
    asset = Equity(sid=1, symbol="TEST")

    for action, amount, price in transactions:
        try:
            if action == "buy":
                # Reduce cash, increase position
                cost = amount * price
                if ledger.cash >= cost:
                    ledger.cash -= cost
                    current_pos = ledger.positions.get(asset)
                    if current_pos:
                        new_amount = current_pos.amount + amount
                        ledger.positions[asset] = DecimalPosition(
                            asset=asset,
                            amount=new_amount,
                            cost_basis=price,
                            last_sale_price=price
                        )
                    else:
                        ledger.positions[asset] = DecimalPosition(
                            asset=asset,
                            amount=amount,
                            cost_basis=price,
                            last_sale_price=price
                        )
            else:  # sell
                current_pos = ledger.positions.get(asset)
                if current_pos and current_pos.amount >= amount:
                    revenue = amount * price
                    ledger.cash += revenue
                    new_amount = current_pos.amount - amount
                    if new_amount > Decimal("0"):
                        ledger.positions[asset] = DecimalPosition(
                            asset=asset,
                            amount=new_amount,
                            cost_basis=current_pos.cost_basis,
                            last_sale_price=price
                        )
                    else:
                        del ledger.positions[asset]

            # Verify invariant after each transaction
            positions_value = sum(
                (pos.market_value for pos in ledger.positions.values()),
                start=Decimal("0")
            )
            assert ledger.portfolio_value == positions_value + ledger.cash

        except (InsufficientFundsError, InvalidPositionError):
            # Expected exceptions are fine, just skip
            pass

# Returns Calculation Consistency
@given(
    start_value=st.decimals(min_value=Decimal("1000"), max_value=Decimal("1000000"), places=2),
    end_value=st.decimals(min_value=Decimal("1000"), max_value=Decimal("1000000"), places=2)
)
def test_returns_reconstruction(start_value, end_value):
    """Returns calculation must be reversible: (1 + return) × start = end."""
    assume(start_value > Decimal("0"))  # Avoid division by zero

    # Calculate returns
    returns = (end_value / start_value) - Decimal("1")

    # Reconstruct end value
    reconstructed_end = (Decimal("1") + returns) * start_value

    # Must match exactly (Decimal precision)
    assert reconstructed_end == end_value

# Commission Bounds
@given(
    order_value=st.decimals(min_value=Decimal("100"), max_value=Decimal("100000"), places=2),
    commission_rate=st.decimals(min_value=Decimal("0"), max_value=Decimal("0.01"), places=4)
)
def test_commission_bounds(order_value, commission_rate):
    """Commission must be non-negative and <= order value."""
    commission = order_value * commission_rate

    # Non-negative
    assert commission >= Decimal("0")

    # Cannot exceed order value (sanity check)
    assert commission <= order_value

# Drawdown Valid Range
@given(
    returns=st.lists(
        st.decimals(min_value=Decimal("-0.1"), max_value=Decimal("0.1"), places=4),
        min_size=10,
        max_size=252
    )
)
def test_max_drawdown_range(returns):
    """Max drawdown must be in range [-1, 0]."""
    returns_series = pl.Series("returns", returns)
    cumulative = (returns_series + Decimal("1")).cumprod()

    running_max = cumulative.cummax()
    drawdown = (cumulative - running_max) / running_max
    max_dd = Decimal(str(drawdown.min()))

    # Valid range
    assert max_dd <= Decimal("0"), "Drawdown must be non-positive"
    assert max_dd >= Decimal("-1"), "Drawdown cannot exceed 100% loss"

# Decimal Associativity
@given(
    a=st.decimals(min_value=Decimal("0"), max_value=Decimal("10000"), places=2),
    b=st.decimals(min_value=Decimal("0"), max_value=Decimal("10000"), places=2),
    c=st.decimals(min_value=Decimal("0"), max_value=Decimal("10000"), places=2)
)
def test_decimal_addition_associativity(a, b, c):
    """Decimal addition must be associative: (a + b) + c == a + (b + c)."""
    left = (a + b) + c
    right = a + (b + c)
    assert left == right

# OHLCV Relationships
@given(bars=ohlcv_bars(num_bars=100))
def test_ohlcv_relationships_preserved(bars):
    """OHLCV relationships must always be valid."""
    # High >= Open
    assert (bars["high"] >= bars["open"]).all()

    # High >= Close
    assert (bars["high"] >= bars["close"]).all()

    # Low <= Open
    assert (bars["low"] <= bars["open"]).all()

    # Low <= Close
    assert (bars["low"] <= bars["close"]).all()

    # High >= Low
    assert (bars["high"] >= bars["low"]).all()
```

**CI/CD Integration:**
```yaml
# .github/workflows/property-tests.yml
name: Property-Based Tests

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  schedule:
    - cron: '0 2 * * 0'  # Weekly thorough run

jobs:
  property-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install dependencies
        run: |
          pip install uv
          uv sync

      - name: Run property tests (CI profile)
        env:
          HYPOTHESIS_PROFILE: ci
        run: |
          pytest tests/property_tests/ \
            --hypothesis-show-statistics \
            -v

      - name: Archive shrunk examples
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: hypothesis-examples
          path: tests/.hypothesis/examples/
```

**Test Coverage Target:**
- All critical invariants tested with property-based tests
- 1000+ examples per property test
- Shrinking enabled to find minimal failing cases
- Integration with CI/CD for regression detection

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-01 | 1.0 | Initial story creation | Claude (Dev Agent) |

## Dev Agent Record

### Agent Model Used
(To be filled by Dev Agent)

### Debug Log References
(To be filled by Dev Agent)

### Completion Notes List
(To be filled by Dev Agent)

### File List
(To be filled by Dev Agent)

## QA Results
(To be filled by QA Agent)
