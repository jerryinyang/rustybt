# Story 4.1: Implement Latency Simulation

## Status
Draft

## Story

**As a** quantitative trader,
**I want** realistic latency simulation (network + broker + exchange),
**so that** backtests account for order submission delays and reflect live trading conditions.

## Acceptance Criteria

1. Latency model configurable (fixed, random distribution, or historical latency data)
2. Network latency component simulated (e.g., 5-50ms based on geographic distance)
3. Broker processing latency simulated (e.g., 1-10ms for order validation and routing)
4. Exchange matching latency simulated (e.g., 0.1-5ms for order matching)
5. Total latency applied to order submission: order_submission_time + latency = actual_execution_time
6. Price movement during latency period affects fill price (market orders filled at price after latency)
7. Configuration API allows per-broker latency profiles
8. Tests validate latency impact on order execution timing and fill prices
9. Performance overhead measured: latency simulation adds <5% to backtest time
10. Documentation explains latency configuration with realistic examples per broker type

## Tasks / Subtasks

- [ ] Design latency model architecture (AC: 1, 7)
  - [ ] Create `LatencyModel` abstract base class in `rustybt/finance/execution.py`
  - [ ] Implement `FixedLatencyModel` (constant latency value)
  - [ ] Implement `RandomLatencyModel` (uniform/normal distribution)
  - [ ] Implement `HistoricalLatencyModel` (replay from historical data)
  - [ ] Implement `CompositeLatencyModel` (network + broker + exchange components)
  - [ ] Add latency configuration to broker profiles (JSON/YAML format)
  - [ ] Document latency model API with examples

- [ ] Implement network latency component (AC: 2)
  - [ ] Add `NetworkLatency` class to model geographic distance delays
  - [ ] Support configurable latency ranges (e.g., 5-50ms for US-based trading)
  - [ ] Model latency based on broker location (US East, US West, Europe, Asia)
  - [ ] Add jitter simulation (realistic variance in network delays)
  - [ ] Use Decimal for time calculations to maintain precision

- [ ] Implement broker processing latency (AC: 3)
  - [ ] Add `BrokerProcessingLatency` class for order validation/routing delays
  - [ ] Support configurable processing time ranges (1-10ms typical)
  - [ ] Model validation overhead (complex orders take longer)
  - [ ] Model routing delays to different exchanges
  - [ ] Track processing time per order type

- [ ] Implement exchange matching latency (AC: 4)
  - [ ] Add `ExchangeMatchingLatency` class for order matching delays
  - [ ] Support configurable matching time ranges (0.1-5ms typical)
  - [ ] Model queue position effects (busy exchanges have higher latency)
  - [ ] Model priority matching (some exchanges prioritize certain order types)
  - [ ] Handle different exchange types (traditional vs. crypto exchanges)

- [ ] Integrate latency into order execution flow (AC: 5, 6)
  - [ ] Extend `ExecutionEngine` in `rustybt/finance/execution.py` to apply latency
  - [ ] Calculate total latency: network + broker + exchange
  - [ ] Adjust order execution time: submission_time + total_latency = execution_time
  - [ ] For market orders: fetch price at execution_time (after latency)
  - [ ] For limit orders: check if limit price would be filled at execution_time
  - [ ] Update order state tracking to record latency components
  - [ ] Log latency details for each order execution

- [ ] Implement broker-specific latency profiles (AC: 7)
  - [ ] Create latency profile configuration structure
  - [ ] Add default profiles for major brokers (Interactive Brokers, Binance, Bybit, etc.)
  - [ ] Support custom latency profiles via configuration files
  - [ ] Allow per-asset-class latency overrides (equities vs. crypto vs. futures)
  - [ ] Implement profile loading from JSON/YAML files
  - [ ] Validate latency profile configurations

- [ ] Write comprehensive tests (AC: 8, 9)
  - [ ] Unit test: Fixed latency model applies constant delay
  - [ ] Unit test: Random latency model generates values within expected range
  - [ ] Unit test: Composite latency sums network + broker + exchange components
  - [ ] Unit test: Market order fill price changes due to latency
  - [ ] Integration test: Backtest with latency vs. without latency shows execution time differences
  - [ ] Performance test: Measure backtest overhead with latency simulation (<5% target)
  - [ ] Property-based test: Latency always delays execution (never negative)
  - [ ] Property-based test: Total latency >= max(network, broker, exchange)

- [ ] Create documentation and examples (AC: 10)
  - [ ] Document latency model API in module docstrings
  - [ ] Create example latency profiles for major brokers
  - [ ] Write tutorial on configuring realistic latency for different markets
  - [ ] Document performance impact and optimization strategies
  - [ ] Provide example code for custom latency models

## Dev Notes

### Previous Story Context

From Story 3.8 (Multi-Resolution Aggregation):
- Polars lazy evaluation patterns established for performance-critical operations
- Decimal precision maintained throughout data processing pipeline
- Comprehensive validation framework with property-based testing
- Structured logging patterns using `structlog` for observability

### Architecture Context

**Source Tree References:** [Source: architecture/source-tree.md]
- Implementation location:
  - `rustybt/finance/execution.py` - Extend existing execution module with latency models
  - `rustybt/finance/slippage.py` - May need coordination with slippage models
- Test location:
  - `tests/finance/test_execution.py` - Add latency-specific tests
- Configuration location:
  - `config/broker_latency_profiles/` - Broker-specific latency configurations (new directory)

**Tech Stack Requirements:** [Source: architecture/tech-stack.md]
- **Python 3.12+**: Use modern type hints and pattern matching
- **Python Decimal**: For time calculations maintaining financial precision
- **numpy/scipy**: For statistical distributions in random latency models (optional)
- **pydantic 2.x+**: For latency profile validation

**Component Dependencies:**
- Extends `rustybt/finance/execution.py` (existing from Zipline)
- Coordinates with commission and slippage models
- Integrates with order execution pipeline
- May interact with `rustybt/live/brokers/` for live trading latency profiles

### Key Implementation Requirements

**Latency Model Architecture:**

```python
from abc import ABC, abstractmethod
from decimal import Decimal
from typing import Dict, Any, Optional
from dataclasses import dataclass
import pandas as pd
from pydantic import BaseModel, Field

@dataclass(frozen=True)
class LatencyComponents:
    """Breakdown of latency components for an order."""
    network_ms: Decimal
    broker_processing_ms: Decimal
    exchange_matching_ms: Decimal
    total_ms: Decimal

class LatencyModel(ABC):
    """Abstract base class for latency simulation models."""

    @abstractmethod
    def calculate_latency(
        self,
        order: Any,  # Order object
        current_time: pd.Timestamp,
        broker_name: str
    ) -> LatencyComponents:
        """Calculate latency components for an order.

        Args:
            order: Order being submitted
            current_time: Current simulation time
            broker_name: Name of broker (for profile lookup)

        Returns:
            LatencyComponents with breakdown of latency sources
        """
        pass

class FixedLatencyModel(LatencyModel):
    """Fixed latency model with constant delays."""

    def __init__(
        self,
        network_ms: Decimal,
        broker_ms: Decimal,
        exchange_ms: Decimal
    ):
        """Initialize fixed latency model.

        Args:
            network_ms: Network latency in milliseconds
            broker_ms: Broker processing latency in milliseconds
            exchange_ms: Exchange matching latency in milliseconds
        """
        self.network_ms = network_ms
        self.broker_ms = broker_ms
        self.exchange_ms = exchange_ms

    def calculate_latency(
        self,
        order: Any,
        current_time: pd.Timestamp,
        broker_name: str
    ) -> LatencyComponents:
        """Calculate fixed latency."""
        total_ms = self.network_ms + self.broker_ms + self.exchange_ms

        return LatencyComponents(
            network_ms=self.network_ms,
            broker_processing_ms=self.broker_ms,
            exchange_matching_ms=self.exchange_ms,
            total_ms=total_ms
        )

class RandomLatencyModel(LatencyModel):
    """Random latency model with statistical distributions."""

    def __init__(
        self,
        network_range_ms: tuple[Decimal, Decimal],
        broker_range_ms: tuple[Decimal, Decimal],
        exchange_range_ms: tuple[Decimal, Decimal],
        distribution: str = "uniform"  # "uniform" or "normal"
    ):
        """Initialize random latency model.

        Args:
            network_range_ms: (min, max) network latency in milliseconds
            broker_range_ms: (min, max) broker processing latency in milliseconds
            exchange_range_ms: (min, max) exchange matching latency in milliseconds
            distribution: Distribution type ("uniform" or "normal")
        """
        self.network_range = network_range_ms
        self.broker_range = broker_range_ms
        self.exchange_range = exchange_range_ms
        self.distribution = distribution

    def calculate_latency(
        self,
        order: Any,
        current_time: pd.Timestamp,
        broker_name: str
    ) -> LatencyComponents:
        """Calculate random latency from configured distributions."""
        import random

        def sample_range(min_val: Decimal, max_val: Decimal) -> Decimal:
            """Sample value from range based on distribution type."""
            if self.distribution == "uniform":
                value = random.uniform(float(min_val), float(max_val))
            elif self.distribution == "normal":
                mean = (float(min_val) + float(max_val)) / 2
                std = (float(max_val) - float(min_val)) / 6  # 3-sigma rule
                value = random.gauss(mean, std)
                value = max(float(min_val), min(float(max_val), value))  # Clip to range
            else:
                raise ValueError(f"Unknown distribution: {self.distribution}")

            return Decimal(str(value))

        network_ms = sample_range(*self.network_range)
        broker_ms = sample_range(*self.broker_range)
        exchange_ms = sample_range(*self.exchange_range)
        total_ms = network_ms + broker_ms + exchange_ms

        return LatencyComponents(
            network_ms=network_ms,
            broker_processing_ms=broker_ms,
            exchange_matching_ms=exchange_ms,
            total_ms=total_ms
        )

class CompositeLatencyModel(LatencyModel):
    """Composite latency model combining multiple latency sources."""

    def __init__(
        self,
        network_model: LatencyModel,
        broker_model: LatencyModel,
        exchange_model: LatencyModel
    ):
        """Initialize composite latency model.

        Args:
            network_model: Model for network latency
            broker_model: Model for broker processing latency
            exchange_model: Model for exchange matching latency
        """
        self.network_model = network_model
        self.broker_model = broker_model
        self.exchange_model = exchange_model

    def calculate_latency(
        self,
        order: Any,
        current_time: pd.Timestamp,
        broker_name: str
    ) -> LatencyComponents:
        """Calculate composite latency from sub-models."""
        network = self.network_model.calculate_latency(order, current_time, broker_name)
        broker = self.broker_model.calculate_latency(order, current_time, broker_name)
        exchange = self.exchange_model.calculate_latency(order, current_time, broker_name)

        return LatencyComponents(
            network_ms=network.network_ms,
            broker_processing_ms=broker.broker_processing_ms,
            exchange_matching_ms=exchange.exchange_matching_ms,
            total_ms=network.total_ms + broker.total_ms + exchange.total_ms
        )

class LatencyProfileConfig(BaseModel):
    """Configuration for broker-specific latency profiles."""
    broker_name: str
    network_latency_ms: tuple[float, float] = Field(description="(min, max) network latency")
    broker_processing_ms: tuple[float, float] = Field(description="(min, max) broker processing")
    exchange_matching_ms: tuple[float, float] = Field(description="(min, max) exchange matching")
    distribution: str = Field(default="uniform", description="Distribution type")

    model_config = {
        "json_schema_extra": {
            "examples": [
                {
                    "broker_name": "Interactive Brokers",
                    "network_latency_ms": [10.0, 30.0],
                    "broker_processing_ms": [2.0, 8.0],
                    "exchange_matching_ms": [0.5, 3.0],
                    "distribution": "normal"
                },
                {
                    "broker_name": "Binance",
                    "network_latency_ms": [20.0, 50.0],
                    "broker_processing_ms": [1.0, 5.0],
                    "exchange_matching_ms": [0.1, 2.0],
                    "distribution": "uniform"
                }
            ]
        }
    }
```

**Integration with Execution Engine:**

```python
class ExecutionEngine:
    """Enhanced execution engine with latency simulation."""

    def __init__(
        self,
        latency_model: Optional[LatencyModel] = None,
        data_portal: Any = None,
        logger: Any = None
    ):
        """Initialize execution engine.

        Args:
            latency_model: Optional latency model for simulation
            data_portal: Data source for price lookup
            logger: Structured logger instance
        """
        self.latency_model = latency_model
        self.data_portal = data_portal
        self.logger = logger or structlog.get_logger()

    def execute_order(
        self,
        order: Any,
        current_time: pd.Timestamp,
        broker_name: str = "default"
    ) -> Any:  # ExecutionResult
        """Execute order with optional latency simulation.

        Args:
            order: Order to execute
            current_time: Current simulation time
            broker_name: Broker name for latency profile lookup

        Returns:
            ExecutionResult with fill details including latency
        """
        # Calculate latency if model configured
        if self.latency_model:
            latency = self.latency_model.calculate_latency(
                order, current_time, broker_name
            )

            # Adjust execution time by total latency
            execution_time = current_time + pd.Timedelta(
                milliseconds=float(latency.total_ms)
            )

            self.logger.debug(
                "order_latency_applied",
                order_id=order.id,
                submission_time=str(current_time),
                execution_time=str(execution_time),
                network_ms=str(latency.network_ms),
                broker_ms=str(latency.broker_processing_ms),
                exchange_ms=str(latency.exchange_matching_ms),
                total_ms=str(latency.total_ms)
            )
        else:
            # No latency simulation
            execution_time = current_time
            latency = None

        # Fetch price at execution time (after latency)
        if order.order_type == "market":
            fill_price = self.data_portal.get_price(
                order.asset,
                execution_time,
                field="close"  # Or "mid" if bid/ask available
            )
        elif order.order_type == "limit":
            # Check if limit price would be filled at execution time
            market_price = self.data_portal.get_price(
                order.asset,
                execution_time,
                field="close"
            )

            # Simplified limit order logic (actual implementation more complex)
            if (order.amount > 0 and market_price <= order.limit_price) or \
               (order.amount < 0 and market_price >= order.limit_price):
                fill_price = order.limit_price
            else:
                # Order not filled
                return None
        else:
            raise ValueError(f"Unsupported order type: {order.order_type}")

        # Log execution details
        self.logger.info(
            "order_executed",
            order_id=order.id,
            asset=order.asset.symbol,
            amount=str(order.amount),
            fill_price=str(fill_price),
            execution_time=str(execution_time),
            latency_ms=str(latency.total_ms) if latency else "0"
        )

        # Return execution result (simplified)
        return ExecutionResult(
            order=order,
            fill_price=fill_price,
            execution_time=execution_time,
            latency=latency
        )

@dataclass
class ExecutionResult:
    """Result of order execution."""
    order: Any
    fill_price: Decimal
    execution_time: pd.Timestamp
    latency: Optional[LatencyComponents] = None
```

**Example Latency Profile Configuration (YAML):**

```yaml
# config/broker_latency_profiles/interactive_brokers.yaml
broker_name: "Interactive Brokers"
asset_classes:
  equities:
    network_latency_ms: [10.0, 30.0]  # US-based trading
    broker_processing_ms: [2.0, 8.0]
    exchange_matching_ms: [0.5, 3.0]
    distribution: "normal"
  futures:
    network_latency_ms: [10.0, 30.0]
    broker_processing_ms: [1.0, 5.0]
    exchange_matching_ms: [0.1, 2.0]
    distribution: "normal"

# config/broker_latency_profiles/binance.yaml
broker_name: "Binance"
asset_classes:
  crypto:
    network_latency_ms: [20.0, 50.0]  # International routing
    broker_processing_ms: [1.0, 5.0]
    exchange_matching_ms: [0.1, 2.0]
    distribution: "uniform"
```

### Coding Standards

**Type Hints:** [Source: architecture/coding-standards.md#python-coding-standards]
- 100% type hint coverage for public APIs
- Use `Decimal` for time calculations to maintain precision

**Docstrings:** [Source: architecture/coding-standards.md#python-coding-standards]
- Google-style docstrings for all public classes and methods

**Error Handling:** [Source: architecture/coding-standards.md#error-handling]
- Create custom exception: `LatencyConfigurationError` for invalid latency profiles
- Log all latency calculations at DEBUG level
- Log execution time adjustments at INFO level

**Logging:** [Source: architecture/coding-standards.md#logging]
```python
import structlog
logger = structlog.get_logger()

logger.debug(
    "latency_calculated",
    order_id=order.id,
    network_ms=str(latency.network_ms),
    broker_ms=str(latency.broker_processing_ms),
    exchange_ms=str(latency.exchange_matching_ms),
    total_ms=str(latency.total_ms)
)
```

**Zero-Mock Enforcement:** [Source: architecture/coding-standards.md#zero-mock-enforcement-mandatory]
- NO hardcoded latency values in production code (use configuration)
- All latency calculations must use real statistical distributions
- All validation functions must perform real checks
- Tests must use real latency models, not mocks

### Testing

#### Testing Standards [Source: architecture/testing-strategy.md]

**Test File Location:**
- `tests/finance/test_execution.py` - Add latency-specific tests
- `tests/finance/test_latency_models.py` - New file for latency model tests

**Test Frameworks:**
- **pytest >= 7.2.0**: Primary test framework
- **pytest-cov >= 3.0.0**: Coverage reporting (target: ≥90%)
- **hypothesis >= 6.x+**: Property-based testing
- **pytest-benchmark**: Performance testing

**Unit Tests:**
```python
import pytest
from decimal import Decimal
from rustybt.finance.execution import (
    FixedLatencyModel,
    RandomLatencyModel,
    LatencyComponents
)

def test_fixed_latency_model():
    """Fixed latency model returns constant values."""
    model = FixedLatencyModel(
        network_ms=Decimal("10.0"),
        broker_ms=Decimal("5.0"),
        exchange_ms=Decimal("2.0")
    )

    latency = model.calculate_latency(order=None, current_time=None, broker_name="test")

    assert latency.network_ms == Decimal("10.0")
    assert latency.broker_processing_ms == Decimal("5.0")
    assert latency.exchange_matching_ms == Decimal("2.0")
    assert latency.total_ms == Decimal("17.0")

def test_random_latency_within_range():
    """Random latency model generates values within configured ranges."""
    model = RandomLatencyModel(
        network_range_ms=(Decimal("5.0"), Decimal("15.0")),
        broker_range_ms=(Decimal("1.0"), Decimal("10.0")),
        exchange_range_ms=(Decimal("0.1"), Decimal("5.0")),
        distribution="uniform"
    )

    # Generate multiple samples to test distribution
    for _ in range(100):
        latency = model.calculate_latency(order=None, current_time=None, broker_name="test")

        assert Decimal("5.0") <= latency.network_ms <= Decimal("15.0")
        assert Decimal("1.0") <= latency.broker_processing_ms <= Decimal("10.0")
        assert Decimal("0.1") <= latency.exchange_matching_ms <= Decimal("5.0")
        assert latency.total_ms == (
            latency.network_ms +
            latency.broker_processing_ms +
            latency.exchange_matching_ms
        )

def test_market_order_fill_price_changes_with_latency():
    """Market order fill price reflects price movement during latency."""
    # Setup: price increases from $100 to $101 during latency period
    # Without latency: fill at $100
    # With latency: fill at $101

    # Test implementation depends on ExecutionEngine and DataPortal
    pass  # Implement based on execution engine design
```

**Property-Based Tests:**
```python
from hypothesis import given, strategies as st

@given(
    network_ms=st.decimals(min_value=Decimal("0"), max_value=Decimal("100")),
    broker_ms=st.decimals(min_value=Decimal("0"), max_value=Decimal("50")),
    exchange_ms=st.decimals(min_value=Decimal("0"), max_value=Decimal("20"))
)
def test_total_latency_equals_sum_of_components(network_ms, broker_ms, exchange_ms):
    """Total latency always equals sum of component latencies."""
    model = FixedLatencyModel(
        network_ms=network_ms,
        broker_ms=broker_ms,
        exchange_ms=exchange_ms
    )

    latency = model.calculate_latency(order=None, current_time=None, broker_name="test")

    assert latency.total_ms == network_ms + broker_ms + exchange_ms

@given(
    network_range=st.tuples(
        st.decimals(min_value=Decimal("0"), max_value=Decimal("50")),
        st.decimals(min_value=Decimal("50"), max_value=Decimal("100"))
    )
)
def test_latency_never_negative(network_range):
    """Latency components are never negative."""
    model = RandomLatencyModel(
        network_range_ms=network_range,
        broker_range_ms=(Decimal("1"), Decimal("10")),
        exchange_range_ms=(Decimal("0.1"), Decimal("5")),
        distribution="uniform"
    )

    for _ in range(100):
        latency = model.calculate_latency(order=None, current_time=None, broker_name="test")

        assert latency.network_ms >= Decimal("0")
        assert latency.broker_processing_ms >= Decimal("0")
        assert latency.exchange_matching_ms >= Decimal("0")
        assert latency.total_ms >= Decimal("0")
```

**Performance Tests:**
```python
@pytest.mark.benchmark
def test_latency_simulation_overhead(benchmark):
    """Latency simulation adds <5% to backtest time."""

    def run_backtest_with_latency():
        # Run standard backtest with latency simulation
        pass  # Implement based on backtest engine

    result = benchmark(run_backtest_with_latency)

    # Compare with baseline backtest without latency
    # Assert overhead < 5%
    pass  # Implement performance comparison
```

**Zero-Mock Enforcement:** [Source: architecture/coding-standards.md#zero-mock-enforcement-mandatory]
- Use real latency calculations in all tests
- No hardcoded latency values or mock implementations
- Tests must exercise actual distribution sampling
- Validation tests must use real latency models

**Coverage Target:** [Source: architecture/testing-strategy.md#test-coverage-targets]
- Overall: ≥90%
- Latency module: ≥90%

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-01 | 1.0 | Initial story creation | SM (Bob) |

## Dev Agent Record

### Agent Model Used

_To be populated by Dev Agent_

### Debug Log References

_To be populated by Dev Agent_

### Completion Notes List

_To be populated by Dev Agent_

### File List

_To be populated by Dev Agent_

## QA Results

_To be populated by QA Agent_
