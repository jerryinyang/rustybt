# Story 4.2: Implement Partial Fill Model

## Status
Draft

## Story

**As a** quantitative trader,
**I want** partial fill simulation based on order size vs. available volume,
**so that** backtests reflect reality of large orders that cannot be fully filled immediately.

## Acceptance Criteria

1. Volume-based partial fill logic: if order_size > available_volume × fill_ratio, partially fill
2. Fill ratio configurable (e.g., can fill up to 10% of bar's volume without impact)
3. Multi-bar fill simulation: unfilled portion persists to next bar(s) until fully filled or timeout
4. Order state tracking for partial fills (PartiallyFilled state, cumulative fill quantity)
5. Average fill price calculated across multiple partial fills
6. Market impact modeled: larger orders relative to volume get worse average prices
7. Configuration supports different fill models (aggressive: fill more quickly, conservative: fill slower)
8. Tests validate partial fill behavior with large orders in low-volume scenarios
9. Integration test demonstrates realistic partial fill across multiple bars
10. Documentation explains partial fill logic and configuration options

## Tasks / Subtasks

- [ ] Design partial fill model architecture (AC: 1, 2, 7)
  - [ ] Create `PartialFillModel` abstract base class in `rustybt/finance/execution.py`
  - [ ] Implement `VolumeBasedFillModel` (fill based on available volume)
  - [ ] Implement `AggressiveFillModel` (fills quickly, accepts market impact)
  - [ ] Implement `ConservativeFillModel` (fills slowly, minimizes market impact)
  - [ ] Add configurable fill_ratio parameter (default: 0.10 = 10% of bar volume)
  - [ ] Document partial fill model API with examples

- [ ] Implement volume-based partial fill logic (AC: 1, 2)
  - [ ] Calculate available volume per bar from data portal
  - [ ] Calculate fillable quantity: min(remaining_order_size, available_volume × fill_ratio)
  - [ ] Update order state with partial fill quantity
  - [ ] Track unfilled quantity for next bar
  - [ ] Use Decimal for all quantity calculations

- [ ] Implement multi-bar fill persistence (AC: 3)
  - [ ] Create `OrderTracker` class to manage open orders across bars
  - [ ] Persist partially filled orders to next bar
  - [ ] Attempt to fill remaining quantity at each new bar
  - [ ] Support order timeout (cancel after N bars or time period)
  - [ ] Support fill-or-kill (FOK) and immediate-or-cancel (IOC) order types
  - [ ] Log multi-bar fill progress

- [ ] Implement order state tracking (AC: 4)
  - [ ] Extend order state enum: New, PartiallyFilled, Filled, Canceled
  - [ ] Track cumulative filled quantity across partial fills
  - [ ] Track cumulative fill value (quantity × price) for average price calculation
  - [ ] Track fill timestamps for each partial fill
  - [ ] Update order object with partial fill history

- [ ] Calculate average fill price (AC: 5)
  - [ ] Implement volume-weighted average price (VWAP) calculation
  - [ ] Formula: average_fill_price = total_fill_value / total_filled_quantity
  - [ ] Use Decimal for precise VWAP calculation
  - [ ] Update order object with average fill price after each partial fill
  - [ ] Log average fill price calculation

- [ ] Model market impact for large orders (AC: 6)
  - [ ] Calculate market impact based on order size / daily volume ratio
  - [ ] Apply price slippage for large orders (worse prices for bigger fills)
  - [ ] Implement impact function: impact = k × (order_size / volume)^α
  - [ ] Coordinate with slippage models from Story 4.3
  - [ ] Make market impact configurable per asset class

- [ ] Implement fill model variants (AC: 7)
  - [ ] AggressiveFillModel: higher fill_ratio (20-30%), accepts more market impact
  - [ ] ConservativeFillModel: lower fill_ratio (5-10%), minimizes market impact
  - [ ] BalancedFillModel: moderate fill_ratio (10-15%), balances speed vs. impact
  - [ ] Allow custom fill models via configuration
  - [ ] Document trade-offs between fill models

- [ ] Write comprehensive tests (AC: 8, 9)
  - [ ] Unit test: Small order (< 10% volume) fills completely in one bar
  - [ ] Unit test: Large order (> 10% volume) fills partially over multiple bars
  - [ ] Unit test: Partial fill state tracking updates correctly
  - [ ] Unit test: Average fill price calculated correctly across partial fills
  - [ ] Unit test: Market impact increases with order size
  - [ ] Integration test: Multi-bar fill simulation with realistic volume data
  - [ ] Property-based test: Cumulative filled quantity never exceeds order size
  - [ ] Property-based test: Average fill price always between min and max fill prices

- [ ] Create documentation and examples (AC: 10)
  - [ ] Document partial fill model API in module docstrings
  - [ ] Create examples showing partial fill behavior for different order sizes
  - [ ] Document fill model variants and configuration options
  - [ ] Provide guidance on choosing fill models for different strategies
  - [ ] Document market impact modeling approach

## Dev Notes

### Previous Story Context

From Story 4.1 (Latency Simulation):
- Latency models integrated into execution pipeline
- Order execution timing and state tracking established
- Structured logging patterns for order execution events

From Story 3.8 (Multi-Resolution Aggregation):
- Decimal precision maintained throughout data processing
- Polars lazy evaluation for performance-critical operations
- Property-based testing patterns established

### Architecture Context

**Source Tree References:** [Source: architecture/source-tree.md]
- Implementation location:
  - `rustybt/finance/execution.py` - Extend with partial fill models
  - `rustybt/finance/decimal/blotter.py` - May need order state tracking extensions
- Test location:
  - `tests/finance/test_execution.py` - Add partial fill tests
  - `tests/finance/test_partial_fills.py` - New file for dedicated partial fill tests

**Tech Stack Requirements:** [Source: architecture/tech-stack.md]
- **Python 3.12+**: Use modern type hints and pattern matching
- **Python Decimal**: For quantity and price calculations
- **Polars**: For volume data access from data portal

**Component Dependencies:**
- Extends `rustybt/finance/execution.py` (extended in Story 4.1)
- Integrates with `rustybt/data/polars/data_portal.py` for volume data
- Coordinates with slippage models (Story 4.3)
- May interact with commission models (Story 4.4)

### Key Implementation Requirements

**Partial Fill Model Architecture:**

```python
from abc import ABC, abstractmethod
from decimal import Decimal
from typing import Optional, List
from dataclasses import dataclass, field
from enum import Enum
import pandas as pd

class OrderState(Enum):
    """Order states for tracking fill status."""
    NEW = "new"
    PARTIALLY_FILLED = "partially_filled"
    FILLED = "filled"
    CANCELED = "canceled"
    REJECTED = "rejected"

@dataclass
class PartialFill:
    """Record of a single partial fill."""
    timestamp: pd.Timestamp
    quantity: Decimal
    price: Decimal
    value: Decimal = field(init=False)

    def __post_init__(self):
        """Calculate fill value."""
        self.value = self.quantity * self.price

@dataclass
class Order:
    """Order with partial fill tracking."""
    id: str
    asset: Any
    amount: Decimal  # Positive = buy, negative = sell
    order_type: str  # "market", "limit", etc.
    limit_price: Optional[Decimal] = None
    state: OrderState = OrderState.NEW
    partial_fills: List[PartialFill] = field(default_factory=list)
    created_at: Optional[pd.Timestamp] = None
    timeout_bars: Optional[int] = None  # Cancel after N bars if not filled

    @property
    def filled_quantity(self) -> Decimal:
        """Total quantity filled across all partial fills."""
        return sum(fill.quantity for fill in self.partial_fills)

    @property
    def remaining_quantity(self) -> Decimal:
        """Remaining quantity to be filled."""
        return abs(self.amount) - self.filled_quantity

    @property
    def is_fully_filled(self) -> bool:
        """Check if order is fully filled."""
        return self.remaining_quantity <= Decimal("0")

    @property
    def average_fill_price(self) -> Optional[Decimal]:
        """Volume-weighted average fill price."""
        if not self.partial_fills:
            return None

        total_value = sum(fill.value for fill in self.partial_fills)
        total_quantity = sum(fill.quantity for fill in self.partial_fills)

        if total_quantity == Decimal("0"):
            return None

        return total_value / total_quantity

class PartialFillModel(ABC):
    """Abstract base class for partial fill simulation."""

    @abstractmethod
    def calculate_fill(
        self,
        order: Order,
        bar_volume: Decimal,
        bar_price: Decimal,
        current_time: pd.Timestamp
    ) -> Optional[PartialFill]:
        """Calculate partial fill for current bar.

        Args:
            order: Order being filled
            bar_volume: Available volume in current bar
            bar_price: Price for current bar
            current_time: Current simulation time

        Returns:
            PartialFill if order can be filled, None otherwise
        """
        pass

class VolumeBasedFillModel(PartialFillModel):
    """Volume-based partial fill model."""

    def __init__(
        self,
        fill_ratio: Decimal = Decimal("0.10"),  # 10% of bar volume
        market_impact_factor: Decimal = Decimal("0.01")  # 1% impact coefficient
    ):
        """Initialize volume-based fill model.

        Args:
            fill_ratio: Maximum fraction of bar volume to fill
            market_impact_factor: Market impact coefficient
        """
        self.fill_ratio = fill_ratio
        self.market_impact_factor = market_impact_factor

    def calculate_fill(
        self,
        order: Order,
        bar_volume: Decimal,
        bar_price: Decimal,
        current_time: pd.Timestamp
    ) -> Optional[PartialFill]:
        """Calculate volume-based partial fill."""
        import structlog
        logger = structlog.get_logger()

        # Calculate available fill quantity
        available_quantity = bar_volume * self.fill_ratio
        remaining = order.remaining_quantity

        # Determine fill quantity (lesser of available and remaining)
        fill_quantity = min(available_quantity, remaining)

        if fill_quantity <= Decimal("0"):
            logger.debug(
                "no_fill_available",
                order_id=order.id,
                bar_volume=str(bar_volume),
                available_quantity=str(available_quantity)
            )
            return None

        # Calculate market impact (larger orders get worse prices)
        order_volume_ratio = fill_quantity / bar_volume if bar_volume > 0 else Decimal("0")
        market_impact = self.market_impact_factor * order_volume_ratio

        # Apply market impact to price (directional: buy orders slip up, sell orders slip down)
        if order.amount > 0:  # Buy order
            fill_price = bar_price * (Decimal("1") + market_impact)
        else:  # Sell order
            fill_price = bar_price * (Decimal("1") - market_impact)

        # Create partial fill record
        partial_fill = PartialFill(
            timestamp=current_time,
            quantity=fill_quantity,
            price=fill_price
        )

        logger.info(
            "partial_fill_executed",
            order_id=order.id,
            asset=order.asset.symbol if hasattr(order.asset, 'symbol') else str(order.asset),
            fill_quantity=str(fill_quantity),
            fill_price=str(fill_price),
            remaining_quantity=str(remaining - fill_quantity),
            market_impact_pct=str(market_impact * Decimal("100"))
        )

        return partial_fill

class AggressiveFillModel(VolumeBasedFillModel):
    """Aggressive fill model (fills quickly, accepts higher impact)."""

    def __init__(self):
        """Initialize aggressive fill model."""
        super().__init__(
            fill_ratio=Decimal("0.25"),  # 25% of bar volume
            market_impact_factor=Decimal("0.02")  # Higher impact accepted
        )

class ConservativeFillModel(VolumeBasedFillModel):
    """Conservative fill model (fills slowly, minimizes impact)."""

    def __init__(self):
        """Initialize conservative fill model."""
        super().__init__(
            fill_ratio=Decimal("0.05"),  # 5% of bar volume
            market_impact_factor=Decimal("0.005")  # Lower impact
        )

class BalancedFillModel(VolumeBasedFillModel):
    """Balanced fill model (moderate fill speed and impact)."""

    def __init__(self):
        """Initialize balanced fill model."""
        super().__init__(
            fill_ratio=Decimal("0.10"),  # 10% of bar volume
            market_impact_factor=Decimal("0.01")  # Moderate impact
        )
```

**Order Tracker for Multi-Bar Fills:**

```python
class OrderTracker:
    """Tracks partially filled orders across multiple bars."""

    def __init__(self, fill_model: PartialFillModel):
        """Initialize order tracker.

        Args:
            fill_model: Partial fill model to use
        """
        self.fill_model = fill_model
        self.open_orders: Dict[str, Order] = {}
        self.logger = structlog.get_logger()

    def add_order(self, order: Order, current_time: pd.Timestamp) -> None:
        """Add new order to tracker.

        Args:
            order: Order to track
            current_time: Current simulation time
        """
        order.created_at = current_time
        self.open_orders[order.id] = order

        self.logger.info(
            "order_created",
            order_id=order.id,
            asset=order.asset.symbol if hasattr(order.asset, 'symbol') else str(order.asset),
            amount=str(order.amount),
            order_type=order.order_type
        )

    def process_bar(
        self,
        current_time: pd.Timestamp,
        data_portal: Any
    ) -> List[Order]:
        """Process current bar and attempt to fill open orders.

        Args:
            current_time: Current simulation time
            data_portal: Data source for price and volume

        Returns:
            List of orders that were fully filled in this bar
        """
        filled_orders = []

        for order_id, order in list(self.open_orders.items()):
            # Check timeout
            if order.timeout_bars is not None:
                bars_elapsed = (current_time - order.created_at).total_seconds() / 60  # Assumes minute bars
                if bars_elapsed > order.timeout_bars:
                    order.state = OrderState.CANCELED
                    del self.open_orders[order_id]
                    self.logger.warning(
                        "order_timeout",
                        order_id=order.id,
                        bars_elapsed=int(bars_elapsed)
                    )
                    continue

            # Get bar data
            bar_volume = data_portal.get_volume(order.asset, current_time)
            bar_price = data_portal.get_price(order.asset, current_time, field="close")

            # Attempt partial fill
            partial_fill = self.fill_model.calculate_fill(
                order, bar_volume, bar_price, current_time
            )

            if partial_fill:
                order.partial_fills.append(partial_fill)

                # Update order state
                if order.is_fully_filled:
                    order.state = OrderState.FILLED
                    filled_orders.append(order)
                    del self.open_orders[order_id]

                    self.logger.info(
                        "order_fully_filled",
                        order_id=order.id,
                        total_fills=len(order.partial_fills),
                        average_price=str(order.average_fill_price)
                    )
                else:
                    order.state = OrderState.PARTIALLY_FILLED

        return filled_orders

    def get_open_orders(self) -> List[Order]:
        """Get list of currently open orders."""
        return list(self.open_orders.values())
```

### Coding Standards

**Type Hints:** [Source: architecture/coding-standards.md#python-coding-standards]
- 100% type hint coverage for public APIs
- Use `Decimal` for all quantity and price calculations

**Docstrings:** [Source: architecture/coding-standards.md#python-coding-standards]
- Google-style docstrings for all public classes and methods

**Logging:** [Source: architecture/coding-standards.md#logging]
```python
import structlog
logger = structlog.get_logger()

logger.info(
    "partial_fill_executed",
    order_id=order.id,
    fill_quantity=str(fill_quantity),
    fill_price=str(fill_price),
    cumulative_filled=str(order.filled_quantity),
    remaining=str(order.remaining_quantity)
)
```

**Zero-Mock Enforcement:** [Source: architecture/coding-standards.md#zero-mock-enforcement-mandatory]
- All fill calculations must use real volume data
- No hardcoded fill quantities or prices
- Market impact calculations must use real formulas
- Tests must use real partial fill models

### Testing

#### Testing Standards [Source: architecture/testing-strategy.md]

**Test File Location:**
- `tests/finance/test_execution.py` - Add partial fill integration tests
- `tests/finance/test_partial_fills.py` - Dedicated partial fill model tests

**Test Frameworks:**
- **pytest >= 7.2.0**: Primary test framework
- **pytest-cov >= 3.0.0**: Coverage reporting (target: ≥90%)
- **hypothesis >= 6.x+**: Property-based testing

**Unit Tests:**
```python
import pytest
from decimal import Decimal
from rustybt.finance.execution import (
    VolumeBasedFillModel,
    Order,
    OrderState,
    PartialFill
)

def test_small_order_fills_completely():
    """Small order (<10% volume) fills completely in one bar."""
    model = VolumeBasedFillModel(fill_ratio=Decimal("0.10"))

    order = Order(
        id="order-1",
        asset=mock_asset,
        amount=Decimal("100"),  # 100 shares
        order_type="market"
    )

    bar_volume = Decimal("10000")  # 10,000 shares available
    bar_price = Decimal("50.00")

    partial_fill = model.calculate_fill(
        order, bar_volume, bar_price, pd.Timestamp("2023-01-01 10:00")
    )

    assert partial_fill is not None
    assert partial_fill.quantity == Decimal("100")  # Full order filled
    assert order.is_fully_filled

def test_large_order_fills_partially():
    """Large order (>10% volume) fills partially over multiple bars."""
    model = VolumeBasedFillModel(fill_ratio=Decimal("0.10"))

    order = Order(
        id="order-2",
        asset=mock_asset,
        amount=Decimal("2000"),  # 2,000 shares
        order_type="market"
    )

    bar_volume = Decimal("10000")  # 10,000 shares available
    bar_price = Decimal("50.00")

    # First bar: fill 10% of volume = 1,000 shares
    partial_fill_1 = model.calculate_fill(
        order, bar_volume, bar_price, pd.Timestamp("2023-01-01 10:00")
    )

    assert partial_fill_1 is not None
    assert partial_fill_1.quantity == Decimal("1000")
    order.partial_fills.append(partial_fill_1)
    assert not order.is_fully_filled
    assert order.remaining_quantity == Decimal("1000")

    # Second bar: fill remaining 1,000 shares
    partial_fill_2 = model.calculate_fill(
        order, bar_volume, bar_price, pd.Timestamp("2023-01-01 10:01")
    )

    assert partial_fill_2 is not None
    assert partial_fill_2.quantity == Decimal("1000")
    order.partial_fills.append(partial_fill_2)
    assert order.is_fully_filled

def test_average_fill_price_calculation():
    """Average fill price calculated correctly across partial fills."""
    order = Order(
        id="order-3",
        asset=mock_asset,
        amount=Decimal("200"),
        order_type="market"
    )

    # Add partial fills at different prices
    order.partial_fills.append(PartialFill(
        timestamp=pd.Timestamp("2023-01-01 10:00"),
        quantity=Decimal("100"),
        price=Decimal("50.00")
    ))

    order.partial_fills.append(PartialFill(
        timestamp=pd.Timestamp("2023-01-01 10:01"),
        quantity=Decimal("100"),
        price=Decimal("52.00")
    ))

    # VWAP = (100 × 50 + 100 × 52) / 200 = 51.00
    expected_vwap = Decimal("51.00")
    assert order.average_fill_price == expected_vwap
```

**Property-Based Tests:**
```python
from hypothesis import given, strategies as st

@given(
    order_size=st.decimals(min_value=Decimal("1"), max_value=Decimal("10000")),
    bar_volume=st.decimals(min_value=Decimal("1000"), max_value=Decimal("100000"))
)
def test_filled_quantity_never_exceeds_order_size(order_size, bar_volume):
    """Cumulative filled quantity never exceeds order size."""
    model = VolumeBasedFillModel(fill_ratio=Decimal("0.10"))

    order = Order(
        id="order-test",
        asset=mock_asset,
        amount=order_size,
        order_type="market"
    )

    # Simulate multiple bars
    for i in range(100):
        if order.is_fully_filled:
            break

        partial_fill = model.calculate_fill(
            order, bar_volume, Decimal("50"), pd.Timestamp(f"2023-01-01 10:{i:02d}")
        )

        if partial_fill:
            order.partial_fills.append(partial_fill)

    # Property: filled quantity <= order size
    assert order.filled_quantity <= order_size

@given(
    fills=st.lists(
        st.tuples(
            st.decimals(min_value=Decimal("1"), max_value=Decimal("1000")),  # quantity
            st.decimals(min_value=Decimal("10"), max_value=Decimal("100"))   # price
        ),
        min_size=2, max_size=10
    )
)
def test_average_price_between_min_max(fills):
    """Average fill price always between min and max fill prices."""
    order = Order(
        id="order-test",
        asset=mock_asset,
        amount=sum(qty for qty, _ in fills),
        order_type="market"
    )

    for i, (qty, price) in enumerate(fills):
        order.partial_fills.append(PartialFill(
            timestamp=pd.Timestamp(f"2023-01-01 10:{i:02d}"),
            quantity=qty,
            price=price
        ))

    avg_price = order.average_fill_price
    min_price = min(price for _, price in fills)
    max_price = max(price for _, price in fills)

    assert min_price <= avg_price <= max_price
```

**Coverage Target:** [Source: architecture/testing-strategy.md#test-coverage-targets]
- Overall: ≥90%
- Partial fill module: ≥90%

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-01 | 1.0 | Initial story creation | SM (Bob) |

## Dev Agent Record

### Agent Model Used

_To be populated by Dev Agent_

### Debug Log References

_To be populated by Dev Agent_

### Completion Notes List

_To be populated by Dev Agent_

### File List

_To be populated by Dev Agent_

## QA Results

_To be populated by QA Agent_
