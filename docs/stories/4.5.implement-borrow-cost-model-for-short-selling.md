# Story 4.5: Implement Borrow Cost Model for Short Selling

## Status
Draft

## Story

**As a** quantitative trader,
**I want** borrow cost simulation for short positions,
**so that** backtests account for stock borrow fees that impact short strategy profitability.

## Acceptance Criteria

1. BorrowCostModel calculates daily interest on short position value
2. Borrow rate configurable per asset (easy-to-borrow: 0.3%, hard-to-borrow: 5-50%+)
3. Borrow cost accrues daily and debits from cash balance
4. Borrow rate lookup supports external data sources (e.g., CSV with symbol → rate mapping)
5. Default borrow rate applied when specific rate unavailable
6. Borrow cost tracked separately in performance reporting (itemized cost breakdown)
7. Tests validate daily accrual calculation accuracy using Decimal arithmetic
8. Integration test demonstrates short strategy with borrow costs over extended period
9. Property-based test ensures borrow cost always reduces short position profitability
10. Documentation explains borrow cost impact with example calculations

## Story Dependencies

**Depends On:**
- Story 4.1 (Latency Simulation) - Execution timing established for end-of-day cost accrual
- Story 4.2 (Partial Fill Model) - Position tracking framework for accumulated costs
- Story 4.3 (Multiple Slippage Models) - Transaction cost modeling patterns
- Story 4.4 (Tiered Commission Models) - DecimalLedger integration patterns

**Enables:**
- Story 4.6 (Overnight Financing) - Complete financing cost framework
- Story 4.7 (Portfolio Allocator) - Comprehensive cost accounting in multi-strategy portfolios
- Story 4.8 (Risk Manager) - Position-level cost tracking for risk analysis

## Tasks / Subtasks

- [ ] Design borrow cost model architecture (AC: 1, 2, 4, 5)
  - [ ] Create `BorrowCostModel` class in `rustybt/finance/costs.py` (new module)
  - [ ] Define interface: `accrue_costs(ledger, current_time) -> BorrowCostResult`
  - [ ] Support per-asset borrow rates with dictionary/CSV lookup
  - [ ] Implement rate lookup from CSV/dict data source with caching
  - [ ] Add default borrow rate fallback with logging
  - [ ] Create `BorrowRateProvider` abstraction for extensibility
  - [ ] Document borrow cost API with examples

- [ ] Implement daily borrow cost accrual (AC: 1, 3)
  - [ ] Calculate daily cost: abs(position_value) × (annual_rate / 365)
  - [ ] Debit cost from cash balance daily using DecimalLedger
  - [ ] Track accrued costs per position over lifetime
  - [ ] Apply costs only to short positions (amount < 0)
  - [ ] Use Decimal arithmetic for all calculations
  - [ ] Log cost accrual events with structlog

- [ ] Implement borrow rate data sources (AC: 4, 5)
  - [ ] Create `CSVBorrowRateProvider` for CSV file loading
  - [ ] Create `DictBorrowRateProvider` for in-memory rates
  - [ ] Support dynamic rate updates (time-varying rates)
  - [ ] Implement rate lookup with symbol normalization
  - [ ] Add validation for rate bounds (0% to 100%)
  - [ ] Cache loaded rates for performance
  - [ ] Handle missing rate data gracefully

- [ ] Integrate with position tracking (AC: 3, 6)
  - [ ] Add `accumulated_borrow_cost` field to DecimalPosition
  - [ ] Accumulate costs over position lifetime
  - [ ] Report costs separately in performance metrics
  - [ ] Track cost per day for analysis
  - [ ] Integrate with existing ledger cash operations
  - [ ] Update position close logic to finalize costs

- [ ] Write comprehensive tests (AC: 7, 8, 9)
  - [ ] Unit test: Daily accrual calculation accuracy
  - [ ] Unit test: Borrow rate lookup from CSV
  - [ ] Unit test: Default rate fallback
  - [ ] Unit test: Cost accumulation over time
  - [ ] Unit test: Hard-to-borrow vs. easy-to-borrow rates
  - [ ] Unit test: Rate data validation and error handling
  - [ ] Integration test: 30+ day short strategy with costs
  - [ ] Property test: Costs always reduce profitability
  - [ ] Property test: Daily rate bounds (0 to annual_rate/365)
  - [ ] Property test: Cost proportional to position size

- [ ] Create documentation and examples (AC: 10)
  - [ ] Document borrow cost mechanics with formulas
  - [ ] Create CSV rate file format examples
  - [ ] Provide hard-to-borrow vs. easy-to-borrow examples
  - [ ] Document integration with DecimalLedger
  - [ ] Include real-world examples (equity short selling)
  - [ ] Document performance impact analysis

## Dev Notes

### Previous Story Context

From Story 4.4 (Tiered Commission Models):
- DecimalLedger integration patterns established for cost debits
- Cost tracking and reporting framework in place
- Decimal precision maintained for all financial calculations
- Structured logging patterns for cost events

From Story 4.3 (Multiple Slippage Models):
- Transaction cost modeling patterns established
- Configuration-driven model selection
- Property-based testing for cost invariants
- Zero-mock enforcement for financial calculations

From Story 4.2 (Partial Fill Model):
- Position state tracking with cumulative values
- Order lifecycle management patterns
- Integration with execution pipeline

From Story 4.1 (Latency Simulation):
- Execution timing framework for end-of-day operations
- Structured logging with structlog
- Configuration management patterns

### Architecture Context

**Source Tree References:** [Source: architecture/source-tree.md]
- Implementation location:
  - `rustybt/finance/costs.py` - Primary borrow cost model implementations (new module)
  - `rustybt/finance/decimal/ledger.py` - Integration with DecimalLedger
  - `rustybt/finance/decimal/position.py` - Position-level cost tracking
- Test location:
  - `tests/finance/test_costs.py` - Comprehensive borrow cost model tests (new file)
  - `tests/finance/test_decimal_ledger.py` - Integration tests with ledger
- Configuration location:
  - `config/borrow_rates/` - CSV files with symbol-to-rate mappings (new directory)

**Tech Stack Requirements:** [Source: architecture/tech-stack.md]
- **Python 3.12+**: Use modern type hints and pattern matching
- **Python Decimal**: For precise cost calculations (mandatory for finance)
- **Polars**: For efficient CSV loading and rate lookups
- **structlog**: For structured logging of cost events
- **pydantic 2.x+**: For configuration validation

**Component Dependencies:**
- Extends `rustybt/finance/decimal/ledger.py` (DecimalLedger for cash operations)
- Integrates with `rustybt/finance/decimal/position.py` (DecimalPosition for cost tracking)
- Uses `rustybt/data/polars/` for CSV rate data loading
- Coordinates with `rustybt/finance/execution.py` for end-of-day triggers

### Key Implementation Requirements

**Borrow Cost Model Architecture:**

```python
from abc import ABC, abstractmethod
from decimal import Decimal
from typing import Dict, Any, Optional, Protocol
from dataclasses import dataclass, field
from pathlib import Path
from enum import Enum
import pandas as pd
import polars as pl
import structlog

logger = structlog.get_logger()

class BorrowRateType(Enum):
    """Classification of borrow rates by difficulty."""
    EASY_TO_BORROW = "easy"  # 0.3% - 1%
    MODERATE = "moderate"  # 1% - 5%
    HARD_TO_BORROW = "hard"  # 5% - 50%+
    EXTREMELY_HARD = "extreme"  # 50%+

@dataclass(frozen=True)
class BorrowCostResult:
    """Result of daily borrow cost accrual."""
    total_cost: Decimal  # Total cost across all positions
    position_costs: Dict[str, Decimal]  # Cost per asset symbol
    timestamp: pd.Timestamp
    positions_processed: int
    metadata: Dict[str, Any] = field(default_factory=dict)

    def __str__(self) -> str:
        """String representation for logging."""
        return (
            f"BorrowCostResult(total={self.total_cost}, "
            f"positions={self.positions_processed}, "
            f"timestamp={self.timestamp})"
        )

class BorrowRateProvider(Protocol):
    """Protocol for borrow rate data sources."""

    def get_rate(
        self,
        symbol: str,
        timestamp: pd.Timestamp
    ) -> Optional[Decimal]:
        """Get borrow rate for a symbol at a given time.

        Args:
            symbol: Asset symbol (e.g., "AAPL", "GME")
            timestamp: Time for rate lookup (supports time-varying rates)

        Returns:
            Annual borrow rate as decimal (e.g., 0.003 = 0.3%) or None if unavailable
        """
        ...

    def get_rate_type(self, symbol: str, rate: Decimal) -> BorrowRateType:
        """Classify borrow rate difficulty."""
        ...

class DictBorrowRateProvider:
    """In-memory dictionary-based borrow rate provider.

    Fast lookup for static rate configurations.
    """

    def __init__(
        self,
        rates: Dict[str, Decimal],
        normalize_symbols: bool = True
    ):
        """Initialize dictionary rate provider.

        Args:
            rates: Mapping of symbol to annual borrow rate
            normalize_symbols: Convert symbols to uppercase for lookup
        """
        self.normalize_symbols = normalize_symbols

        # Normalize symbols if configured
        if normalize_symbols:
            self.rates = {k.upper(): v for k, v in rates.items()}
        else:
            self.rates = dict(rates)

        logger.info(
            "dict_borrow_rate_provider_initialized",
            num_symbols=len(self.rates),
            sample_rates=str(dict(list(self.rates.items())[:3]))
        )

    def get_rate(
        self,
        symbol: str,
        timestamp: pd.Timestamp
    ) -> Optional[Decimal]:
        """Get borrow rate from dictionary."""
        lookup_symbol = symbol.upper() if self.normalize_symbols else symbol

        rate = self.rates.get(lookup_symbol)

        if rate is not None:
            logger.debug(
                "borrow_rate_found",
                symbol=symbol,
                rate=str(rate),
                rate_type=self.get_rate_type(symbol, rate).value
            )

        return rate

    def get_rate_type(self, symbol: str, rate: Decimal) -> BorrowRateType:
        """Classify borrow rate difficulty."""
        if rate < Decimal("0.01"):  # < 1%
            return BorrowRateType.EASY_TO_BORROW
        elif rate < Decimal("0.05"):  # < 5%
            return BorrowRateType.MODERATE
        elif rate < Decimal("0.50"):  # < 50%
            return BorrowRateType.HARD_TO_BORROW
        else:
            return BorrowRateType.EXTREMELY_HARD

class CSVBorrowRateProvider:
    """CSV file-based borrow rate provider.

    Supports time-varying rates with date columns.

    CSV Format:
    ```
    symbol,date,annual_rate
    AAPL,2023-01-01,0.003
    GME,2023-01-01,0.25
    GME,2023-02-01,0.15
    ```
    """

    def __init__(
        self,
        csv_path: Path,
        normalize_symbols: bool = True,
        cache_rates: bool = True
    ):
        """Initialize CSV rate provider.

        Args:
            csv_path: Path to CSV file with borrow rates
            normalize_symbols: Convert symbols to uppercase
            cache_rates: Cache loaded rates in memory
        """
        self.csv_path = csv_path
        self.normalize_symbols = normalize_symbols
        self.cache_rates = cache_rates
        self._rate_cache: Dict[tuple[str, pd.Timestamp], Decimal] = {}

        # Load CSV using Polars for performance
        self.df = self._load_csv()

        logger.info(
            "csv_borrow_rate_provider_initialized",
            csv_path=str(csv_path),
            num_rows=len(self.df),
            unique_symbols=self.df.select("symbol").n_unique()
        )

    def _load_csv(self) -> pl.DataFrame:
        """Load and validate CSV file."""
        try:
            df = pl.read_csv(self.csv_path)

            # Validate required columns
            required_cols = {"symbol", "annual_rate"}
            if not required_cols.issubset(df.columns):
                raise ValueError(
                    f"CSV missing required columns. "
                    f"Expected: {required_cols}, Got: {set(df.columns)}"
                )

            # Normalize symbols if configured
            if self.normalize_symbols:
                df = df.with_columns(
                    pl.col("symbol").str.to_uppercase().alias("symbol")
                )

            # Convert date column if present (for time-varying rates)
            if "date" in df.columns:
                df = df.with_columns(
                    pl.col("date").str.strptime(pl.Date, "%Y-%m-%d").alias("date")
                )

            # Validate rate bounds (0% to 100%)
            invalid_rates = df.filter(
                (pl.col("annual_rate") < 0.0) | (pl.col("annual_rate") > 1.0)
            )

            if len(invalid_rates) > 0:
                logger.warning(
                    "invalid_borrow_rates_found",
                    num_invalid=len(invalid_rates),
                    sample=invalid_rates.head(5).to_dicts()
                )
                # Filter out invalid rates
                df = df.filter(
                    (pl.col("annual_rate") >= 0.0) & (pl.col("annual_rate") <= 1.0)
                )

            return df

        except Exception as e:
            logger.error(
                "csv_load_failed",
                csv_path=str(self.csv_path),
                error=str(e)
            )
            raise BorrowRateLoadError(f"Failed to load CSV: {e}") from e

    def get_rate(
        self,
        symbol: str,
        timestamp: pd.Timestamp
    ) -> Optional[Decimal]:
        """Get borrow rate from CSV."""
        lookup_symbol = symbol.upper() if self.normalize_symbols else symbol

        # Check cache first
        cache_key = (lookup_symbol, timestamp)
        if self.cache_rates and cache_key in self._rate_cache:
            return self._rate_cache[cache_key]

        # Query CSV for rate
        if "date" in self.df.columns:
            # Time-varying rates: find most recent rate <= timestamp
            filtered = self.df.filter(
                (pl.col("symbol") == lookup_symbol) &
                (pl.col("date") <= timestamp.date())
            ).sort("date", descending=True)

            if len(filtered) > 0:
                rate = Decimal(str(filtered[0, "annual_rate"]))
            else:
                rate = None
        else:
            # Static rates: direct lookup
            filtered = self.df.filter(pl.col("symbol") == lookup_symbol)

            if len(filtered) > 0:
                rate = Decimal(str(filtered[0, "annual_rate"]))
            else:
                rate = None

        # Cache result
        if self.cache_rates and rate is not None:
            self._rate_cache[cache_key] = rate

        if rate is not None:
            logger.debug(
                "borrow_rate_found_in_csv",
                symbol=symbol,
                rate=str(rate),
                rate_type=self.get_rate_type(symbol, rate).value
            )

        return rate

    def get_rate_type(self, symbol: str, rate: Decimal) -> BorrowRateType:
        """Classify borrow rate difficulty."""
        if rate < Decimal("0.01"):  # < 1%
            return BorrowRateType.EASY_TO_BORROW
        elif rate < Decimal("0.05"):  # < 5%
            return BorrowRateType.MODERATE
        elif rate < Decimal("0.50"):  # < 50%
            return BorrowRateType.HARD_TO_BORROW
        else:
            return BorrowRateType.EXTREMELY_HARD

class BorrowCostModel:
    """Borrow cost model for short position financing.

    Calculates daily interest on short position values based on
    configurable borrow rates per asset.

    Daily cost formula:
        daily_cost = abs(position_value) × (annual_rate / 365)

    Example:
        Short 100 shares of AAPL at $150 with 0.3% annual rate:
        - Position value: $15,000
        - Daily cost: $15,000 × (0.003 / 365) = $0.123
        - Annual cost (if held 365 days): ~$45
    """

    def __init__(
        self,
        rate_provider: BorrowRateProvider,
        default_rate: Decimal = Decimal("0.003"),  # 0.3% annual
        days_in_year: int = 365
    ):
        """Initialize borrow cost model.

        Args:
            rate_provider: Provider for borrow rate lookups
            default_rate: Default annual rate when specific rate unavailable
            days_in_year: Days per year for daily rate calculation (365 or 360)
        """
        self.rate_provider = rate_provider
        self.default_rate = default_rate
        self.days_in_year = days_in_year

        logger.info(
            "borrow_cost_model_initialized",
            default_rate=str(default_rate),
            days_in_year=days_in_year,
            provider_type=type(rate_provider).__name__
        )

    def calculate_daily_cost(
        self,
        symbol: str,
        position_value: Decimal,
        current_time: pd.Timestamp
    ) -> tuple[Decimal, Decimal]:
        """Calculate daily borrow cost for a short position.

        Args:
            symbol: Asset symbol
            position_value: Absolute value of position (positive)
            current_time: Current timestamp for rate lookup

        Returns:
            Tuple of (daily_cost, annual_rate_used)
        """
        # Get borrow rate (try specific rate, fall back to default)
        annual_rate = self.rate_provider.get_rate(symbol, current_time)

        if annual_rate is None:
            annual_rate = self.default_rate
            logger.debug(
                "using_default_borrow_rate",
                symbol=symbol,
                default_rate=str(self.default_rate)
            )
        else:
            logger.debug(
                "using_symbol_borrow_rate",
                symbol=symbol,
                annual_rate=str(annual_rate)
            )

        # Calculate daily rate
        daily_rate = annual_rate / Decimal(str(self.days_in_year))

        # Calculate daily cost
        daily_cost = position_value * daily_rate

        return daily_cost, annual_rate

    def accrue_costs(
        self,
        ledger: Any,  # DecimalLedger
        current_time: pd.Timestamp
    ) -> BorrowCostResult:
        """Accrue borrow costs for all short positions.

        Debits cash from ledger and tracks accumulated costs per position.

        Args:
            ledger: DecimalLedger with positions
            current_time: Current simulation time

        Returns:
            BorrowCostResult with cost details
        """
        total_cost = Decimal("0")
        position_costs: Dict[str, Decimal] = {}
        positions_processed = 0

        # Iterate over all positions in ledger
        for asset, position in ledger.positions.items():
            # Only process short positions (negative amount)
            if position.amount < Decimal("0"):
                # Get symbol for rate lookup
                symbol = asset.symbol if hasattr(asset, 'symbol') else str(asset)

                # Calculate position value (absolute)
                position_value = abs(position.market_value)

                # Calculate daily cost
                daily_cost, annual_rate = self.calculate_daily_cost(
                    symbol, position_value, current_time
                )

                # Debit from cash
                ledger.cash -= daily_cost

                # Track accumulated cost in position
                if not hasattr(position, 'accumulated_borrow_cost'):
                    position.accumulated_borrow_cost = Decimal("0")

                position.accumulated_borrow_cost += daily_cost

                # Record cost
                position_costs[symbol] = daily_cost
                total_cost += daily_cost
                positions_processed += 1

                logger.info(
                    "borrow_cost_accrued",
                    symbol=symbol,
                    position_value=str(position_value),
                    annual_rate=str(annual_rate),
                    daily_cost=str(daily_cost),
                    accumulated_cost=str(position.accumulated_borrow_cost),
                    cash_after_debit=str(ledger.cash)
                )

        # Create result
        result = BorrowCostResult(
            total_cost=total_cost,
            position_costs=position_costs,
            timestamp=current_time,
            positions_processed=positions_processed,
            metadata={
                "default_rate": str(self.default_rate),
                "days_in_year": self.days_in_year
            }
        )

        if positions_processed > 0:
            logger.info(
                "borrow_costs_accrued_summary",
                total_cost=str(total_cost),
                positions_processed=positions_processed,
                timestamp=str(current_time)
            )

        return result

class BorrowRateLoadError(Exception):
    """Raised when borrow rate data fails to load."""
    pass

class BorrowCostCalculationError(Exception):
    """Raised when borrow cost calculation fails."""
    pass
```

**Example Borrow Rate CSV:**

```csv
# config/borrow_rates/default_rates.csv
symbol,annual_rate,description
AAPL,0.003,Easy to borrow - large cap tech
MSFT,0.003,Easy to borrow - large cap tech
TSLA,0.015,Moderate - volatile stock
GME,0.25,Hard to borrow - meme stock
AMC,0.35,Hard to borrow - high short interest
DWAC,0.50,Extremely hard to borrow - speculation
```

**Example Time-Varying Borrow Rates CSV:**

```csv
# config/borrow_rates/historical_rates.csv
symbol,date,annual_rate,notes
GME,2021-01-01,0.05,Normal rate before squeeze
GME,2021-01-15,0.80,During squeeze - extremely hard to borrow
GME,2021-02-01,0.35,Post-squeeze - still elevated
GME,2021-03-01,0.15,Normalizing
AAPL,2021-01-01,0.003,Stable easy-to-borrow rate
```

**Integration with DecimalPosition:**

```python
# Extension to rustybt/finance/decimal/position.py
from decimal import Decimal
from dataclasses import dataclass, field

@dataclass
class DecimalPosition:
    """Position tracking with borrow cost accumulation."""

    asset: Any
    amount: Decimal  # Positive = long, negative = short
    cost_basis: Decimal
    market_value: Decimal
    accumulated_borrow_cost: Decimal = field(default_factory=lambda: Decimal("0"))
    accumulated_financing: Decimal = field(default_factory=lambda: Decimal("0"))

    @property
    def is_short(self) -> bool:
        """Check if position is short."""
        return self.amount < Decimal("0")

    @property
    def total_costs(self) -> Decimal:
        """Total accumulated costs (borrow + financing + commissions)."""
        return self.accumulated_borrow_cost + self.accumulated_financing

    @property
    def realized_pnl_net_of_costs(self) -> Decimal:
        """Realized P&L after all costs."""
        # This would be calculated on position close
        gross_pnl = self.market_value - self.cost_basis
        return gross_pnl - self.total_costs
```

### Coding Standards

**Type Hints:** [Source: architecture/coding-standards.md#python-coding-standards]
- 100% type hint coverage for public APIs
- Use `Decimal` for all financial calculations (rates, costs, position values)
- Use `Protocol` for extensible interfaces (BorrowRateProvider)

**Docstrings:** [Source: architecture/coding-standards.md#python-coding-standards]
- Google-style docstrings for all public classes and methods
- Include calculation formulas in model docstrings
- Document CSV format expectations

**Error Handling:** [Source: architecture/coding-standards.md#error-handling]
- Create custom exceptions: `BorrowRateLoadError`, `BorrowCostCalculationError`
- Log warnings when using default rates
- Validate rate bounds (0% to 100%)
- Handle missing data gracefully

```python
class BorrowRateLoadError(Exception):
    """Raised when borrow rate data fails to load."""
    pass

class BorrowCostCalculationError(Exception):
    """Raised when borrow cost calculation fails."""
    pass

# Example error handling
try:
    rate_provider = CSVBorrowRateProvider(csv_path=Path("rates.csv"))
except BorrowRateLoadError as e:
    logger.error(
        "failed_to_load_borrow_rates",
        csv_path=str(csv_path),
        error=str(e)
    )
    # Fall back to default rates
    rate_provider = DictBorrowRateProvider(rates={})
```

**Logging:** [Source: architecture/coding-standards.md#logging]
```python
import structlog
logger = structlog.get_logger()

logger.info(
    "borrow_cost_accrued",
    symbol=symbol,
    position_value=str(position_value),
    annual_rate=str(annual_rate),
    daily_cost=str(daily_cost),
    accumulated_cost=str(position.accumulated_borrow_cost)
)

logger.warning(
    "using_default_borrow_rate",
    symbol=symbol,
    default_rate=str(self.default_rate),
    reason="rate_not_found_in_provider"
)
```

**Zero-Mock Enforcement:** [Source: architecture/coding-standards.md#zero-mock-enforcement-mandatory]
- NO hardcoded borrow rates in production code (use configuration)
- All cost calculations must use real Decimal arithmetic
- All validation functions must perform real checks
- Tests must use real BorrowCostModel instances with real rate providers

### Testing

#### Testing Standards [Source: architecture/testing-strategy.md]

**Test File Location:**
- `tests/finance/test_costs.py` - Comprehensive borrow cost model tests (new file)
- `tests/finance/test_decimal_ledger.py` - Integration tests with ledger

**Test Frameworks:**
- **pytest >= 7.2.0**: Primary test framework
- **pytest-cov >= 3.0.0**: Coverage reporting (target: ≥90%)
- **hypothesis >= 6.x+**: Property-based testing

**Unit Tests:**

```python
import pytest
from decimal import Decimal
from pathlib import Path
import pandas as pd
from rustybt.finance.costs import (
    BorrowCostModel,
    DictBorrowRateProvider,
    CSVBorrowRateProvider,
    BorrowRateType,
    BorrowCostResult
)

def test_daily_accrual_calculation_easy_to_borrow():
    """Daily accrual calculation for easy-to-borrow stock (0.3%)."""
    # Setup: AAPL at 0.3% annual rate
    rates = {"AAPL": Decimal("0.003")}
    provider = DictBorrowRateProvider(rates)
    model = BorrowCostModel(provider, days_in_year=365)

    # Short position: 100 shares at $150 = $15,000 value
    position_value = Decimal("15000.00")
    symbol = "AAPL"
    current_time = pd.Timestamp("2023-01-01")

    # Calculate daily cost
    daily_cost, annual_rate = model.calculate_daily_cost(
        symbol, position_value, current_time
    )

    # Expected: $15,000 × (0.003 / 365) = $0.12328767...
    expected_daily_cost = position_value * (Decimal("0.003") / Decimal("365"))

    assert daily_cost == expected_daily_cost
    assert annual_rate == Decimal("0.003")

    # Verify cost magnitude (should be small for easy-to-borrow)
    assert daily_cost < Decimal("1.00")  # Less than $1/day

def test_daily_accrual_calculation_hard_to_borrow():
    """Daily accrual calculation for hard-to-borrow stock (25%)."""
    # Setup: GME at 25% annual rate during squeeze
    rates = {"GME": Decimal("0.25")}
    provider = DictBorrowRateProvider(rates)
    model = BorrowCostModel(provider, days_in_year=365)

    # Short position: 100 shares at $200 = $20,000 value
    position_value = Decimal("20000.00")
    symbol = "GME"
    current_time = pd.Timestamp("2021-01-15")

    # Calculate daily cost
    daily_cost, annual_rate = model.calculate_daily_cost(
        symbol, position_value, current_time
    )

    # Expected: $20,000 × (0.25 / 365) = $13.698630...
    expected_daily_cost = position_value * (Decimal("0.25") / Decimal("365"))

    assert daily_cost == expected_daily_cost
    assert annual_rate == Decimal("0.25")

    # Verify cost magnitude (should be significant for hard-to-borrow)
    assert daily_cost > Decimal("10.00")  # More than $10/day

def test_borrow_rate_lookup_from_dict():
    """Borrow rate lookup from dictionary provider."""
    rates = {
        "AAPL": Decimal("0.003"),
        "GME": Decimal("0.25"),
        "TSLA": Decimal("0.015")
    }
    provider = DictBorrowRateProvider(rates, normalize_symbols=True)

    # Test exact match
    assert provider.get_rate("AAPL", pd.Timestamp("2023-01-01")) == Decimal("0.003")

    # Test case insensitivity
    assert provider.get_rate("aapl", pd.Timestamp("2023-01-01")) == Decimal("0.003")

    # Test missing symbol
    assert provider.get_rate("UNKNOWN", pd.Timestamp("2023-01-01")) is None

def test_borrow_rate_lookup_from_csv(tmp_path):
    """Borrow rate lookup from CSV file."""
    # Create temporary CSV file
    csv_content = """symbol,annual_rate
AAPL,0.003
GME,0.25
TSLA,0.015
"""
    csv_path = tmp_path / "rates.csv"
    csv_path.write_text(csv_content)

    # Load CSV
    provider = CSVBorrowRateProvider(csv_path, normalize_symbols=True)

    # Test lookup
    assert provider.get_rate("AAPL", pd.Timestamp("2023-01-01")) == Decimal("0.003")
    assert provider.get_rate("GME", pd.Timestamp("2023-01-01")) == Decimal("0.25")

def test_default_rate_fallback():
    """Default rate used when specific rate unavailable."""
    rates = {"AAPL": Decimal("0.003")}
    provider = DictBorrowRateProvider(rates)
    default_rate = Decimal("0.005")  # 0.5% default
    model = BorrowCostModel(provider, default_rate=default_rate)

    position_value = Decimal("10000.00")
    current_time = pd.Timestamp("2023-01-01")

    # Known symbol
    daily_cost_aapl, rate_aapl = model.calculate_daily_cost(
        "AAPL", position_value, current_time
    )
    assert rate_aapl == Decimal("0.003")

    # Unknown symbol (should use default)
    daily_cost_unknown, rate_unknown = model.calculate_daily_cost(
        "UNKNOWN", position_value, current_time
    )
    assert rate_unknown == default_rate

    # Cost should be higher for unknown (default 0.5% > AAPL 0.3%)
    assert daily_cost_unknown > daily_cost_aapl

def test_cost_accumulation_over_30_days():
    """Cost accumulation over 30-day holding period."""
    rates = {"TSLA": Decimal("0.015")}  # 1.5% annual
    provider = DictBorrowRateProvider(rates)
    model = BorrowCostModel(provider)

    # Mock ledger and position
    ledger = MockLedger()
    position = MockPosition(
        asset=MockAsset(symbol="TSLA"),
        amount=Decimal("-100"),  # Short 100 shares
        market_value=Decimal("-25000.00")  # At $250/share
    )
    ledger.positions = {position.asset: position}
    ledger.cash = Decimal("100000.00")

    # Accrue costs daily for 30 days
    start_date = pd.Timestamp("2023-01-01")
    accumulated_costs = []

    for day in range(30):
        current_time = start_date + pd.Timedelta(days=day)
        result = model.accrue_costs(ledger, current_time)

        accumulated_costs.append(position.accumulated_borrow_cost)

    # Expected total cost for 30 days:
    # Daily: $25,000 × (0.015 / 365) = $1.027397...
    # 30 days: $1.027397 × 30 = $30.821917...
    expected_total = Decimal("25000.00") * (Decimal("0.015") / Decimal("365")) * Decimal("30")

    assert position.accumulated_borrow_cost == pytest.approx(float(expected_total), rel=1e-6)

    # Verify cash was debited
    assert ledger.cash < Decimal("100000.00")
    cash_debited = Decimal("100000.00") - ledger.cash
    assert cash_debited == pytest.approx(float(expected_total), rel=1e-6)

def test_rate_type_classification():
    """Borrow rate type classification."""
    provider = DictBorrowRateProvider({})

    # Easy to borrow
    assert provider.get_rate_type("AAPL", Decimal("0.003")) == BorrowRateType.EASY_TO_BORROW

    # Moderate
    assert provider.get_rate_type("TSLA", Decimal("0.015")) == BorrowRateType.MODERATE

    # Hard to borrow
    assert provider.get_rate_type("GME", Decimal("0.25")) == BorrowRateType.HARD_TO_BORROW

    # Extremely hard
    assert provider.get_rate_type("DWAC", Decimal("0.80")) == BorrowRateType.EXTREMELY_HARD

def test_csv_rate_validation_invalid_rates(tmp_path):
    """CSV provider filters out invalid rates."""
    # CSV with invalid rates (negative, > 100%)
    csv_content = """symbol,annual_rate
AAPL,0.003
INVALID1,-0.05
INVALID2,1.5
GME,0.25
"""
    csv_path = tmp_path / "rates.csv"
    csv_path.write_text(csv_content)

    provider = CSVBorrowRateProvider(csv_path)

    # Valid rates should be accessible
    assert provider.get_rate("AAPL", pd.Timestamp("2023-01-01")) == Decimal("0.003")
    assert provider.get_rate("GME", pd.Timestamp("2023-01-01")) == Decimal("0.25")

    # Invalid rates should be filtered out
    assert provider.get_rate("INVALID1", pd.Timestamp("2023-01-01")) is None
    assert provider.get_rate("INVALID2", pd.Timestamp("2023-01-01")) is None

def test_time_varying_rates_from_csv(tmp_path):
    """CSV provider handles time-varying rates."""
    csv_content = """symbol,date,annual_rate
GME,2021-01-01,0.05
GME,2021-01-15,0.80
GME,2021-02-01,0.35
"""
    csv_path = tmp_path / "rates.csv"
    csv_path.write_text(csv_content)

    provider = CSVBorrowRateProvider(csv_path)

    # Before squeeze
    rate_jan1 = provider.get_rate("GME", pd.Timestamp("2021-01-10"))
    assert rate_jan1 == Decimal("0.05")

    # During squeeze
    rate_jan20 = provider.get_rate("GME", pd.Timestamp("2021-01-20"))
    assert rate_jan20 == Decimal("0.80")

    # After squeeze
    rate_feb15 = provider.get_rate("GME", pd.Timestamp("2021-02-15"))
    assert rate_feb15 == Decimal("0.35")
```

**Property-Based Tests:**

```python
from hypothesis import given, strategies as st, assume

@given(
    position_value=st.decimals(min_value=Decimal("1"), max_value=Decimal("1000000")),
    annual_rate=st.decimals(min_value=Decimal("0"), max_value=Decimal("1"))
)
def test_costs_always_reduce_profitability(position_value, annual_rate):
    """Property: Borrow costs always reduce profitability (never negative costs)."""
    # Borrow costs are always >= 0
    daily_rate = annual_rate / Decimal("365")
    daily_cost = position_value * daily_rate

    # Property: Cost is non-negative
    assert daily_cost >= Decimal("0")

    # Property: Cost reduces cash (profitability)
    # If you start with cash C and pay cost X, ending cash = C - X < C
    initial_cash = Decimal("100000.00")
    final_cash = initial_cash - daily_cost
    assert final_cash <= initial_cash

@given(
    position_value=st.decimals(min_value=Decimal("1"), max_value=Decimal("1000000")),
    annual_rate=st.decimals(min_value=Decimal("0"), max_value=Decimal("1"))
)
def test_daily_rate_bounds(position_value, annual_rate):
    """Property: Daily rate is always between 0 and annual_rate/365."""
    daily_rate = annual_rate / Decimal("365")

    # Property: Daily rate bounds
    assert daily_rate >= Decimal("0")
    assert daily_rate <= annual_rate
    assert daily_rate <= annual_rate / Decimal("365")

@given(
    position_value=st.decimals(min_value=Decimal("1"), max_value=Decimal("1000000")),
    annual_rate=st.decimals(min_value=Decimal("0.001"), max_value=Decimal("1")),
    scale_factor=st.decimals(min_value=Decimal("1"), max_value=Decimal("10"))
)
def test_cost_proportional_to_position_size(position_value, annual_rate, scale_factor):
    """Property: Borrow cost scales linearly with position size."""
    provider = DictBorrowRateProvider({"TEST": annual_rate})
    model = BorrowCostModel(provider)

    # Calculate cost for base position
    cost1, _ = model.calculate_daily_cost(
        "TEST", position_value, pd.Timestamp("2023-01-01")
    )

    # Calculate cost for scaled position
    cost2, _ = model.calculate_daily_cost(
        "TEST", position_value * scale_factor, pd.Timestamp("2023-01-01")
    )

    # Property: Cost scales linearly (cost2 / cost1 ≈ scale_factor)
    ratio = cost2 / cost1 if cost1 > 0 else Decimal("0")
    assert ratio == pytest.approx(float(scale_factor), rel=1e-6)

@given(
    num_days=st.integers(min_value=1, max_value=365),
    annual_rate=st.decimals(min_value=Decimal("0.001"), max_value=Decimal("1"))
)
def test_annual_cost_approximates_rate(num_days, annual_rate):
    """Property: Cost over 365 days approximates annual rate × position value."""
    position_value = Decimal("10000.00")
    provider = DictBorrowRateProvider({"TEST": annual_rate})
    model = BorrowCostModel(provider, days_in_year=365)

    # Calculate daily cost
    daily_cost, _ = model.calculate_daily_cost(
        "TEST", position_value, pd.Timestamp("2023-01-01")
    )

    # Property: Annual cost ≈ annual_rate × position_value
    # (over 365 days)
    annual_cost = daily_cost * Decimal("365")
    expected_annual_cost = position_value * annual_rate

    assert annual_cost == pytest.approx(float(expected_annual_cost), rel=1e-6)
```

**Integration Tests:**

```python
def test_short_strategy_with_borrow_costs_30_days():
    """Integration test: Short strategy with borrow costs over 30+ days."""
    # Setup: Short GME during meme stock squeeze
    rates = {"GME": Decimal("0.25")}  # 25% annual during squeeze
    provider = DictBorrowRateProvider(rates)
    model = BorrowCostModel(provider)

    # Initialize ledger
    ledger = DecimalLedger(initial_cash=Decimal("100000.00"))

    # Day 0: Enter short position (100 shares at $300)
    gme_asset = Asset(symbol="GME")
    ledger.add_position(
        asset=gme_asset,
        amount=Decimal("-100"),  # Short
        price=Decimal("300.00")
    )

    # Track metrics
    daily_costs = []
    cash_balances = []

    # Simulate 30 days
    start_date = pd.Timestamp("2021-01-15")

    for day in range(30):
        current_time = start_date + pd.Timedelta(days=day)

        # Update position market value (price fluctuates)
        # Simplified: assume price constant at $300
        position = ledger.positions[gme_asset]
        position.market_value = Decimal("-100") * Decimal("300.00")

        # Accrue borrow costs
        result = model.accrue_costs(ledger, current_time)

        # Record metrics
        daily_costs.append(result.total_cost)
        cash_balances.append(ledger.cash)

    # Verify cost accumulation
    total_cost_accrued = sum(daily_costs)
    position_value = Decimal("30000.00")  # 100 shares × $300
    expected_30day_cost = position_value * (Decimal("0.25") / Decimal("365")) * Decimal("30")

    assert total_cost_accrued == pytest.approx(float(expected_30day_cost), rel=1e-6)

    # Verify cash was debited
    cash_debited = Decimal("100000.00") - ledger.cash
    assert cash_debited == pytest.approx(float(expected_30day_cost), rel=1e-6)

    # Verify accumulated cost in position
    assert position.accumulated_borrow_cost == pytest.approx(float(expected_30day_cost), rel=1e-6)

    # Expected total cost: ~$616.44 over 30 days
    # This significantly impacts profitability of short strategy
    assert total_cost_accrued > Decimal("600.00")

def test_mixed_positions_long_and_short():
    """Integration test: Ledger with both long and short positions."""
    rates = {
        "AAPL": Decimal("0.003"),  # Long position (no borrow cost)
        "GME": Decimal("0.25")     # Short position (borrow cost)
    }
    provider = DictBorrowRateProvider(rates)
    model = BorrowCostModel(provider)

    ledger = DecimalLedger(initial_cash=Decimal("100000.00"))

    # Add long position (AAPL)
    aapl_asset = Asset(symbol="AAPL")
    ledger.add_position(
        asset=aapl_asset,
        amount=Decimal("100"),  # Long (positive)
        price=Decimal("150.00")
    )

    # Add short position (GME)
    gme_asset = Asset(symbol="GME")
    ledger.add_position(
        asset=gme_asset,
        amount=Decimal("-50"),  # Short (negative)
        price=Decimal("200.00")
    )

    # Accrue costs
    current_time = pd.Timestamp("2021-01-15")
    result = model.accrue_costs(ledger, current_time)

    # Only short position should accrue costs
    assert result.positions_processed == 1
    assert "GME" in result.position_costs
    assert "AAPL" not in result.position_costs

    # Verify cost magnitude
    gme_position_value = Decimal("50") * Decimal("200.00")  # $10,000
    expected_daily_cost = gme_position_value * (Decimal("0.25") / Decimal("365"))

    assert result.position_costs["GME"] == pytest.approx(float(expected_daily_cost), rel=1e-6)
```

**Zero-Mock Enforcement:** [Source: architecture/coding-standards.md#zero-mock-enforcement-mandatory]
- Use real BorrowCostModel instances in all tests
- No hardcoded cost values or mock implementations
- Tests must exercise actual Decimal calculations
- Mock only external dependencies (assets, ledger structure), not cost logic

**Coverage Target:** [Source: architecture/testing-strategy.md#test-coverage-targets]
- Overall: ≥90%
- Borrow cost module: ≥90%

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-01 | 1.0 | Initial story creation | SM (Bob) |
| 2025-10-01 | 1.1 | Enhanced with comprehensive implementation details, CSV/dict rate providers, property-based testing, and integration examples per PO validation | PO (Sarah) |

## Dev Agent Record

### Agent Model Used

_To be populated by Dev Agent_

### Debug Log References

_To be populated by Dev Agent_

### Completion Notes List

_To be populated by Dev Agent_

### File List

_To be populated by Dev Agent_

## QA Results

_To be populated by QA Agent_
