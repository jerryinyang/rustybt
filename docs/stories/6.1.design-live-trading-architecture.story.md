# Story 6.1: Design Live Trading Engine Architecture

## Status
Draft

## Story
**As a** developer,
**I want** architectural design for event-driven live trading engine,
**so that** implementation follows production-ready patterns with clear concurrency and error handling strategies.

## Acceptance Criteria
1. Architecture diagram showing EventLoop, OrderManager, DataFeed, BrokerAdapter, StateManager, Scheduler
2. Async/await design specified (asyncio for I/O-bound operations, threading for CPU-bound)
3. Event types defined (MarketData, OrderFill, OrderReject, ScheduledTrigger, SystemError)
4. State persistence design (what to save: strategy state, positions, orders, cash)
5. Crash recovery design (restore from last checkpoint, reconcile with broker)
6. Threading/concurrency model documented (avoid race conditions, use thread-safe queues)
7. Error handling strategy defined (retry logic, circuit breakers, graceful degradation)
8. Monitoring and alerting hooks designed (emit events for external monitoring)
9. Architecture documentation saved to docs/architecture/live-trading.md
10. Design reviewed for production readiness before implementation

## Tasks / Subtasks
- [ ] Research existing live trading architectures (AC: 1, 2, 3, 6, 7)
  - [ ] Review asyncio event loop patterns for financial systems
  - [ ] Research broker adapter design patterns from industry (IBKR, Alpaca, QuantConnect)
  - [ ] Study state management approaches for trading engines (checkpointing, journaling)
  - [ ] Review concurrency patterns for async Python (asyncio.Queue, asyncio.Lock, task groups)
- [ ] Design core component architecture (AC: 1)
  - [ ] Define LiveTradingEngine class structure with async event loop
  - [ ] Design EventLoop component (prioritized asyncio.Queue for event processing)
  - [ ] Design OrderManager component (track order lifecycle: pending â†’ filled/rejected/canceled)
  - [ ] Design DataFeed component (real-time market data coordination)
  - [ ] Design BrokerAdapter abstract interface (submit_order, cancel_order, get_positions, get_open_orders, get_account_info, subscribe_market_data, get_next_event)
  - [ ] Design StateManager component (checkpoint strategy state, positions, orders to disk)
  - [ ] Design Scheduler component (APScheduler integration for market triggers and custom schedules)
  - [ ] Create architecture diagram showing component relationships and data flow
- [ ] Define event system architecture (AC: 3)
  - [ ] Define MarketData event structure (asset, timestamp, price, volume)
  - [ ] Define OrderFill event structure (order_id, fill_price, fill_amount, commission, timestamp)
  - [ ] Define OrderReject event structure (order_id, reason, timestamp)
  - [ ] Define ScheduledTrigger event structure (trigger_type, scheduled_time, actual_time)
  - [ ] Define SystemError event structure (error_type, message, severity, timestamp)
  - [ ] Design event priority system (SystemError > OrderFill > OrderReject > ScheduledTrigger > MarketData)
  - [ ] Design event queue mechanism using asyncio.PriorityQueue
- [ ] Design async/await concurrency model (AC: 2, 6)
  - [ ] Document asyncio usage for I/O-bound operations (broker API calls, data fetching)
  - [ ] Document threading usage for CPU-bound operations if needed (indicator calculations with ThreadPoolExecutor)
  - [ ] Design thread-safe queue for event passing between async and sync contexts
  - [ ] Document asyncio.Lock usage for protecting shared state (portfolio, positions)
  - [ ] Design task group pattern for managing concurrent broker operations
  - [ ] Document race condition prevention strategies (locks, queues, immutable events)
- [ ] Design state persistence architecture (AC: 4, 5)
  - [ ] Define state checkpoint structure (strategy_state, positions, pending_orders, cash_balance, timestamp)
  - [ ] Design checkpoint frequency strategy (every 1 minute, on shutdown, on significant portfolio changes)
  - [ ] Design storage format (JSON for human readability vs pickle for efficiency)
  - [ ] Design atomic write strategy (write to temp file, then rename for atomicity)
  - [ ] Design state restoration procedure (load checkpoint, validate timestamp, reconcile with broker)
  - [ ] Design stale state detection (warn if checkpoint >1 hour old)
  - [ ] Design position reconciliation logic (compare local vs broker positions, resolve discrepancies)
  - [ ] Document crash recovery workflow with sequence diagrams
- [ ] Design error handling and retry strategy (AC: 7)
  - [ ] Define retry logic with exponential backoff (1s, 2s, 4s, 8s, 16s max)
  - [ ] Design circuit breaker pattern (trip after N consecutive failures, auto-reset after cooldown)
  - [ ] Design graceful degradation strategy (fallback to paper trading mode on broker failure)
  - [ ] Define transient vs permanent error classification
  - [ ] Design error propagation strategy (log, alert, retry, or fail)
  - [ ] Document timeout strategies for broker operations (order submission: 30s, position fetch: 10s)
- [ ] Design monitoring and alerting architecture (AC: 8)
  - [ ] Define monitoring event hooks (on_order_submitted, on_order_filled, on_error, on_state_checkpoint)
  - [ ] Design metric emission points (latency, throughput, error rates, position reconciliation mismatches)
  - [ ] Design alerting triggers (circuit breaker trip, repeated order rejections, position reconciliation failure)
  - [ ] Document integration points for external monitoring (Prometheus, Grafana, custom webhooks)
  - [ ] Design health check endpoint for monitoring systems
- [ ] Document architecture in live-trading.md (AC: 9)
  - [ ] Write architecture overview section
  - [ ] Document component responsibilities and interfaces
  - [ ] Add architecture diagrams (component diagram, sequence diagrams for key workflows)
  - [ ] Document event flow with examples
  - [ ] Document concurrency model and thread safety guarantees
  - [ ] Document state persistence and crash recovery procedures
  - [ ] Document error handling strategies with decision trees
  - [ ] Document monitoring and alerting integration points
  - [ ] Add configuration examples for different deployment scenarios
- [ ] Conduct architecture review (AC: 10)
  - [ ] Review for production readiness (error handling, monitoring, recovery)
  - [ ] Review for scalability (can handle 1000+ events/second)
  - [ ] Review for correctness (no race conditions, atomic operations, data consistency)
  - [ ] Review for maintainability (clear interfaces, extensible design)
  - [ ] Document review findings and incorporate feedback
  - [ ] Update architecture document with review outcomes

## Dev Notes

### Previous Story Insights
This is the first story in Epic 6, building on the foundation established in Epics 1-5:
- Epic 1: Decimal precision finance layer (DecimalLedger, DecimalPosition)
- Epic 2: Polars/Parquet data layer (PolarsDataPortal, data adapters)
- Epic 3: Advanced backtesting features (multi-strategy, partial fills, advanced orders)
- Epic 4: Comprehensive testing and documentation
- Epic 5: Strategy optimization framework

Epic 6 adds live trading capabilities on top of this proven backtesting foundation.

### Architecture Context

**Tech Stack Requirements:**
[Source: architecture/tech-stack.md#new-technology-additions-rustybt-enhancements]
- **Async Framework:** asyncio (stdlib) for I/O-bound broker API calls and live data feeds
- **Scheduling:** APScheduler 3.x+ for market open/close triggers and custom intervals
- **WebSocket:** websockets 14.x+ for real-time data streaming
- **Validation:** pydantic 2.x+ for event data validation and config management
- **Decimal:** Python Decimal (stdlib) for all financial calculations
- **DataFrames:** Polars 1.x for data operations
- **Broker Libraries:** ccxt 4.x+, ib_async 1.x+, binance-connector 3.x+, pybit 5.x+, hyperliquid-python-sdk

**Component Architecture Patterns:**
[Source: architecture/component-architecture.md#live-trading-components]
- LiveTradingEngine: Main orchestrator with async event loop, broker integration, state management
- BrokerAdapter: Abstract base class with async interface (connect, submit_order, cancel_order, get_positions, get_account_info, subscribe_market_data, get_next_event)
- Adapter Implementations: CCXTAdapter, IBAdapter, BinanceAdapter, BybitAdapter, HyperliquidAdapter, PaperBroker
- PositionReconciler: Compare local state vs broker positions, handle discrepancies
- StateManager: Checkpoint strategy state, positions, orders to disk for crash recovery
- TradingScheduler: Market triggers using APScheduler (market_open, market_close, custom intervals)

**External API Integration Patterns:**
[Source: architecture/external-api-integration.md]
- Broker APIs use async/await for all operations
- Error handling with retry logic and exponential backoff
- Rate limiting per broker specifications
- Authentication via credentials dict (api_key, api_secret, etc.)
- Connection timeout: 30s, reconnection with exponential backoff
- Order status polling for confirmation

**Coding Standards:**
[Source: architecture/coding-standards.md#asyncawait]
- Use async/await for all broker API calls and I/O operations
- Event loop: asyncio (standard library)
- Structured logging with structlog (log levels: DEBUG, INFO, WARNING, ERROR)
- Type hints required with mypy --strict compliance
- Error handling with specific exception classes (BrokerError, OrderRejectedError)
- No mock implementations allowed (Zero-Mock Enforcement)

**Error Handling Patterns:**
[Source: architecture/coding-standards.md#error-handling]
- Custom exception hierarchy: RustyBTError > BrokerError > OrderRejectedError
- Always log exceptions with context using structlog
- Retry logic required for transient errors
- No silent exception swallowing (no empty except blocks)

**Concurrency Guardrails:**
[Source: architecture/coding-standards.md#mutation-safety]
- Immutable data structures preferred (dataclasses with frozen=True)
- Explicit Optional types for nullable values
- No mutation of input arguments in functions
- Thread-safe queues for event passing

### File Locations
[Source: architecture/source-tree.md#rustybt-directory-structure]
- Architecture documentation: `docs/architecture/live-trading.md` **(NEW FILE - will be created in this story, AC 9)**
- Live trading engine: `rustybt/live/engine.py`
- Broker adapters: `rustybt/live/brokers/` (base.py, ccxt_adapter.py, ib_adapter.py, etc.)
- State manager: `rustybt/live/state_manager.py`
- Position reconciler: `rustybt/live/reconciler.py`
- Scheduler: `rustybt/live/scheduler.py`
- Streaming components: `rustybt/live/streaming/` (base.py, binance_stream.py)

### Project Structure Notes
This story creates architectural documentation only (no code implementation). The architecture will guide implementation in subsequent stories (6.2-6.11). The live trading engine is a new component with no Zipline equivalent, so we're designing from first principles while following RustyBT patterns.

### Testing
[Source: architecture/testing-strategy.md]

**Test Location:**
- No tests required for this story (architecture documentation only)
- Subsequent implementation stories (6.2+) will require:
  - Unit tests: â‰¥90% coverage in `tests/live/`
  - Integration tests: Live trading workflows in `tests/integration/live/`
  - Property-based tests: Event processing invariants using Hypothesis

**Testing Standards for Future Implementation:**
- Mock broker APIs using pytest-mock or responses
- Use paper trading accounts for broker integration tests
- Validate event processing order and priority
- Test crash recovery scenarios (save â†’ crash â†’ restore)
- Test position reconciliation with simulated discrepancies
- Performance test: engine handles 1000+ events/second with <10ms latency

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-02 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
Not yet implemented

### Debug Log References
Not yet implemented

### Completion Notes List
Not yet implemented

### File List
Not yet implemented

## QA Results
Not yet implemented
