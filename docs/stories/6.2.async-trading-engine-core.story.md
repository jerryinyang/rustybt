# Story 6.2: Implement Event-Driven Async Trading Engine Core

## Status
Draft

## Story
**As a** developer,
**I want** async event loop with order management and data feed coordination,
**so that** live trading can handle real-time market data and order execution concurrently.

## Acceptance Criteria
1. TradingEngine class with async event loop (asyncio-based)
2. Event queue implemented (prioritized queue for different event types)
3. Event dispatcher routes events to appropriate handlers (market data → strategy, order fills → portfolio)
4. OrderManager tracks active orders (submitted, pending, filled, canceled)
5. DataFeed integration (subscribe to market data, dispatch to strategy on updates)
6. Strategy execution triggers (on_data, on_order_fill, on_scheduled_event)
7. Graceful shutdown handling (cleanup resources, persist state before exit)
8. Tests validate event loop processes events in correct order
9. Performance tested: engine handles 1000+ events/second with <10ms latency
10. Example demonstrates simple live strategy responding to market data events

## Tasks / Subtasks
- [ ] Implement TradingEngine core with async event loop (AC: 1, 7)
  - [ ] Create LiveTradingEngine class in rustybt/live/engine.py
  - [ ] Implement async __init__ with broker_adapter, data_portal, scheduler parameters
  - [ ] Implement async run() method with main event loop using asyncio
  - [ ] Implement graceful_shutdown() method with cleanup and state persistence hooks
  - [ ] Add signal handlers for SIGINT/SIGTERM to trigger graceful shutdown
  - [ ] Implement engine lifecycle: initialize → run → shutdown
- [ ] Implement priority event queue system (AC: 2)
  - [ ] Create Event base class with priority, timestamp, event_type fields (pydantic model)
  - [ ] Create MarketDataEvent(Event) for price updates
  - [ ] Create OrderFillEvent(Event) for order fills
  - [ ] Create OrderRejectEvent(Event) for order rejections
  - [ ] Create ScheduledTriggerEvent(Event) for scheduled callbacks
  - [ ] Create SystemErrorEvent(Event) for error conditions
  - [ ] Implement asyncio.PriorityQueue with priority ordering (SystemError=1, OrderFill=2, OrderReject=3, ScheduledTrigger=4, MarketData=5)
  - [ ] Implement event enqueue/dequeue methods with proper typing
- [ ] Implement event dispatcher and routing (AC: 3)
  - [ ] Create EventDispatcher class with async dispatch() method
  - [ ] Implement handler registration (register_handler(event_type, handler_func))
  - [ ] Route MarketDataEvent to strategy.on_data() handler
  - [ ] Route OrderFillEvent to portfolio update and strategy.on_order_fill() handler
  - [ ] Route OrderRejectEvent to strategy.on_order_reject() handler
  - [ ] Route ScheduledTriggerEvent to strategy scheduled callback
  - [ ] Route SystemErrorEvent to error handler with logging and alerting
  - [ ] Add async error handling for handler exceptions (log and continue processing)
- [ ] Implement OrderManager for order lifecycle tracking (AC: 4)
  - [ ] Create OrderManager class in rustybt/live/order_manager.py
  - [ ] Create Order dataclass with id, asset, amount, order_type, status, broker_order_id fields
  - [ ] Implement submit_order() method that creates Order and submits to broker
  - [ ] Implement track order states: SUBMITTED → PENDING → FILLED/CANCELED/REJECTED
  - [ ] Implement get_order(order_id) and get_active_orders() methods
  - [ ] Implement order status update from broker events
  - [ ] Add thread-safe access using asyncio.Lock for order state modifications
- [ ] Implement DataFeed integration (AC: 5)
  - [ ] Create DataFeed class in rustybt/live/data_feed.py
  - [ ] Implement async subscribe(assets: List[Asset]) method
  - [ ] Implement async get_next_market_data() that fetches from broker adapter
  - [ ] Convert broker market data to MarketDataEvent and enqueue
  - [ ] Handle subscription management (add/remove assets dynamically)
  - [ ] Implement connection monitoring and auto-reconnect on disconnect
- [ ] Implement strategy execution triggers (AC: 6)
  - [ ] Create StrategyExecutor class wrapping TradingAlgorithm
  - [ ] Implement async on_data(market_data_event) trigger
  - [ ] Implement async on_order_fill(order_fill_event) trigger
  - [ ] Implement async on_scheduled_event(scheduled_trigger_event) trigger
  - [ ] Pass data portal and context to strategy callbacks
  - [ ] Handle strategy exceptions without crashing engine (log and continue)
- [ ] Implement unit tests for event processing (AC: 8)
  - [ ] Test event queue priority ordering (SystemError processed before MarketData)
  - [ ] Test event dispatcher routes events to correct handlers
  - [ ] Test OrderManager state transitions (SUBMITTED → FILLED)
  - [ ] Test DataFeed subscription and market data event generation
  - [ ] Test graceful shutdown cleans up resources
  - [ ] Test concurrent event processing with multiple event types
- [ ] Implement performance tests (AC: 9)
  - [ ] Benchmark event processing throughput (target: 1000+ events/second)
  - [ ] Measure event processing latency (target: <10ms per event)
  - [ ] Test with simulated high-frequency market data (100 updates/second)
  - [ ] Verify no memory leaks during extended operation (1 hour test)
  - [ ] Profile and optimize bottlenecks if performance targets not met
- [ ] Create live strategy example (AC: 10)
  - [ ] Create examples/live_trading_simple.py
  - [ ] Implement SimpleMovingAverageCrossStrategy responding to market data
  - [ ] Configure with PaperBroker for testing without real capital
  - [ ] Demonstrate subscribing to market data and receiving updates
  - [ ] Demonstrate order submission and fill handling
  - [ ] Add logging to show event flow and strategy execution
  - [ ] Document example with clear setup instructions

## Dev Notes

### Previous Story Insights
[From Story 6.1: Design Live Trading Engine Architecture]
- Architecture defines LiveTradingEngine as main orchestrator with async event loop
- Event priority system: SystemError > OrderFill > OrderReject > ScheduledTrigger > MarketData
- BrokerAdapter provides async interface for order submission and market data subscription
- StateManager and PositionReconciler will be implemented in subsequent stories
- Zero-Mock Enforcement: All components must have real implementations, no mocks

### Architecture Context

**Live Trading Engine Design:**
[Source: docs/architecture/live-trading.md (created in Story 6.1)]
**Note:** If Story 6.1 architecture doc isn't completed, reference Epic 6 PRD docs/prd/epic-6-live-trading-engine-broker-integrations.md as fallback
- Main event loop uses asyncio for async I/O operations
- Priority queue ensures critical events (errors, fills) processed before market data
- Event dispatcher pattern for routing events to handlers
- Graceful shutdown with state persistence and resource cleanup
- Thread-safe order state management using asyncio.Lock

**Component Architecture:**
[Source: architecture/component-architecture.md#live-trading-components]
- LiveTradingEngine: Orchestrates event loop, broker integration, strategy execution
- OrderManager: Track order lifecycle (submitted, pending, filled, canceled)
- DataFeed: Subscribe to market data, convert to events, dispatch to strategy
- StrategyExecutor: Wrap TradingAlgorithm, provide async triggers (on_data, on_order_fill)

**BrokerAdapter Interface Extension (Story 6.4):** The get_open_orders() method will be added to BrokerAdapter in Story 6.4 for order reconciliation. Initial implementation uses core methods only.

**Event System Design:**
[From Story 6.1 Architecture]
- Event base class with priority, timestamp, event_type
- Pydantic models for type safety and validation
- Priority values: SystemError=1, OrderFill=2, OrderReject=3, ScheduledTrigger=4, MarketData=5
- asyncio.PriorityQueue for event ordering

**Tech Stack:**
[Source: architecture/tech-stack.md#new-technology-additions]
- asyncio (stdlib) for async event loop and I/O operations
- pydantic 2.x+ for event data validation
- Python Decimal for all financial values
- structlog for structured logging
- asyncio.Lock for thread-safe state access

**Coding Standards:**
[Source: architecture/coding-standards.md]
- Type hints required: mypy --strict compliance
- Async/await for all I/O operations
- Immutable dataclasses (frozen=True) for events and orders
- Structured logging with context (structlog)
- Error handling with specific exceptions (EngineError, OrderError)
- No empty except blocks or silent error swallowing

**Zero-Mock Enforcement:**
[Source: architecture/coding-standards.md#zero-mock-enforcement]
- No hardcoded return values in production code
- All event handlers must perform real processing
- Tests use real event queue and dispatcher, not mocks
- PaperBroker for testing (real implementation, simulated execution)

### File Locations
[Source: architecture/source-tree.md#rustybt-directory-structure]
- Main engine: `rustybt/live/engine.py` (LiveTradingEngine class)
- Order manager: `rustybt/live/order_manager.py` (OrderManager class)
- Data feed: `rustybt/live/data_feed.py` (DataFeed class)
- Events: `rustybt/live/events.py` (Event classes with pydantic)
- Strategy executor: `rustybt/live/strategy_executor.py` (StrategyExecutor class)
- Tests: `tests/live/test_engine.py`, `tests/live/test_order_manager.py`, `tests/live/test_data_feed.py`
- Performance tests: `tests/live/test_performance.py`
- Example: `examples/live_trading_simple.py`

### Integration Points
- BrokerAdapter: Use abstract interface from rustybt/live/brokers/base.py (implemented in Story 6.7+)
- TradingAlgorithm: Extend zipline algorithm with live trading hooks
- DataPortal: Use PolarsDataPortal for historical data access
- StateManager: Will integrate in Story 6.3 for state persistence

### Testing
[Source: architecture/testing-strategy.md]

**Test Location:**
- Unit tests in `tests/live/test_engine.py`, `tests/live/test_order_manager.py`, `tests/live/test_data_feed.py`
- Performance tests in `tests/live/test_performance.py`
- Integration tests in `tests/integration/live/test_engine_integration.py`

**Testing Standards:**
- Unit tests: ≥90% coverage
- Use mock BrokerAdapter for initial tests (basic mock implementation), will be enhanced with PaperBroker from Story 6.7 for comprehensive validation
- Property-based tests with Hypothesis for event ordering invariants
- Performance benchmarks: pytest-benchmark for throughput and latency
- Mock only external broker APIs, not internal components

**Key Test Scenarios:**
- Event queue processes events in priority order
- OrderManager correctly tracks order state transitions
- DataFeed handles subscription and market data conversion
- Graceful shutdown persists state and cleans up resources
- Concurrent event processing maintains consistency
- Performance: 1000+ events/second with <10ms latency

**Test Fixtures:**
- Mock market data events with known timestamps
- Sample orders with different states (pending, filled, rejected)
- PaperBroker configured for testing
- Sample strategy for event triggering

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-02 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
Not yet implemented

### Debug Log References
Not yet implemented

### Completion Notes List
Not yet implemented

### File List
Not yet implemented

## QA Results
Not yet implemented
