# Story 6.3: Implement State Management with Save/Restore

## Status
Draft

## Story
**As a** quantitative trader,
**I want** automatic state persistence and restore on restart,
**so that** my live trading strategies survive crashes and restarts without losing positions.

## Acceptance Criteria
1. StateManager saves strategy state, positions, open orders, cash balance to disk (JSON or pickle)
2. State saved periodically (e.g., every 1 minute) and on shutdown
3. State restored on engine startup (load last checkpoint)
4. State includes timestamps to detect stale state (warn if state >1 hour old)
5. Position reconciliation with broker after restore (compare local state vs. broker positions)
6. Discrepancy handling (if local != broker, log warning and optionally sync to broker state)
7. Atomic state writes (use temporary file + rename to prevent corruption)
8. Tests validate save → crash → restore scenario
9. Integration test simulates crash and validates correct state restoration
10. Documentation explains state management and reconciliation process

## Tasks / Subtasks
- [ ] Design state checkpoint data structure (AC: 1, 4)
  - [ ] Define StateCheckpoint pydantic model with strategy_state, positions, pending_orders, cash_balance, timestamp fields
  - [ ] Define PositionSnapshot for position serialization (asset, amount, cost_basis, last_price)
  - [ ] Define OrderSnapshot for pending order serialization (order_id, asset, amount, order_type, broker_order_id, status)
  - [ ] Choose serialization format: JSON for human readability and debugging
  - [ ] Add validation for required fields and data types
- [ ] Implement StateManager core (AC: 1, 2, 3, 7)
  - [ ] Create StateManager class in rustybt/live/state_manager.py
  - [ ] Implement save_checkpoint(strategy_name, state) method with atomic writes
  - [ ] Use temp file pattern: write to .tmp, then os.rename() for atomicity
  - [ ] Implement load_checkpoint(strategy_name) → StateCheckpoint method
  - [ ] Handle missing checkpoint file gracefully (return None, log info)
  - [ ] Store checkpoints in configurable directory (default: ~/.rustybt/state/)
  - [ ] Add checkpoint filename pattern: {strategy_name}_checkpoint.json
- [ ] Implement periodic state saving (AC: 2)
  - [ ] Integrate with LiveTradingEngine event loop
  - [ ] Add APScheduler job for periodic checkpoint (default: every 1 minute)
  - [ ] Implement on_shutdown hook to save final checkpoint
  - [ ] Capture current strategy state from TradingAlgorithm
  - [ ] Capture current positions from DecimalLedger
  - [ ] Capture pending orders from OrderManager
  - [ ] Capture cash balance from portfolio
  - [ ] Add timestamp to checkpoint for staleness detection
- [ ] Implement state restoration (AC: 3, 4)
  - [ ] Implement restore_state() in LiveTradingEngine
  - [ ] Load checkpoint using StateManager.load_checkpoint()
  - [ ] Check timestamp staleness (warn if >1 hour old, configurable threshold)
  - [ ] Restore strategy state to TradingAlgorithm
  - [ ] Restore positions to DecimalLedger
  - [ ] Restore pending orders to OrderManager
  - [ ] Restore cash balance to portfolio
  - [ ] Log restoration summary with timestamp and key metrics
- [ ] Implement position reconciliation after restore (AC: 5, 6)
  - [ ] Fetch broker positions after state restoration
  - [ ] Compare local positions vs broker positions (asset, amount)
  - [ ] Detect discrepancies (missing positions, quantity mismatches)
  - [ ] Log warnings for any discrepancies found
  - [ ] Implement reconciliation strategies (configurable):
    - [ ] WARN_ONLY: Log discrepancies, continue with local state
    - [ ] SYNC_TO_BROKER: Update local state to match broker
    - [ ] HALT_AND_ALERT: Stop engine, require manual intervention
  - [ ] Apply selected reconciliation strategy
  - [ ] Generate reconciliation report with details
- [ ] Implement atomic write guarantees (AC: 7)
  - [ ] Write checkpoint to temporary file {filename}.tmp
  - [ ] Use os.fsync() to ensure data written to disk
  - [ ] Use os.rename() for atomic move (overwrites existing checkpoint)
  - [ ] Handle write errors with proper exception handling
  - [ ] Verify checkpoint integrity after write (optional: checksum validation)
  - [ ] Clean up temp files on errors
- [ ] Implement unit tests for state management (AC: 8)
  - [ ] Test StateCheckpoint serialization/deserialization
  - [ ] Test save_checkpoint creates valid JSON file
  - [ ] Test load_checkpoint reads and validates checkpoint
  - [ ] Test atomic write (write → rename) prevents corruption
  - [ ] Test staleness detection warns for old checkpoints
  - [ ] Test missing checkpoint handling (returns None gracefully)
  - [ ] Test reconciliation strategies (WARN_ONLY, SYNC_TO_BROKER, HALT_AND_ALERT)
- [ ] Implement crash recovery integration test (AC: 9)
  - [ ] Create test that runs engine, saves checkpoint, then stops
  - [ ] Simulate crash (abrupt termination without shutdown)
  - [ ] Restart engine and verify state restored from checkpoint
  - [ ] Verify positions match pre-crash state
  - [ ] Verify pending orders restored correctly
  - [ ] Verify cash balance restored correctly
  - [ ] Test with position reconciliation (simulated broker discrepancy)
- [ ] Create documentation for state management (AC: 10)
  - [ ] Document StateCheckpoint structure in docs/architecture/live-trading.md
  - [ ] Explain periodic checkpoint strategy (frequency, triggers)
  - [ ] Explain state restoration process with sequence diagram
  - [ ] Explain reconciliation strategies and when to use each
  - [ ] Provide configuration examples for different scenarios
  - [ ] Document checkpoint file location and cleanup policies
  - [ ] Add troubleshooting guide for state restoration issues

## Dev Notes

### Previous Story Insights
[From Story 6.1: Design Live Trading Engine Architecture]
- State persistence design: save strategy_state, positions, orders, cash with timestamps
- Atomic write strategy: temp file + rename for corruption prevention
- Stale state detection: warn if checkpoint >1 hour old
- Reconciliation strategies: WARN_ONLY, SYNC_TO_BROKER, HALT_AND_ALERT

[From Story 6.2: Implement Event-Driven Async Trading Engine Core]
- LiveTradingEngine has graceful_shutdown() hook for final checkpoint
- OrderManager tracks pending orders that need to be persisted
- Event loop integration point for periodic scheduled tasks

### Architecture Context

**State Management Design:**
[Source: docs/architecture/live-trading.md (from Story 6.1)]
- Checkpoint structure: strategy_state, positions, pending_orders, cash_balance, timestamp
- Checkpoint frequency: every 1 minute, on shutdown, on significant portfolio changes
- Storage format: JSON for human readability (pickle optional for efficiency)
- Atomic writes: temp file + rename to prevent corruption
- Restoration: load checkpoint, validate timestamp, reconcile with broker

**Component Integration:**
[Source: architecture/component-architecture.md#live-trading-components]
- StateManager: Checkpoint strategy state, positions, orders to disk
- LiveTradingEngine: Calls StateManager for periodic saves and restoration
- PositionReconciler: Reconcile local state vs broker positions (implemented in Story 6.4)
- DecimalLedger: Source of position and cash balance data
- OrderManager: Source of pending orders data

**Data Models:**
[Source: architecture/data-models-and-schema-changes.md#new-database-tables]
- strategy_state table schema: strategy_name, state_blob, timestamp, version
- live_positions table: Used by PositionReconciler for broker comparison
- order_audit_log table: Tracks order history for reconciliation
**Note:** Database tables (strategy_state, live_positions, order_audit_log) are for audit/reconciliation history. Primary checkpoint storage uses JSON files for fast save/restore.

**Tech Stack:**
[Source: architecture/tech-stack.md]
- Pydantic 2.x+ for StateCheckpoint model validation
- Python JSON (stdlib) for serialization
- APScheduler 3.x+ for periodic checkpoint scheduling
- Python Decimal for all financial values
- asyncio for async checkpoint operations

**Coding Standards:**
[Source: architecture/coding-standards.md]
- Pydantic models for data validation (StateCheckpoint, PositionSnapshot, OrderSnapshot)
- Structured logging for checkpoint operations (save, load, reconcile)
- Type hints: mypy --strict compliance
- Error handling: specific exceptions (StateError, CheckpointCorrupted, ReconciliationError)
- Atomic file operations to prevent data corruption

### File Locations
[Source: architecture/source-tree.md]
- StateManager: `rustybt/live/state_manager.py`
- Checkpoint models: `rustybt/live/models.py` (StateCheckpoint, PositionSnapshot, OrderSnapshot)
- State storage: `~/.rustybt/state/` (configurable via environment variable)
- Tests: `tests/live/test_state_manager.py`
- Integration test: `tests/integration/live/test_crash_recovery.py`
- Documentation: `docs/architecture/live-trading.md` (update with state management section)

### Integration Points
- LiveTradingEngine: Register periodic checkpoint job, call save on shutdown
- OrderManager: Provide pending orders for checkpoint
- DecimalLedger: Provide positions and cash balance for checkpoint
- BrokerAdapter: Fetch broker positions for reconciliation
- PositionReconciler: Compare local vs broker positions (Story 6.4)

**Reconciliation Scope in This Story:** Story 6.3 implements basic reconciliation called during state restoration. Story 6.4 implements comprehensive ongoing reconciliation with full discrepancy handling and reconciliation strategies.

### Checkpoint File Format Example

**Checkpoint File Format (Illustrative):** Actual implementation will use Pydantic models defined in tasks. This JSON structure shows the expected data:

```json
{
  "strategy_name": "mean_reversion_v1",
  "timestamp": "2025-10-02T14:30:00.123456Z",
  "strategy_state": {
    "custom_data": {"last_signal": "buy", "signal_strength": 0.75}
  },
  "positions": [
    {"asset": "AAPL", "sid": 1, "amount": "100", "cost_basis": "150.25", "last_price": "155.50"},
    {"asset": "MSFT", "sid": 2, "amount": "50", "cost_basis": "320.00", "last_price": "325.75"}
  ],
  "pending_orders": [
    {"order_id": "order-123", "asset": "GOOGL", "sid": 3, "amount": "10", "order_type": "limit", "limit_price": "2800.00", "broker_order_id": "broker-456", "status": "pending"}
  ],
  "cash_balance": "25000.00"
}
```

### Testing
[Source: architecture/testing-strategy.md]

**Test Location:**
- Unit tests: `tests/live/test_state_manager.py`
- Integration tests: `tests/integration/live/test_crash_recovery.py`

**Testing Standards:**
- Unit tests: ≥90% coverage
- Test atomic write guarantees (write corruption scenarios)
- Test staleness detection with various time deltas
- Test reconciliation strategies with simulated discrepancies
- Property-based tests with Hypothesis for serialization round-trips

**Key Test Scenarios:**
- Save checkpoint creates valid JSON with all required fields
- Load checkpoint deserializes and validates data correctly
- Atomic write prevents corruption (test interrupted writes)
- Staleness warning for old checkpoints (>1 hour)
- Missing checkpoint handled gracefully (new strategy start)
- Crash recovery: save → crash → restore → verify state
- Position reconciliation detects and handles discrepancies
- Concurrent checkpoint operations are thread-safe

**Test Fixtures:**
- Sample StateCheckpoint with known data
- Mock DecimalLedger with test positions
- Mock OrderManager with pending orders
- Mock BrokerAdapter with discrepant positions for reconciliation tests

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-02 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
Not yet implemented

### Debug Log References
Not yet implemented

### Completion Notes List
Not yet implemented

### File List
Not yet implemented

## QA Results
Not yet implemented
