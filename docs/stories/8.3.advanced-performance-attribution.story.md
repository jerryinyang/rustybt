# Story 8.3: Advanced Performance Attribution

## Status
Ready for development

## Story
**As a** quantitative trader,
**I want** performance attribution breaking down returns by source,
**so that** I can understand what drove strategy performance (skill vs. luck, factor exposures).

## Acceptance Criteria
1. Attribution analysis decomposes returns into components (alpha, beta, factor exposures)
2. Factor exposure analysis (momentum, value, volatility, size, etc. if applicable)
3. Timing attribution (skill in entry/exit timing)
4. Selection attribution (skill in asset selection)
5. Interaction attribution (skill in combining timing and selection)
6. Attribution over time (rolling attribution windows)
7. Visualization of attribution components (stacked bar charts, time series)
8. Statistical significance testing (is alpha significant or noise?)
9. Tests validate attribution sums to total returns (accounting identity)
10. Documentation explains attribution methodology and interpretation

## Tasks / Subtasks
- [ ] Create PerformanceAttribution class (AC: 1)
  - [ ] Implement `__init__(backtest_result, benchmark_returns=None)`
  - [ ] Implement `analyze_attribution()` method
  - [ ] Decompose returns into alpha, beta, factor components
- [ ] Implement alpha/beta decomposition (AC: 1, 8)
  - [ ] Calculate portfolio beta vs. benchmark (if provided)
  - [ ] Calculate alpha (excess return beyond beta-adjusted benchmark)
  - [ ] Run statistical significance test (t-test) on alpha
  - [ ] Calculate information ratio (alpha / tracking error)
- [ ] Implement factor exposure analysis (AC: 2)
  - [ ] Support factor models (Fama-French 3-factor, 5-factor, Carhart 4-factor)
  - [ ] Regress portfolio returns against factors
  - [ ] Extract factor loadings (exposures)
  - [ ] Calculate factor-explained returns vs. alpha
- [ ] Implement timing attribution (AC: 3)
  - [ ] Measure timing skill: correct market timing (buying before rallies, selling before declines)
  - [ ] Calculate timing coefficient (correlation of position changes with subsequent returns)
  - [ ] Use Merton-Henriksson market timing test
- [ ] Implement selection attribution (AC: 4)
  - [ ] Measure selection skill: choosing assets that outperform within their sectors/classes
  - [ ] Calculate selection return (asset-level alpha)
  - [ ] Compare actual holdings vs. benchmark weights
- [ ] Implement interaction attribution (AC: 5)
  - [ ] Calculate interaction effect (synergy between timing and selection)
  - [ ] Use Brinson-Fachler attribution model
  - [ ] Decompose total return = allocation + selection + interaction
- [ ] Implement rolling attribution (AC: 6)
  - [ ] Calculate attribution over rolling windows (e.g., 30 days, 90 days)
  - [ ] Track how attribution components change over time
  - [ ] Identify periods of strong/weak performance
- [ ] Implement visualizations (AC: 7)
  - [ ] Create stacked bar chart of attribution components
  - [ ] Create time series chart of rolling alpha
  - [ ] Create factor exposure heatmap
  - [ ] Create attribution waterfall chart (total return → alpha + beta + factors)
- [ ] Validate accounting identity (AC: 9)
  - [ ] Test: Sum of attribution components equals total return
  - [ ] Implement `validate_attribution()` method
  - [ ] Raise error if attribution doesn't reconcile
- [ ] Write tests (AC: 9)
  - [ ] Unit test: Alpha/beta decomposition with synthetic data
  - [ ] Unit test: Factor regression with known factor exposures
  - [ ] Property test: Attribution components sum to total return
  - [ ] Integration test: Full attribution analysis on completed backtest
- [ ] Write documentation (AC: 10)
  - [ ] Document attribution methodology (alpha, beta, factors)
  - [ ] Explain interpretation of attribution results
  - [ ] Provide example: "How to interpret alpha = 2% vs. noise"
  - [ ] Reference academic papers (Brinson-Fachler, Merton-Henriksson)

## Dev Notes

### Relevant Source Tree
[Source: docs/architecture/source-tree.md]
- PerformanceAttribution: `rustybt/analytics/attribution.py` (NEW)
- Helper functions: `rustybt/finance/metrics/core.py` (extend if needed)

### Tech Stack
[Source: docs/architecture/tech-stack.md]
- **Statistics**: **scipy** and **statsmodels** (regression, statistical tests)
- **DataFrames**: **polars** (data manipulation) and **pandas** (for statsmodels compatibility)
- **Visualization**: **matplotlib** and **seaborn** (charts)

### Attribution Methodologies

**1. Brinson-Fachler Attribution Model:**
Decomposes total return into:
- **Allocation Effect**: Return from sector/asset class allocation decisions
- **Selection Effect**: Return from security selection within sectors
- **Interaction Effect**: Synergy between allocation and selection

Formula:
```
Total Return = Allocation + Selection + Interaction

Allocation = Σ (w_p - w_b) * r_b
Selection = Σ w_b * (r_p - r_b)
Interaction = Σ (w_p - w_b) * (r_p - r_b)

where:
  w_p = portfolio weight in sector
  w_b = benchmark weight in sector
  r_p = portfolio return in sector
  r_b = benchmark return in sector
```

**2. Alpha/Beta Decomposition:**
```
Portfolio Return = Alpha + Beta * Benchmark Return + Epsilon

Alpha = Excess return (skill-based)
Beta = Market sensitivity
```

**3. Factor Attribution (Fama-French):**
```
Return = Alpha + β_market * Market + β_size * SMB + β_value * HML + ε

SMB = Small Minus Big (size factor)
HML = High Minus Low (value factor)
```

**4. Timing Attribution (Merton-Henriksson):**
```
Return = Alpha + β_market * Market + γ * max(Market, 0) + ε

γ > 0 indicates market timing skill
```

### Example Code Pattern
```python
from decimal import Decimal
from typing import Optional
import polars as pl
import pandas as pd
from scipy import stats
import statsmodels.api as sm

class PerformanceAttribution:
    """Analyze performance attribution."""

    def __init__(
        self,
        backtest_result,
        benchmark_returns: Optional[pl.Series] = None,
        factor_returns: Optional[pd.DataFrame] = None
    ):
        self.backtest_result = backtest_result
        self.benchmark_returns = benchmark_returns
        self.factor_returns = factor_returns  # Fama-French factors

    def analyze_attribution(self) -> dict:
        """Run full attribution analysis."""
        results = {}

        # Alpha/Beta decomposition
        if self.benchmark_returns is not None:
            results['alpha_beta'] = self._calculate_alpha_beta()

        # Factor attribution
        if self.factor_returns is not None:
            results['factor_attribution'] = self._calculate_factor_attribution()

        # Timing attribution
        results['timing'] = self._calculate_timing_attribution()

        # Validate accounting identity
        self._validate_attribution(results)

        return results

    def _calculate_alpha_beta(self) -> dict:
        """Calculate alpha and beta vs. benchmark."""
        portfolio_returns = self.backtest_result.returns
        benchmark_returns = self.benchmark_returns

        # Convert to pandas for statsmodels
        df = pd.DataFrame({
            'portfolio': portfolio_returns.to_pandas(),
            'benchmark': benchmark_returns.to_pandas()
        }).dropna()

        # Regression: portfolio ~ benchmark
        X = sm.add_constant(df['benchmark'])
        model = sm.OLS(df['portfolio'], X).fit()

        alpha = Decimal(str(model.params['const']))
        beta = Decimal(str(model.params['benchmark']))
        alpha_pvalue = model.pvalues['const']

        # Information ratio
        tracking_error = (df['portfolio'] - beta * df['benchmark']).std()
        information_ratio = float(alpha) / tracking_error if tracking_error > 0 else 0

        return {
            'alpha': alpha,
            'beta': beta,
            'alpha_pvalue': alpha_pvalue,
            'alpha_significant': alpha_pvalue < 0.05,
            'information_ratio': Decimal(str(information_ratio))
        }

    def _calculate_factor_attribution(self) -> dict:
        """Calculate factor exposures (Fama-French)."""
        # Similar regression approach with multiple factors
        ...

    def _validate_attribution(self, results: dict):
        """Validate attribution components sum to total return."""
        total_return = self.backtest_result.total_return
        attributed_return = sum(results.values())  # Simplified

        if abs(total_return - attributed_return) > Decimal("0.0001"):
            raise ValueError(
                f"Attribution mismatch: total={total_return}, "
                f"attributed={attributed_return}"
            )
```

### Testing
[Source: docs/architecture/testing-strategy.md]
- **Test Location**: `tests/analytics/test_attribution.py`
- **Test Types**:
  - Unit tests: Alpha/beta calculation, factor regression
  - Property tests: Attribution components sum to total return
  - Integration tests: Full attribution on synthetic backtest
- **Coverage Target**: ≥90%

### Zero-Mock Enforcement
[Source: docs/architecture/coding-standards.md#zero-mock-enforcement-mandatory]
- Alpha/beta calculations must use actual regression, not hardcoded values
- Statistical tests must run real tests (t-test, regression)
- Attribution validation must perform actual arithmetic checks

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-31 | 1.0 | Initial story draft | Bob (Scrum Master) |

## Dev Agent Record
_This section will be populated by the development agent during implementation._

### Agent Model Used
_Not yet populated_

### Debug Log References
_Not yet populated_

### Completion Notes List
_Not yet populated_

### File List
_Not yet populated_

## QA Results
_This section will be populated by the QA Agent after story completion._
