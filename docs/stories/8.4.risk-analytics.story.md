# Story 8.4: Risk Analytics (VaR, CVaR, Stress Testing)

## Status
Ready for development

## Story
**As a** quantitative trader,
**I want** comprehensive risk analytics to understand strategy risk profile,
**so that** I can make informed decisions about position sizing and risk limits.

## Acceptance Criteria
1. VaR (Value at Risk) calculated at 95% and 99% confidence levels (parametric, historical, Monte Carlo methods)
2. CVaR (Conditional VaR / Expected Shortfall) calculated (average loss beyond VaR threshold)
3. Stress testing: simulate extreme scenarios (2008 crisis, COVID crash, flash crash)
4. Scenario analysis: user-defined scenarios (e.g., "what if rates rise 2%?")
5. Correlation analysis: portfolio correlation matrix, factor correlation
6. Beta analysis: portfolio beta vs. benchmark (market sensitivity)
7. Tail risk metrics: skewness, kurtosis, max loss in worst N days
8. Risk decomposition: which positions contribute most to portfolio risk?
9. Tests validate risk calculations with known scenarios
10. Visualization of risk metrics (VaR distribution, stress test results)

## Tasks / Subtasks
- [ ] Create RiskAnalytics class (AC: 1-10)
  - [ ] Implement `__init__(backtest_result, confidence_levels=[0.95, 0.99])`
  - [ ] Implement `analyze_risk()` method returning comprehensive risk report
- [ ] Implement VaR calculations (AC: 1)
  - [ ] Parametric VaR (assumes normal distribution)
  - [ ] Historical VaR (empirical quantiles)
  - [ ] Monte Carlo VaR (simulation-based)
  - [ ] Calculate at 95% and 99% confidence levels
  - [ ] Return VaR as Decimal (dollar amount)
- [ ] Implement CVaR (Conditional VaR / Expected Shortfall) (AC: 2)
  - [ ] Calculate average loss beyond VaR threshold
  - [ ] Implement for all three VaR methods (parametric, historical, Monte Carlo)
  - [ ] Return CVaR as Decimal
- [ ] Implement stress testing (AC: 3)
  - [ ] Create predefined stress scenarios: 2008 Financial Crisis, COVID-19 Crash, Flash Crash
  - [ ] Apply historical shock magnitudes to portfolio
  - [ ] Calculate estimated loss under each scenario
  - [ ] Return stress test results as dictionary {scenario: loss}
- [ ] Implement scenario analysis (AC: 4)
  - [ ] Support user-defined scenarios (e.g., {"SPY": -0.2, "TLT": 0.1})
  - [ ] Apply scenario shocks to portfolio positions
  - [ ] Calculate total portfolio impact
  - [ ] Support multiple scenarios in batch
- [ ] Implement correlation analysis (AC: 5)
  - [ ] Calculate correlation matrix of portfolio assets
  - [ ] Calculate factor correlations (if factor data available)
  - [ ] Identify highly correlated positions (concentration risk)
  - [ ] Visualize correlation heatmap
- [ ] Implement beta analysis (AC: 6)
  - [ ] Calculate portfolio beta vs. benchmark (if provided)
  - [ ] Calculate beta of individual positions
  - [ ] Calculate weighted average portfolio beta
  - [ ] Return beta as Decimal
- [ ] Implement tail risk metrics (AC: 7)
  - [ ] Calculate skewness (asymmetry of returns distribution)
  - [ ] Calculate kurtosis (fat tails)
  - [ ] Calculate max loss in worst 1, 5, 10 days
  - [ ] Calculate downside deviation (semideviation)
- [ ] Implement risk decomposition (AC: 8)
  - [ ] Calculate marginal VaR per position
  - [ ] Calculate component VaR (contribution to total portfolio VaR)
  - [ ] Rank positions by risk contribution
  - [ ] Return as DataFrame sorted by risk contribution
- [ ] Implement visualizations (AC: 10)
  - [ ] Plot VaR distribution (histogram with VaR threshold line)
  - [ ] Plot stress test results (bar chart of losses per scenario)
  - [ ] Plot correlation heatmap
  - [ ] Plot risk decomposition (bar chart of top risk contributors)
- [ ] Write tests (AC: 9)
  - [ ] Unit test: VaR calculation with synthetic normal returns
  - [ ] Unit test: CVaR calculation validates expected value beyond threshold
  - [ ] Unit test: Stress test applies correct shocks
  - [ ] Property test: CVaR >= VaR (always true)
  - [ ] Integration test: Full risk analysis on completed backtest
- [ ] Write documentation
  - [ ] Document risk methodologies (VaR, CVaR, stress testing)
  - [ ] Explain interpretation of risk metrics
  - [ ] Provide examples: "How to use VaR for position sizing"
  - [ ] Reference academic papers and industry standards (Basel III)

## Dev Notes

### Relevant Source Tree
[Source: docs/architecture/source-tree.md]
- RiskAnalytics: `rustybt/analytics/risk.py` (NEW)
- Helper functions: May extend `rustybt/finance/metrics/core.py` if needed

### Tech Stack
[Source: docs/architecture/tech-stack.md]
- **Statistics**: **scipy** (distributions, statistical tests)
- **Monte Carlo**: **numpy** (random number generation) or **scipy.stats**
- **DataFrames**: **polars** (data manipulation)
- **Visualization**: **matplotlib** and **seaborn** (charts)

### Risk Analytics Methodologies

**1. Value at Risk (VaR):**
VaR is the maximum expected loss at a given confidence level over a time horizon.

**Parametric VaR (assumes normal distribution):**
```
VaR = μ - σ * z
where:
  μ = mean daily return
  σ = standard deviation of daily returns
  z = z-score for confidence level (e.g., 1.645 for 95%, 2.326 for 99%)
```

**Historical VaR (empirical quantiles):**
```
VaR = α-quantile of historical returns
where α = 1 - confidence level
```

**Monte Carlo VaR:**
```
1. Simulate 10,000+ portfolio return scenarios
2. Calculate α-quantile of simulated returns
```

**2. Conditional VaR (CVaR / Expected Shortfall):**
```
CVaR = E[Loss | Loss > VaR]

Average loss in the worst (1 - confidence_level) % of cases
```

**3. Stress Testing:**
Apply historical crisis shocks to current portfolio:
- **2008 Financial Crisis**: SPY -50%, TLT +20%, Gold +5%
- **COVID-19 Crash**: SPY -35%, VIX +400%, Bonds +5%
- **Flash Crash**: SPY -10% in 1 day, immediate recovery

**4. Tail Risk Metrics:**
- **Skewness**: Measures asymmetry (negative skew = more extreme losses)
- **Kurtosis**: Measures fat tails (high kurtosis = more extreme events)
- **Max Drawdown**: Largest peak-to-trough decline
- **Downside Deviation**: Standard deviation of negative returns only

**5. Risk Decomposition (Component VaR):**
```
Component VaR_i = β_i * VaR_portfolio

where β_i = marginal contribution of position i to portfolio risk
```

### Example Code Pattern
```python
from decimal import Decimal
from typing import Dict, Optional
import polars as pl
import numpy as np
from scipy import stats

class RiskAnalytics:
    """Comprehensive risk analytics."""

    def __init__(
        self,
        backtest_result,
        confidence_levels: list[float] = [0.95, 0.99],
        benchmark_returns: Optional[pl.Series] = None
    ):
        self.backtest_result = backtest_result
        self.confidence_levels = confidence_levels
        self.benchmark_returns = benchmark_returns
        self.returns = backtest_result.returns

    def analyze_risk(self) -> dict:
        """Run comprehensive risk analysis."""
        return {
            'var': self.calculate_var(),
            'cvar': self.calculate_cvar(),
            'stress_tests': self.run_stress_tests(),
            'tail_risk': self.calculate_tail_risk(),
            'beta': self.calculate_beta() if self.benchmark_returns else None
        }

    def calculate_var(self, method: str = 'historical') -> Dict[str, Decimal]:
        """Calculate Value at Risk at multiple confidence levels."""
        results = {}

        for confidence in self.confidence_levels:
            if method == 'parametric':
                var = self._var_parametric(confidence)
            elif method == 'historical':
                var = self._var_historical(confidence)
            elif method == 'montecarlo':
                var = self._var_montecarlo(confidence)
            else:
                raise ValueError(f"Unknown VaR method: {method}")

            results[f'var_{int(confidence * 100)}'] = var

        return results

    def _var_parametric(self, confidence: float) -> Decimal:
        """Parametric VaR (assumes normal distribution)."""
        returns_array = self.returns.to_numpy()
        mean = returns_array.mean()
        std = returns_array.std()
        z_score = stats.norm.ppf(1 - confidence)

        var = mean + z_score * std  # z_score is negative for losses
        return Decimal(str(var))

    def _var_historical(self, confidence: float) -> Decimal:
        """Historical VaR (empirical quantile)."""
        quantile = 1 - confidence
        var = self.returns.quantile(quantile)
        return Decimal(str(var))

    def calculate_cvar(self, method: str = 'historical') -> Dict[str, Decimal]:
        """Calculate Conditional VaR (Expected Shortfall)."""
        var_results = self.calculate_var(method=method)
        cvar_results = {}

        for confidence in self.confidence_levels:
            var = var_results[f'var_{int(confidence * 100)}']

            # CVaR = average loss beyond VaR
            tail_losses = self.returns.filter(self.returns <= float(var))
            cvar = tail_losses.mean()

            cvar_results[f'cvar_{int(confidence * 100)}'] = Decimal(str(cvar))

        return cvar_results

    def run_stress_tests(self) -> Dict[str, Decimal]:
        """Run predefined stress test scenarios."""
        scenarios = {
            '2008_financial_crisis': {'SPY': -0.50, 'TLT': 0.20, 'GLD': 0.05},
            'covid_crash': {'SPY': -0.35, 'TLT': 0.05},
            'flash_crash': {'SPY': -0.10}
        }

        results = {}
        for scenario_name, shocks in scenarios.items():
            loss = self._apply_scenario(shocks)
            results[scenario_name] = loss

        return results

    def _apply_scenario(self, shocks: Dict[str, float]) -> Decimal:
        """Apply scenario shocks to portfolio."""
        total_loss = Decimal(0)

        for position in self.backtest_result.positions:
            symbol = position.asset.symbol
            if symbol in shocks:
                shock = Decimal(str(shocks[symbol]))
                position_value = position.amount * position.last_sale_price
                position_loss = position_value * shock
                total_loss += position_loss

        return total_loss
```

### Testing
[Source: docs/architecture/testing-strategy.md]
- **Test Location**: `tests/analytics/test_risk.py`
- **Test Types**:
  - Unit tests: VaR, CVaR calculations with synthetic data
  - Property tests: CVaR >= VaR, VaR at 99% <= VaR at 95%
  - Integration tests: Full risk analysis on completed backtest
- **Coverage Target**: ≥90%

### Zero-Mock Enforcement
[Source: docs/architecture/coding-standards.md#zero-mock-enforcement-mandatory]
- VaR/CVaR must calculate from actual return distributions, not hardcoded values
- Stress tests must apply actual shocks to actual positions
- Monte Carlo simulations must run actual random draws, not fake data

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-31 | 1.0 | Initial story draft | Bob (Scrum Master) |

## Dev Agent Record
_This section will be populated by the development agent during implementation._

### Agent Model Used
_Not yet populated_

### Debug Log References
_Not yet populated_

### Completion Notes List
_Not yet populated_

### File List
_Not yet populated_

## QA Results
_This section will be populated by the QA Agent after story completion._
