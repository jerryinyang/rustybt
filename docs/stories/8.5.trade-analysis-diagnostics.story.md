# Story 8.5: Trade Analysis and Diagnostics

## Status
Ready for development

## Story
**As a** quantitative trader,
**I want** detailed trade analysis showing entry/exit quality and patterns,
**so that** I can identify strategy weaknesses and improve execution.

## Acceptance Criteria
1. Trade log with all trades (entry/exit time, price, PnL, duration)
2. Entry/exit quality analysis (how close to optimal entry/exit points?)
3. Holding period distribution (histogram of trade durations)
4. Win/loss distribution (histogram of trade PnLs)
5. MAE/MFE analysis (Maximum Adverse Excursion / Maximum Favorable Excursion)
6. Trade clustering analysis (are trades concentrated in time/assets?)
7. Slippage analysis (realized slippage vs. expected)
8. Commission impact analysis (how much do fees erode returns?)
9. Tests validate trade analysis with synthetic trade data
10. Visualization of trade patterns (scatter plots, heatmaps)

## Tasks / Subtasks
- [ ] Create TradeAnalyzer class (AC: 1-10)
  - [ ] Implement `__init__(backtest_result)`
  - [ ] Implement `analyze_trades()` method returning comprehensive trade report
  - [ ] Extract trade log from backtest transactions
- [ ] Extract trade log (AC: 1)
  - [ ] Parse transactions to identify trade entries and exits
  - [ ] Calculate trade duration (entry â†’ exit time)
  - [ ] Calculate trade PnL (exit price - entry price - commissions - slippage)
  - [ ] Return as Polars DataFrame with columns: entry_time, exit_time, asset, entry_price, exit_price, amount, pnl, duration, commission, slippage
- [ ] Implement entry/exit quality analysis (AC: 2)
  - [ ] For each trade, calculate optimal entry point (lowest price in N bars before entry)
  - [ ] Calculate entry quality: (optimal_entry - actual_entry) / optimal_entry
  - [ ] Similarly for exit quality: (actual_exit - optimal_exit) / optimal_exit
  - [ ] Average entry/exit quality across all trades
- [ ] Implement holding period distribution (AC: 3)
  - [ ] Calculate trade durations (in days or bars)
  - [ ] Create histogram of durations
  - [ ] Calculate mean, median, mode holding period
  - [ ] Identify long vs. short duration trades
- [ ] Implement win/loss distribution (AC: 4)
  - [ ] Create histogram of trade PnLs
  - [ ] Calculate win rate (% of profitable trades)
  - [ ] Calculate average win, average loss
  - [ ] Calculate profit factor (total wins / total losses)
  - [ ] Calculate largest win, largest loss
- [ ] Implement MAE/MFE analysis (AC: 5)
  - [ ] For each trade, track max adverse excursion (worst price during trade)
  - [ ] Track max favorable excursion (best price during trade)
  - [ ] Calculate MAE/MFE as percentage of entry price
  - [ ] Plot MAE vs. final PnL (scatter plot)
  - [ ] Plot MFE vs. final PnL (scatter plot)
- [ ] Implement trade clustering analysis (AC: 6)
  - [ ] Calculate trade frequency over time (trades per day/week)
  - [ ] Identify periods of high trading activity
  - [ ] Calculate asset concentration (% of trades in top N assets)
  - [ ] Detect if trades are evenly distributed or clustered
- [ ] Implement slippage analysis (AC: 7)
  - [ ] Calculate realized slippage (actual fill price - expected price)
  - [ ] Compare to slippage model assumptions
  - [ ] Calculate slippage cost per trade
  - [ ] Identify trades with excessive slippage
- [ ] Implement commission impact analysis (AC: 8)
  - [ ] Calculate total commissions paid
  - [ ] Calculate commissions as % of total return
  - [ ] Calculate commissions per trade
  - [ ] Identify high-commission trades
- [ ] Implement visualizations (AC: 10)
  - [ ] Plot holding period histogram
  - [ ] Plot win/loss distribution histogram
  - [ ] Plot MAE/MFE scatter plots
  - [ ] Plot trade timeline (scatter plot: time vs. PnL)
  - [ ] Plot trade heatmap (asset vs. time)
- [ ] Write tests (AC: 9)
  - [ ] Unit test: Trade extraction from synthetic transactions
  - [ ] Unit test: Entry/exit quality calculation
  - [ ] Unit test: MAE/MFE calculation
  - [ ] Integration test: Full trade analysis on completed backtest
  - [ ] Property test: Sum of trade PnLs equals total portfolio return
- [ ] Write documentation
  - [ ] Document trade analysis metrics (MAE, MFE, quality scores)
  - [ ] Explain interpretation of trade patterns
  - [ ] Provide examples: "How to use MAE to set stop losses"
  - [ ] Reference: Tomasini & Jaekle - "Trading Systems" (MAE/MFE methodology)

## Dev Notes

### Relevant Source Tree
[Source: docs/architecture/source-tree.md]
- TradeAnalyzer: `rustybt/analytics/trade_analysis.py` (NEW)
- May read from: `rustybt/finance/decimal/transaction.py` (transaction data)

### Tech Stack
[Source: docs/architecture/tech-stack.md]
- **DataFrames**: **polars** (trade log manipulation)
- **Visualization**: **matplotlib** and **seaborn** (charts)
- **Statistics**: **scipy** (statistical analysis if needed)

### Trade Analysis Methodologies

**1. Maximum Adverse Excursion (MAE):**
MAE measures the worst price movement against the trade during its lifetime.
```
MAE = max(entry_price - lowest_price_during_trade) / entry_price  (for longs)
MAE = max(highest_price_during_trade - entry_price) / entry_price  (for shorts)
```

**Use Case:** Setting stop losses
- Plot MAE vs. final PnL
- Optimal stop loss = MAE level that avoids most losing trades but preserves winners

**2. Maximum Favorable Excursion (MFE):**
MFE measures the best price movement in favor of the trade.
```
MFE = max(highest_price_during_trade - entry_price) / entry_price  (for longs)
```

**Use Case:** Setting profit targets
- Plot MFE vs. final PnL
- Optimal profit target = MFE level that captures most gains without premature exit

**3. Entry/Exit Quality:**
Measures how close entry/exit prices are to optimal prices in hindsight.
```
Entry Quality = 1 - (actual_entry - optimal_entry) / optimal_entry
Exit Quality = (actual_exit - optimal_exit) / optimal_exit

where:
  optimal_entry = lowest price in N bars before entry
  optimal_exit = highest price in N bars after exit
```

**4. Trade Clustering:**
Identifies whether trades are evenly distributed or concentrated:
- **Time Clustering**: High trading frequency in certain periods
- **Asset Clustering**: Most trades in few assets (concentration risk)

**5. Slippage Analysis:**
```
Realized Slippage = actual_fill_price - expected_price

Expected slippage from model vs. realized slippage
```

### Example Code Pattern
```python
from decimal import Decimal
from typing import List, Dict
import polars as pl
from dataclasses import dataclass

@dataclass
class Trade:
    """Single trade record."""
    entry_time: pd.Timestamp
    exit_time: pd.Timestamp
    asset: Asset
    entry_price: Decimal
    exit_price: Decimal
    amount: Decimal
    pnl: Decimal
    duration: pd.Timedelta
    commission: Decimal
    slippage: Decimal
    mae: Decimal  # Maximum Adverse Excursion
    mfe: Decimal  # Maximum Favorable Excursion

class TradeAnalyzer:
    """Analyze trade execution quality and patterns."""

    def __init__(self, backtest_result):
        self.backtest_result = backtest_result
        self.trades = self._extract_trades()

    def _extract_trades(self) -> List[Trade]:
        """Extract individual trades from transactions."""
        trades = []
        open_positions = {}  # Track open positions

        for transaction in self.backtest_result.transactions:
            asset = transaction.asset
            amount = transaction.amount

            if asset not in open_positions:
                # New position opened
                open_positions[asset] = {
                    'entry_time': transaction.dt,
                    'entry_price': transaction.price,
                    'amount': amount
                }
            elif amount * open_positions[asset]['amount'] < 0:
                # Position closed (opposite sign)
                entry = open_positions[asset]
                trade = Trade(
                    entry_time=entry['entry_time'],
                    exit_time=transaction.dt,
                    asset=asset,
                    entry_price=entry['entry_price'],
                    exit_price=transaction.price,
                    amount=entry['amount'],
                    pnl=self._calculate_pnl(entry, transaction),
                    duration=transaction.dt - entry['entry_time'],
                    commission=transaction.commission,
                    slippage=Decimal(0),  # Calculate if slippage data available
                    mae=self._calculate_mae(entry, transaction),
                    mfe=self._calculate_mfe(entry, transaction)
                )
                trades.append(trade)
                del open_positions[asset]

        return trades

    def _calculate_mae(self, entry: dict, exit_transaction) -> Decimal:
        """Calculate Maximum Adverse Excursion."""
        # Get price history during trade
        price_history = self.backtest_result.get_price_history(
            entry['asset'],
            start=entry['entry_time'],
            end=exit_transaction.dt
        )

        if entry['amount'] > 0:  # Long position
            lowest_price = price_history.min()
            mae = (entry['entry_price'] - lowest_price) / entry['entry_price']
        else:  # Short position
            highest_price = price_history.max()
            mae = (highest_price - entry['entry_price']) / entry['entry_price']

        return max(Decimal(0), Decimal(str(mae)))

    def analyze_trades(self) -> dict:
        """Run comprehensive trade analysis."""
        trades_df = self._trades_to_dataframe()

        return {
            'trade_log': trades_df,
            'summary_stats': self._calculate_summary_stats(trades_df),
            'entry_exit_quality': self._analyze_entry_exit_quality(),
            'mae_mfe_analysis': self._analyze_mae_mfe(),
            'clustering': self._analyze_clustering(),
            'slippage': self._analyze_slippage(),
            'commission_impact': self._analyze_commissions()
        }

    def _calculate_summary_stats(self, trades_df: pl.DataFrame) -> dict:
        """Calculate trade summary statistics."""
        return {
            'total_trades': len(trades_df),
            'win_rate': (trades_df['pnl'] > 0).sum() / len(trades_df),
            'average_win': trades_df.filter(pl.col('pnl') > 0)['pnl'].mean(),
            'average_loss': trades_df.filter(pl.col('pnl') < 0)['pnl'].mean(),
            'profit_factor': (
                trades_df.filter(pl.col('pnl') > 0)['pnl'].sum() /
                abs(trades_df.filter(pl.col('pnl') < 0)['pnl'].sum())
            ),
            'average_duration': trades_df['duration'].mean()
        }
```

### Testing
[Source: docs/architecture/testing-strategy.md]
- **Test Location**: `tests/analytics/test_trade_analysis.py`
- **Test Types**:
  - Unit tests: Trade extraction, MAE/MFE calculation, quality scores
  - Property tests: Sum of trade PnLs equals total return
  - Integration tests: Full trade analysis on completed backtest
- **Coverage Target**: â‰¥90%

### Zero-Mock Enforcement
[Source: docs/architecture/coding-standards.md#zero-mock-enforcement-mandatory]
- Trade extraction must parse actual transactions, not return fake trades
- MAE/MFE must calculate from actual price history
- Quality scores must use actual entry/exit prices, not hardcoded values

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-31 | 1.0 | Initial story draft | Bob (Scrum Master) |

## Dev Agent Record
_This section will be populated by the development agent during implementation._

### Agent Model Used
_Not yet populated_

### Debug Log References
_Not yet populated_

### Completion Notes List
_Not yet populated_

### File List
_Not yet populated_

## QA Results
_This section will be populated by the QA Agent after story completion._
