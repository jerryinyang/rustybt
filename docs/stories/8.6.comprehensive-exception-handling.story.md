# Story 8.6: Comprehensive Exception Handling

## Status
Ready for development

## Story
**As a** developer,
**I want** robust exception handling with custom exception hierarchy,
**so that** errors are caught gracefully and provide actionable information.

## Acceptance Criteria
1. Custom exception hierarchy defined (RustyBTError base, specific subclasses)
2. Exception categories: DataError, OrderError, BrokerError, StrategyError, ValidationError
3. All external API calls wrapped in try/except with retries for transient errors
4. Unrecoverable errors logged and raised (don't silently fail)
5. Recoverable errors logged and handled (graceful degradation)
6. User-facing errors provide clear messages (not stack traces)
7. Developer errors provide full context (stack trace, relevant state)
8. Tests validate exception handling for various error scenarios
9. Documentation explains exception hierarchy and handling patterns
10. Error handling best practices guide for contributors

## Tasks / Subtasks
- [ ] Design custom exception hierarchy (AC: 1, 2)
  - [ ] Create base exception: `RustyBTError`
  - [ ] Create subclasses: `DataError`, `OrderError`, `BrokerError`, `StrategyError`, `ValidationError`
  - [ ] Add nested exceptions for specific cases (e.g., `OrderRejectedError(OrderError)`)
  - [ ] Implement `__init__` with context fields (asset, order_id, broker_name, etc.)
- [ ] Implement exception classes (AC: 1, 2)
  - [ ] File: `rustybt/exceptions.py`
  - [ ] Base exception with `__repr__` showing context
  - [ ] Each exception stores relevant context (asset, broker, error_code, etc.)
- [ ] Wrap broker API calls with error handling (AC: 3)
  - [ ] Implement retry logic for transient errors (network failures, rate limits)
  - [ ] Use exponential backoff with jitter
  - [ ] Log retries with context
  - [ ] Raise BrokerError after max retries exhausted
- [ ] Wrap data adapter API calls with error handling (AC: 3)
  - [ ] Handle network errors, invalid responses, missing data
  - [ ] Retry transient errors
  - [ ] Raise DataError for unrecoverable issues
- [ ] Implement graceful degradation (AC: 5)
  - [ ] If non-critical data fetch fails, use cached data or skip
  - [ ] Log warning but don't halt execution
  - [ ] Example: If unable to fetch latest price, use last known price
- [ ] Distinguish user-facing vs. developer errors (AC: 6, 7)
  - [ ] User-facing: Clear message, no stack trace (e.g., "Order rejected: insufficient funds")
  - [ ] Developer: Full stack trace, state dump (for debugging)
  - [ ] Use logging levels: ERROR for user issues, CRITICAL for system failures
- [ ] Implement error logging (AC: 4, 5)
  - [ ] Log all exceptions with structured context (asset, broker, order_id)
  - [ ] Use structlog for structured logging
  - [ ] Include exception type, message, traceback (for developer errors)
- [ ] Write tests for exception handling (AC: 8)
  - [ ] Unit test: Each exception class construction
  - [ ] Unit test: Retry logic with mock broker (simulate transient failures)
  - [ ] Integration test: Broker connection failure → BrokerError raised
  - [ ] Integration test: Invalid data → DataError raised
  - [ ] Test: Graceful degradation (non-critical error → execution continues)
- [ ] Write documentation (AC: 9, 10)
  - [ ] Document exception hierarchy (diagram)
  - [ ] Explain when to use each exception type
  - [ ] Provide examples: "How to handle broker errors"
  - [ ] Best practices guide for contributors

## Dev Notes

### Relevant Source Tree
[Source: docs/architecture/source-tree.md]
- Exception classes: `rustybt/exceptions.py` (NEW)
- Error handling utilities: `rustybt/utils/error_handling.py` (NEW)
- Update broker adapters: `rustybt/live/brokers/*.py` (wrap API calls)
- Update data adapters: `rustybt/data/adapters/*.py` (wrap API calls)

### Tech Stack
[Source: docs/architecture/tech-stack.md]
- **Logging**: **structlog** (structured logging, already in use)
- **Async Retries**: **tenacity** (retry library with exponential backoff) or custom implementation

### Exception Hierarchy Design
[Source: docs/architecture/coding-standards.md#error-handling]
```
RustyBTError (base)
├── DataError (data-related errors)
│   ├── DataNotFoundError (missing data)
│   ├── DataValidationError (invalid data format/values)
│   ├── LookaheadError (future data accessed)
│   └── DataAdapterError (data source adapter failure)
├── OrderError (order-related errors)
│   ├── OrderRejectedError (broker rejected order)
│   ├── OrderNotFoundError (order ID not found)
│   ├── InsufficientFundsError (not enough cash/margin)
│   └── InvalidOrderError (invalid order parameters)
├── BrokerError (broker API errors)
│   ├── BrokerConnectionError (connection failure)
│   ├── BrokerAuthenticationError (auth failure)
│   ├── BrokerRateLimitError (rate limit exceeded)
│   └── BrokerResponseError (invalid response)
├── StrategyError (strategy logic errors)
│   ├── StrategyInitializationError (initialize() failed)
│   ├── StrategyExecutionError (handle_data() failed)
│   └── InvalidSignalError (invalid trading signal)
├── ValidationError (validation errors)
│   ├── ConfigValidationError (invalid config)
│   ├── AssetValidationError (invalid asset)
│   └── ParameterValidationError (invalid parameter)
└── CircuitBreakerError (circuit breaker tripped)
    ├── CircuitBreakerTrippedError (breaker in OPEN state)
    └── AlignmentCircuitBreakerError (backtest-live misalignment)
```

### Error Handling Patterns

**1. Retry with Exponential Backoff:**
```python
import time
import random
from typing import Callable, TypeVar

T = TypeVar('T')

def retry_with_backoff(
    func: Callable[..., T],
    max_retries: int = 3,
    base_delay: float = 1.0,
    max_delay: float = 60.0,
    jitter: bool = True
) -> T:
    """Retry function with exponential backoff."""
    for attempt in range(max_retries):
        try:
            return func()
        except (BrokerConnectionError, BrokerRateLimitError) as e:
            if attempt == max_retries - 1:
                logger.error("max_retries_exhausted", error=str(e), attempts=max_retries)
                raise BrokerError(f"Max retries exhausted: {e}") from e

            delay = min(base_delay * (2 ** attempt), max_delay)
            if jitter:
                delay *= (0.5 + random.random())  # Add jitter

            logger.warning("retrying_after_error", error=str(e), attempt=attempt + 1, delay=delay)
            time.sleep(delay)
```

**2. Graceful Degradation:**
```python
def get_current_price(asset: Asset, data_portal) -> Decimal:
    """Get current price with fallback to cached price."""
    try:
        return data_portal.get_spot_value(asset, 'close')
    except DataNotFoundError as e:
        logger.warning("price_not_found_using_cache", asset=asset.symbol, error=str(e))
        # Fallback to last known price
        cached_price = cache.get_last_price(asset)
        if cached_price is not None:
            return cached_price
        else:
            # No fallback available, re-raise
            raise DataError(f"No price available for {asset.symbol}") from e
```

**3. Context-Rich Exceptions:**
```python
class OrderRejectedError(OrderError):
    """Order rejected by broker."""

    def __init__(
        self,
        message: str,
        order_id: str,
        asset: Asset,
        broker: str,
        rejection_reason: str
    ):
        super().__init__(message)
        self.order_id = order_id
        self.asset = asset
        self.broker = broker
        self.rejection_reason = rejection_reason

    def __repr__(self):
        return (
            f"OrderRejectedError("
            f"order_id={self.order_id}, "
            f"asset={self.asset.symbol}, "
            f"broker={self.broker}, "
            f"reason={self.rejection_reason})"
        )

# Usage:
try:
    order_id = broker.submit_order(asset, amount)
except OrderRejectedError as e:
    logger.error(
        "order_rejected",
        order_id=e.order_id,
        asset=e.asset.symbol,
        broker=e.broker,
        reason=e.rejection_reason
    )
    # User-facing message
    print(f"Order rejected: {e.rejection_reason}")
```

### Example Implementation
```python
# rustybt/exceptions.py

class RustyBTError(Exception):
    """Base exception for all RustyBT errors."""
    pass

class DataError(RustyBTError):
    """Data-related errors."""
    pass

class DataNotFoundError(DataError):
    """Data not found for requested asset/timeframe."""
    
    def __init__(self, message: str, asset=None, start=None, end=None):
        super().__init__(message)
        self.asset = asset
        self.start = start
        self.end = end

class LookaheadError(DataError):
    """Future data accessed (lookahead bias)."""
    
    def __init__(self, message: str, requested_dt=None, current_dt=None):
        super().__init__(message)
        self.requested_dt = requested_dt
        self.current_dt = current_dt

class OrderError(RustyBTError):
    """Order-related errors."""
    pass

class OrderRejectedError(OrderError):
    """Order rejected by broker."""
    pass

class BrokerError(RustyBTError):
    """Broker API errors."""
    pass

class BrokerConnectionError(BrokerError):
    """Broker connection failure."""
    pass

class StrategyError(RustyBTError):
    """Strategy logic errors."""
    pass

class ValidationError(RustyBTError):
    """Validation errors."""
    pass
```

### Testing
[Source: docs/architecture/testing-strategy.md]
- **Test Location**: `tests/test_exceptions.py`, `tests/utils/test_error_handling.py`
- **Test Types**:
  - Unit tests: Exception construction, retry logic
  - Integration tests: Broker error handling, data adapter error handling
  - End-to-end tests: Graceful degradation scenarios
- **Coverage Target**: ≥90%

### Zero-Mock Enforcement
[Source: docs/architecture/coding-standards.md#zero-mock-enforcement-mandatory]
- Retry logic must actually retry, not return after first call
- Error logging must actually log, not be stubbed
- Tests should trigger real errors (e.g., invalid API key), not mock exceptions

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-31 | 1.0 | Initial story draft | Bob (Scrum Master) |

## Dev Agent Record
_This section will be populated by the development agent during implementation._

### Agent Model Used
_Not yet populated_

### Debug Log References
_Not yet populated_

### Completion Notes List
_Not yet populated_

### File List
_Not yet populated_

## QA Results
_This section will be populated by the QA Agent after story completion._
