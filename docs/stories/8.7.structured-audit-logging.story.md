# Story 8.7: Structured Audit Logging

## Status
Ready for development

## Story
**As a** quantitative trader,
**I want** comprehensive trade-by-trade audit logging in searchable format,
**so that** I can review all system actions and debug issues.

## Acceptance Criteria
1. structlog integrated for structured logging (JSON format)
2. Trade logging: every order submission, fill, modification, cancellation logged with full details
3. Strategy decision logging: signals, reasons for trades, parameter values at decision time
4. System event logging: startup, shutdown, errors, circuit breaker trips
5. Log context includes timestamp, strategy ID, asset, order ID, user (if applicable)
6. Logs searchable (JSON format enables easy filtering with jq, grep, or log aggregation tools)
7. Log rotation configured (prevent unbounded log growth)
8. Sensitive data masked (API keys, credentials not logged)
9. Tests validate logging coverage for critical events
10. Documentation explains log format and querying examples

## Tasks / Subtasks
- [ ] Integrate structlog (AC: 1)
  - [ ] Add structlog dependency to pyproject.toml
  - [ ] Configure structlog with JSON renderer
  - [ ] Set up global logger configuration
  - [ ] Configure log levels (DEBUG, INFO, WARNING, ERROR, CRITICAL)
- [ ] Implement trade logging (AC: 2)
  - [ ] Log order submission: order_id, asset, amount, order_type, limit_price, timestamp
  - [ ] Log order fill: order_id, fill_price, filled_amount, commission, slippage, timestamp
  - [ ] Log order modification: order_id, old_params, new_params, timestamp
  - [ ] Log order cancellation: order_id, reason, timestamp
  - [ ] Add to LiveTradingEngine, BrokerAdapter classes
- [ ] Implement strategy decision logging (AC: 3)
  - [ ] Log trading signals: signal_type (buy/sell/hold), asset, signal_strength, timestamp
  - [ ] Log reasoning: why trade was made (e.g., "momentum crossed threshold")
  - [ ] Log parameter values: strategy parameters at decision time
  - [ ] Add to TradingAlgorithm.handle_data() method
- [ ] Implement system event logging (AC: 4)
  - [ ] Log system startup: version, config, timestamp
  - [ ] Log system shutdown: reason (graceful/error), timestamp
  - [ ] Log errors: exception type, message, traceback, context
  - [ ] Log circuit breaker events: breaker_id, reason, timestamp
  - [ ] Add to main entry points, error handlers, circuit breaker classes
- [ ] Add contextual information (AC: 5)
  - [ ] Bind context to logger: strategy_id, user_id (if applicable)
  - [ ] Include asset symbol, order_id in trade logs
  - [ ] Include timestamp (ISO 8601 format with timezone)
  - [ ] Use structlog.contextvars or bind_contextvars for automatic context propagation
- [ ] Implement log searchability (AC: 6)
  - [ ] Use JSON format for all logs (enables jq, grep, log aggregation tools)
  - [ ] Document common search queries (e.g., "Find all rejected orders")
  - [ ] Provide example jq queries for common scenarios
- [ ] Configure log rotation (AC: 7)
  - [ ] Use logging.handlers.RotatingFileHandler or TimedRotatingFileHandler
  - [ ] Rotate logs daily or at 100MB size
  - [ ] Keep last 30 days of logs (configurable)
  - [ ] Compress rotated logs (gzip)
- [ ] Mask sensitive data (AC: 8)
  - [ ] Never log API keys, passwords, encryption keys
  - [ ] Mask sensitive fields in structured logs (e.g., api_key: "***")
  - [ ] Implement sensitive data filter processor in structlog
- [ ] Write tests (AC: 9)
  - [ ] Unit test: Logger configuration and JSON output
  - [ ] Integration test: Trade events logged correctly
  - [ ] Test: Sensitive data not logged
  - [ ] Test: Log rotation works (create large log, verify rotation)
- [ ] Write documentation (AC: 10)
  - [ ] Document log format (JSON schema)
  - [ ] Provide example logs for each event type
  - [ ] Document common queries (jq, grep examples)
  - [ ] Document log retention policy

## Dev Notes

### Relevant Source Tree
[Source: docs/architecture/source-tree.md]
- Logger configuration: `rustybt/utils/logging.py` (NEW)
- Update: `rustybt/algorithm.py` (add strategy decision logging)
- Update: `rustybt/live/engine.py` (add trade logging)
- Update: `rustybt/live/brokers/base.py` (add broker event logging)

### Tech Stack
[Source: docs/architecture/tech-stack.md]
- **Structured Logging**: **structlog** (already in architecture, not yet implemented)
- **Log Rotation**: **logging.handlers.RotatingFileHandler** (standard library)

### Audit Logging Architecture
[Source: docs/architecture/security-integration.md#audit-logging]
- **Comprehensive Trade-by-Trade Logging**: All orders logged to `order_audit_log` table (JSON format)
- **Searchable via SQL queries**
- **Log Retention**: 7 years (regulatory requirement, configurable)

### structlog Configuration
```python
# rustybt/utils/logging.py

import structlog
from structlog.processors import JSONRenderer, TimeStamper, add_log_level
from logging.handlers import TimedRotatingFileHandler
import logging
from pathlib import Path

def configure_logging(log_dir: Path = Path("logs"), log_level: str = "INFO"):
    """Configure structured logging with JSON output."""
    
    # Ensure log directory exists
    log_dir.mkdir(parents=True, exist_ok=True)
    
    # Configure standard library logging (structlog uses it as backend)
    logging.basicConfig(
        format="%(message)s",
        level=getattr(logging, log_level.upper()),
        handlers=[
            TimedRotatingFileHandler(
                filename=log_dir / "rustybt.log",
                when="midnight",
                interval=1,
                backupCount=30,  # Keep 30 days
                encoding="utf-8"
            ),
            logging.StreamHandler()  # Also log to console
        ]
    )
    
    # Configure structlog
    structlog.configure(
        processors=[
            structlog.contextvars.merge_contextvars,  # Include bound context
            add_log_level,
            TimeStamper(fmt="iso", utc=True),
            mask_sensitive_data,  # Custom processor to mask secrets
            JSONRenderer()
        ],
        wrapper_class=structlog.make_filtering_bound_logger(
            getattr(logging, log_level.upper())
        ),
        context_class=dict,
        logger_factory=structlog.stdlib.LoggerFactory(),
        cache_logger_on_first_use=True,
    )

def mask_sensitive_data(logger, method_name, event_dict):
    """Mask sensitive data in logs."""
    sensitive_keys = ['api_key', 'api_secret', 'password', 'token', 'encryption_key']
    
    for key in sensitive_keys:
        if key in event_dict:
            event_dict[key] = "***MASKED***"
    
    return event_dict

# Usage:
configure_logging()
logger = structlog.get_logger()
```

### Trade Logging Pattern
```python
# In LiveTradingEngine or BrokerAdapter

import structlog

logger = structlog.get_logger()

def submit_order(self, asset: Asset, amount: Decimal, order_type: str, **kwargs):
    """Submit order to broker with audit logging."""
    
    # Log order submission
    logger.info(
        "order_submitted",
        event_type="order_submitted",
        order_id=order_id,
        asset=asset.symbol,
        amount=str(amount),
        order_type=order_type,
        limit_price=str(kwargs.get('limit_price')) if 'limit_price' in kwargs else None,
        strategy_id=self.strategy_id,
        timestamp=pd.Timestamp.now(tz='UTC').isoformat()
    )
    
    try:
        order_id = self.broker.submit_order(asset, amount, order_type, **kwargs)
        
        # Log successful submission
        logger.info(
            "order_accepted",
            event_type="order_accepted",
            order_id=order_id,
            broker=self.broker.name,
            timestamp=pd.Timestamp.now(tz='UTC').isoformat()
        )
        
        return order_id
    
    except OrderRejectedError as e:
        # Log rejection
        logger.error(
            "order_rejected",
            event_type="order_rejected",
            asset=asset.symbol,
            amount=str(amount),
            rejection_reason=e.rejection_reason,
            strategy_id=self.strategy_id,
            timestamp=pd.Timestamp.now(tz='UTC').isoformat()
        )
        raise

def on_order_fill(self, order_id: str, fill_event: dict):
    """Log order fill event."""
    logger.info(
        "order_filled",
        event_type="order_filled",
        order_id=order_id,
        fill_price=str(fill_event['fill_price']),
        filled_amount=str(fill_event['filled_amount']),
        commission=str(fill_event['commission']),
        slippage=str(fill_event.get('slippage', 0)),
        strategy_id=self.strategy_id,
        timestamp=fill_event['timestamp'].isoformat()
    )
```

### Strategy Decision Logging Pattern
```python
# In TradingAlgorithm.handle_data()

def handle_data(self, context, data):
    """Handle market data with decision logging."""
    
    # Calculate signal
    signal = self.calculate_signal(context, data)
    
    # Log signal and reasoning
    logger.info(
        "trading_signal",
        event_type="trading_signal",
        signal_type=signal.type,  # 'buy', 'sell', 'hold'
        asset=signal.asset.symbol,
        signal_strength=str(signal.strength),
        reasoning=signal.reasoning,  # e.g., "momentum > 0.5"
        strategy_id=context.strategy_id,
        parameters=self.get_current_parameters(),  # Strategy params
        timestamp=data.current_dt.isoformat()
    )
    
    if signal.type == 'buy':
        order_id = self.order(signal.asset, signal.amount)
        
        logger.info(
            "order_placed",
            event_type="order_placed",
            order_id=order_id,
            asset=signal.asset.symbol,
            amount=str(signal.amount),
            reason=signal.reasoning,
            timestamp=data.current_dt.isoformat()
        )
```

### Example Log Queries
```bash
# Find all rejected orders
cat rustybt.log | jq 'select(.event_type == "order_rejected")'

# Find all trades for AAPL
cat rustybt.log | jq 'select(.asset == "AAPL")'

# Find all errors in last hour
cat rustybt.log | jq 'select(.level == "error" and .timestamp > "'$(date -u -d '1 hour ago' +%Y-%m-%dT%H:%M:%S)'")'

# Find circuit breaker trips
cat rustybt.log | jq 'select(.event_type == "circuit_breaker_tripped")'

# Calculate total commissions paid
cat rustybt.log | jq 'select(.event_type == "order_filled") | .commission | tonumber' | awk '{sum+=$1} END {print sum}'
```

### Testing
[Source: docs/architecture/testing-strategy.md]
- **Test Location**: `tests/utils/test_logging.py`
- **Test Types**:
  - Unit tests: Logger configuration, JSON output format
  - Integration tests: Trade events logged, strategy decisions logged
  - Security tests: Sensitive data masked
  - Rotation tests: Log rotation works correctly
- **Coverage Target**: â‰¥90%

### Zero-Mock Enforcement
[Source: docs/architecture/coding-standards.md#zero-mock-enforcement-mandatory]
- Logger must actually write to files, not be mocked
- Log entries must contain actual data, not hardcoded values
- Tests should verify actual log content

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-31 | 1.0 | Initial story draft | Bob (Scrum Master) |

## Dev Agent Record
_This section will be populated by the development agent during implementation._

### Agent Model Used
_Not yet populated_

### Debug Log References
_Not yet populated_

### Completion Notes List
_Not yet populated_

### File List
_Not yet populated_

## QA Results
_This section will be populated by the QA Agent after story completion._
