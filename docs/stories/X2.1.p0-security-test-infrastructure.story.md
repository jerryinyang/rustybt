# Story X2.1: P0 Security & Test Infrastructure

## Status
Draft

## Story

**As a** Platform Engineer preparing RustyBT for production deployment,
**I want** critical security vulnerabilities remediated, the test suite fully operational with coverage measurement, and comprehensive property-based testing for financial calculations,
**so that** I can verify system integrity, certify security posture and mathematical correctness, and confidently deploy to production environments.

## Acceptance Criteria

### Security Requirements

1. **Safe Tarfile Extraction**
   - `rustybt/data/bundles/quandl.py:326` implements path traversal validation
   - Extraction validates all tar members before extraction
   - Unsafe members (path traversal attempts) raise ValueError with descriptive message
   - Existing bundle download/extraction functionality works unchanged
   - Unit test added covering safe extraction and attack prevention

2. **Exec/Eval Safeguards**
   - `rustybt/algorithm.py` exec/eval usage reviewed and documented with threat model
   - `rustybt/utils/run_algo.py` exec/eval usage has input validation or whitelist
   - `rustybt/utils/preprocess.py` exec/eval replaced with ast.literal_eval where semantics allow
   - Threat model documented: trusted vs. untrusted code sources
   - Security comments added explaining guardrails and restrictions

3. **SQL Parameterization**
   - All SQL f-string constructions identified via grep/code review
   - Table/column name f-strings sanitized with whitelist validation
   - Dynamic SQL uses parameterized queries where supported by SQLAlchemy
   - Remaining f-strings justified with `# nosec` and documented constraints

4. **Request Timeouts**
   - All `requests.get()`, `requests.post()`, etc. calls identified
   - Explicit `timeout=` parameter added to all request calls
   - Timeout values appropriate for operation type (data fetch, API call, etc.)
   - False-positive bandit warnings annotated with `# nosec B113` and justification

### Testing Infrastructure Requirements

5. **Pytest Markers**
   - `pyproject.toml` → [tool.pytest.ini_options].markers includes `memory: memory profiling benchmarks`
   - `pyproject.toml` → [tool.pytest.ini_options].markers includes `api_integration: marks tests requiring external API integration`
   - `pyproject.toml` → [tool.pytest.ini_options].markers includes `property: property-based tests using hypothesis`
   - Existing markers documented: `live`, `ib_integration`
   - Marker usage documented in test suite README or contributing guide

6. **Test Extras Installation**
   - `pyproject.toml` [project.optional-dependencies].test includes all required extras
   - Required extras confirmed: pytest, pytest-cov, freezegun, responses, hypothesis
   - Installation command documented: `uv sync -E test`
   - CI configuration uses: `uv sync -E test` before pytest execution

7. **Coverage Measurement**
   - Pytest runs without marker errors: `pytest -m "not memory and not api_integration and not live and not ib_integration"`
   - Coverage report generated: `--cov=rustybt --cov-report=term`
   - Core modules achieve ≥90% coverage per [tool.coverage.report].fail_under
   - Financial modules (rustybt/finance/*, rustybt/analytics/*) achieve ≥95% coverage
   - Coverage report saved for CI/CD artifact archiving

### Property-Based Testing Requirements

8. **Hypothesis Framework Installation**
   - Update `pyproject.toml` → `[project.optional-dependencies].test` to include `"hypothesis>=6.0"`
   - Run `uv sync -E test` to install hypothesis
   - Verify installation: `python -c "import hypothesis; print(hypothesis.__version__)"`
   - Document hypothesis version in test dependencies

9. **Decimal Arithmetic Property Tests**
   - Create test file: `tests/finance/test_decimal_properties.py`
   - Implement property tests with 1000+ examples per test:
     - Commutativity test: `a + b == b + a` for addition/multiplication
     - Associativity test: `(a + b) + c == a + (b + c)` for addition/multiplication
     - Identity test: `a + 0 == a`, `a * 1 == a`
     - Precision test: `Decimal("0.1") + Decimal("0.2") == Decimal("0.3")` (vs. float failure)
     - Division by zero test: Verify `ZeroDivisionError` raised
     - Distributivity test: `a * (b + c) == (a * b) + (a * c)`
     - Inverse operations: `(a + b) - b == a`, `(a * b) / b == a` (when b != 0)
   - Each test uses `@settings(max_examples=1000)` annotation
   - Use appropriate strategies: `st.decimals(min_value, max_value)` with financial ranges

10. **Hypothesis Configuration**
    - Create `.hypothesis/` directory for example database
    - Add hypothesis profile to `pyproject.toml`:
      ```toml
      [tool.hypothesis]
      database_file = ".hypothesis/examples.db"

      [tool.hypothesis.profiles]
      default = { max_examples = 1000 }
      ci = { max_examples = 1000, derandomize = true }
      quick = { max_examples = 100 }
      ```
    - CI configuration uses: `pytest -m property --hypothesis-profile=ci`

### Integration Requirements

11. **Existing bundle download functionality continues to work unchanged**
    - `python -m rustybt ingest -b quandl` completes successfully
    - Tarfile extraction produces identical directory structure
    - No performance regression in extraction time
    - Error messages for corrupted archives remain informative

12. **New security validations follow existing pattern**
    - Path traversal validation uses standard library (pathlib.Path.resolve())
    - Security annotations follow existing `# nosec {code}` pattern
    - Threat model documentation added to docs/security-audit.md
    - No new external security dependencies introduced

13. **Integration with existing test suite maintains current behavior**
    - All existing tests pass with new marker configuration
    - Test discovery unchanged (same tests found before/after)
    - Test execution time unchanged (within 5% variance)
    - CI/CD pipeline green with new configuration

### Quality Requirements

14. **Changes are covered by appropriate tests**
    - Tarfile path traversal attack test added (attempts ../, /etc/passwd, etc.)
    - Safe extraction test with known-good archive
    - Exec/eval security tests validate input restrictions
    - SQL injection prevention tests (if applicable to codebase)
    - Request timeout tests verify parameter presence (may be integration test)
    - Property-based tests achieve ≥95% coverage of Decimal arithmetic code paths

15. **Documentation is updated if needed**
    - docs/security-audit.md updated with remediation summary
    - docs/guides/exception-handling.md references tarfile security pattern if applicable
    - Test marker documentation added to CONTRIBUTING.md or test README
    - Threat model for exec/eval documented in code comments and security-audit.md
    - Property-based testing guide added to test documentation

16. **No regression in existing functionality verified**
    - Full test suite passes: `pytest -m "not memory and not api_integration and not live and not ib_integration"`
    - Smoke test: bundle ingestion, backtest execution, report generation
    - Manual verification: paper trading starts successfully
    - CI/CD pipeline green end-to-end

## Tasks / Subtasks

- [ ] **Task 0: Discovery Phase** (AC: 1-4)
  - [ ] Run: `grep -rn "f\".*SELECT\|f\".*INSERT\|f\".*UPDATE\|f\".*DELETE" rustybt/ --include="*.py" > sql-sites.txt`
  - [ ] Run: `grep -rn "requests\\.get\|requests\\.post\|requests\\.put\|requests\\.delete\|requests\\.patch" rustybt/ --include="*.py" > request-sites.txt`
  - [ ] Document findings in implementation plan
  - [ ] Estimated time: 30 minutes

- [ ] **Task 1: Security Fix - Safe Tarfile Extraction** (AC: 1)
  - [ ] Implement path traversal validation in `rustybt/data/bundles/quandl.py:326`
  - [ ] Add security test: `tests/data/bundles/test_quandl_security.py`
  - [ ] Test with malicious tar (path traversal attempts)
  - [ ] Test with legitimate tar (normal extraction)
  - [ ] Verify existing bundle ingestion still works

- [ ] **Task 2: Security Fix - Exec/Eval Safeguards** (AC: 2)
  - [ ] Review and document threat model for `rustybt/algorithm.py`
  - [ ] Add security comments and input validation to `rustybt/utils/run_algo.py`
  - [ ] Replace eval with ast.literal_eval in `rustybt/utils/preprocess.py` where applicable
  - [ ] Add security tests for algorithm loading
  - [ ] Document threat model in docs/security-audit.md

- [ ] **Task 3: Security Fix - SQL Parameterization** (AC: 3)
  - [ ] Review sql-sites.txt from Task 0
  - [ ] Parameterize or whitelist all SQL f-string usage
  - [ ] Add `# nosec` with justification where needed
  - [ ] Add SQL injection prevention tests

- [ ] **Task 4: Security Fix - Request Timeouts** (AC: 4)
  - [ ] Review request-sites.txt from Task 0
  - [ ] Add explicit `timeout=` parameter to all requests.* calls
  - [ ] Choose appropriate timeout values per operation type
  - [ ] Add `# nosec B113` with justification for false positives
  - [ ] Add integration tests for timeout behavior

- [ ] **Task 5: Configure Pytest Markers** (AC: 5)
  - [ ] Add missing markers to `pyproject.toml`: `memory`, `api_integration`, `property`
  - [ ] Verify existing markers: `live`, `ib_integration`
  - [ ] Document marker usage in CONTRIBUTING.md
  - [ ] Test marker filtering: `pytest --markers`

- [ ] **Task 6: Configure Test Extras** (AC: 6)
  - [ ] Verify `[project.optional-dependencies].test` includes: pytest, pytest-cov, freezegun, responses, hypothesis
  - [ ] Add hypothesis>=6.0 to test extras
  - [ ] Update CI configuration to use: `uv sync -E test`
  - [ ] Document installation: `uv sync -E test` in README/CONTRIBUTING.md

- [ ] **Task 7: Restore Coverage Measurement** (AC: 7)
  - [ ] Run: `pytest -m "not memory and not api_integration and not live and not ib_integration" --cov=rustybt --cov-report=term`
  - [ ] Verify coverage ≥90% for core modules
  - [ ] Verify coverage ≥95% for financial modules (finance/*, analytics/*)
  - [ ] Configure CI to generate and save coverage reports

- [ ] **Task 8: Install Hypothesis Framework** (AC: 8)
  - [ ] Update `pyproject.toml` test extras with hypothesis>=6.0
  - [ ] Run: `uv sync -E test`
  - [ ] Verify: `python -c "import hypothesis; print(hypothesis.__version__)"`
  - [ ] Create `.hypothesis/` directory

- [ ] **Task 9: Implement Decimal Property Tests** (AC: 9)
  - [ ] Create `tests/finance/test_decimal_properties.py`
  - [ ] Implement commutativity tests (addition, multiplication)
  - [ ] Implement associativity tests (addition, multiplication)
  - [ ] Implement identity tests (addition, multiplication)
  - [ ] Implement precision test (Decimal vs float)
  - [ ] Implement division by zero test
  - [ ] Implement distributivity test
  - [ ] Implement inverse operations tests
  - [ ] Mark all tests with `@pytest.mark.property`
  - [ ] Configure `@settings(max_examples=1000)` for each test

- [ ] **Task 10: Configure Hypothesis Profiles** (AC: 10)
  - [ ] Add `[tool.hypothesis]` section to `pyproject.toml`
  - [ ] Configure profiles: default, ci, quick
  - [ ] Update CI to use: `pytest -m property --hypothesis-profile=ci`
  - [ ] Test hypothesis configuration locally

- [ ] **Task 11: Integration Testing** (AC: 11-13)
  - [ ] Test bundle ingestion: `python -m rustybt ingest -b quandl`
  - [ ] Run full test suite: `pytest -m "not memory and not api_integration and not live and not ib_integration"`
  - [ ] Verify all existing tests still pass
  - [ ] Verify test discovery unchanged
  - [ ] Measure test execution time variance (< 5%)

- [ ] **Task 12: Documentation Updates** (AC: 15)
  - [ ] Update docs/security-audit.md with remediation summary
  - [ ] Add tarfile security pattern to docs/guides/exception-handling.md (if applicable)
  - [ ] Document test markers in CONTRIBUTING.md
  - [ ] Document threat model for exec/eval in security-audit.md
  - [ ] Add property-based testing guide to test documentation

- [ ] **Task 13: Smoke Tests** (AC: 16)
  - [ ] Run bundle ingestion smoke test
  - [ ] Run backtest execution smoke test
  - [ ] Run report generation smoke test
  - [ ] Verify paper trading starts successfully
  - [ ] Verify CI/CD pipeline green

## Dev Notes

### Architecture Context

**Source:** [docs/architecture/tech-stack.md](../architecture/tech-stack.md)

**Testing Stack:**
- pytest >= 7.2.0 (test framework)
- pytest-cov >= 3.0.0 (coverage reporting)
- pytest-xdist >= 2.5.0 (parallel testing)
- hypothesis >= 6.0 (property-based testing) - NEW for Epic X2
- Security: bandit (SAST), safety (dependency scanning)

**Python Version:** 3.12+ required

**Source:** [docs/architecture/coding-standards.md](../architecture/coding-standards.md)

**Decimal Precision Standards:**
- Import: `from decimal import Decimal, getcontext`
- Set context: `getcontext().prec = 28` (configurable per asset class)
- String construction: `Decimal("42.123")` (never `Decimal(42.123)`)
- Comparison: Use Decimal comparison directly (`a > b`), avoid float conversion

**Error Handling:**
- Use custom exception hierarchy (RustyBTError → BrokerError, etc.)
- Always log exceptions with structlog context

**Source:** [docs/architecture/source-tree.md](../architecture/source-tree.md)

**Relevant Source Locations:**
- Security fixes: `rustybt/data/bundles/quandl.py`, `rustybt/algorithm.py`, `rustybt/utils/run_algo.py`, `rustybt/utils/preprocess.py`
- Test configuration: `pyproject.toml` ([tool.pytest.ini_options], [project.optional-dependencies])
- Test files: `tests/data/bundles/`, `tests/finance/`, `tests/` (general)
- Documentation: `docs/security-audit.md`, `docs/guides/exception-handling.md`, `CONTRIBUTING.md`

### Technical Implementation Guidance

**Security Fix: Safe Tarfile Extraction**
```python
# rustybt/data/bundles/quandl.py:326
from pathlib import Path

base = Path(output_dir).resolve()
for member in tar.getmembers():
    member_path = (base / member.name).resolve()
    if not str(member_path).startswith(str(base)):
        raise ValueError(f"Unsafe tar member path: {member.name}")
tar.extractall(output_dir)
```

**Security Fix: Exec/Eval Documentation**
```python
# Example: rustybt/algorithm.py
# SECURITY: exec() used for trusted user-provided algorithm code only.
# Threat model: Users have full system access; this is not a sandboxed environment.
# Mitigation: Validate code source, consider AST validation for untrusted sources.
exec(algorithm_code, namespace)  # nosec B102 - trusted user code
```

**Security Fix: SQL Parameterization**
```python
# Bad: f"SELECT * FROM {table_name} WHERE id = {user_id}"
# Good: text("SELECT * FROM :table WHERE id = :id").bindparams(table=table_name, id=user_id)
# Or whitelist: assert table_name in ALLOWED_TABLES
```

**Security Fix: Request Timeouts**
```python
# Before: requests.get(url)
# After:  requests.get(url, timeout=30)  # 30s for data APIs, adjust as needed
```

**Test Configuration: Pytest Markers**
```toml
# pyproject.toml
[tool.pytest.ini_options]
markers = [
    "memory: memory profiling benchmarks",
    "api_integration: marks tests requiring external API integration",
    "property: property-based tests using hypothesis",
    "live: marks tests requiring live broker connections",
    "ib_integration: marks tests requiring Interactive Brokers connection",
]
```

**Test Configuration: Hypothesis**
```toml
# pyproject.toml
[tool.hypothesis]
database_file = ".hypothesis/examples.db"

[tool.hypothesis.profiles]
default = { max_examples = 1000 }
ci = { max_examples = 1000, derandomize = true }
quick = { max_examples = 100 }
```

**Property-Based Test Example:**
```python
# tests/finance/test_decimal_properties.py
from hypothesis import given, strategies as st, settings
from decimal import Decimal
import pytest

@pytest.mark.property
@given(
    a=st.decimals(min_value=Decimal("0.01"), max_value=Decimal("1000000")),
    b=st.decimals(min_value=Decimal("0.01"), max_value=Decimal("1000000"))
)
@settings(max_examples=1000)
def test_decimal_addition_commutative(a, b):
    """Verify Decimal addition is commutative: a + b == b + a."""
    assert a + b == b + a
```

### Testing

**Source:** [docs/architecture/coding-standards.md](../architecture/coding-standards.md) (lines 433-483: Testing Standards)

**Test File Locations:**
- Security tests: `tests/data/bundles/test_quandl_security.py`, `tests/test_algorithm_security.py`
- Property tests: `tests/finance/test_decimal_properties.py`
- Integration tests: `tests/integration/test_bundle_ingestion.py`, `tests/integration/test_request_timeouts.py`

**Test Standards:**
- All public functions require unit tests
- Coverage targets: ≥90% for core modules, ≥95% for financial modules
- Use pytest fixtures for test data setup
- Mock external dependencies (broker APIs, network calls)
- Property-based tests: 1000+ examples per test with hypothesis

**Testing Frameworks:**
- pytest for unit/integration tests
- pytest-cov for coverage measurement
- hypothesis for property-based testing
- freezegun for time-dependent tests
- responses for HTTP mocking

**CI Test Command:**
```bash
# Unit tests with coverage
pytest -m "not memory and not api_integration and not live and not ib_integration" \
  --cov=rustybt --cov-report=term --cov-report=html

# Property-based tests (CI profile)
pytest -m property --hypothesis-profile=ci
```

## Change Log

| Date       | Version | Description                          | Author        |
|------------|---------|--------------------------------------|---------------|
| 2025-10-11 | 1.0     | Initial story creation               | PM/PO         |
| 2025-10-11 | 2.0     | Consolidated X2.1 + X2.1B content    | SM (Bob)      |

## Dev Agent Record

*This section will be populated by the development agent during implementation.*

### Agent Model Used

*To be filled by dev agent*

### Debug Log References

*To be filled by dev agent*

### Completion Notes List

*To be filled by dev agent*

### File List

*To be filled by dev agent*

## QA Results

*This section will be populated by the QA agent after story completion.*
