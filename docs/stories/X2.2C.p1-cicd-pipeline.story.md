# Story X2.2C: CI/CD Pipeline

## Status
Draft

## Story

**As a** Software Engineer maintaining RustyBT's code quality and deployment infrastructure,
**I want** a comprehensive CI/CD pipeline with automated quality gates, security scanning, and performance regression testing,
**so that** all code changes are validated against strict quality standards before merge, ensuring production-ready code quality.

## Acceptance Criteria

### Phase 1: Code Quality CI Job

1. **Code Quality Workflow Created**
   - Create `.github/workflows/code-quality.yml` with all linting/formatting checks
   - BLOCKING: `ruff check .` must pass with 0 errors
   - BLOCKING: `black --check .` must pass with 0 files to reformat
   - BLOCKING: `python3 -m mypy` must pass for scoped modules (Epic 8 modules: analytics/*, utils/secure_pickle.py, utils/logging.py, utils/error_handling.py, exceptions.py)
   - BLOCKING: `python scripts/check_complexity.py` must pass (McCabe ≤10 for all functions)
   - Job runs on push and pull_request events
   - Job configured with uv for fast dependency installation

2. **Branch Protection Rules Configured**
   - Configure branch protection for `main` branch
   - Require status checks to pass before merging
   - Include code-quality job as required check
   - Enforce restrictions on administrators
   - Require linear history (no merge commits)

### Phase 2: Zero-Mock Enforcement CI Job

3. **Zero-Mock Enforcement Workflow Created**
   - Create `.github/workflows/zero-mock-enforcement.yml` with all detection scripts
   - BLOCKING: `python scripts/detect_mocks.py --strict` must pass (0 mock patterns detected)
   - BLOCKING: `python scripts/detect_hardcoded_values.py --fail-on-found` must pass (0 hardcoded values)
   - BLOCKING: `python scripts/verify_validations.py --ensure-real-checks` must pass (all validators functional)
   - BLOCKING: `python scripts/test_unique_results.py` must pass (unique outputs verified)
   - Job runs on push and pull_request events
   - Job depends on zero-mock detection scripts from Story X2.2B

4. **Zero-Mock Branch Protection**
   - Add zero-mock-enforcement job to required status checks
   - Configure failure handling to block merges on any violation
   - Add clear error messages when zero-mock checks fail

### Phase 3: Security CI Job

5. **Security Workflow Created**
   - Create `.github/workflows/security.yml` with security scanning tools
   - BLOCKING: `bandit -r rustybt -ll -i` must pass (0 High/Critical severity issues)
   - BLOCKING: `truffleHog --regex --entropy=False .` must pass (0 secrets detected)
   - BLOCKING: `detect-secrets scan` must pass (0 secrets detected)
   - Job runs on push and pull_request events
   - Upload security scan results as artifacts

6. **Security Branch Protection**
   - Add security job to required status checks
   - Configure failure handling to block merges on any security violation
   - Document security scan results location in CI/CD docs

### Phase 4: Testing CI Job

7. **Testing Workflow Created**
   - Create `.github/workflows/testing.yml` with comprehensive test suite
   - Run unit tests: `pytest -m "not memory and not api_integration and not live and not ib_integration" --cov=rustybt --cov-report=term --cov-report=html`
   - BLOCKING: Coverage thresholds enforced (Core modules ≥90%, financial modules ≥95%)
   - Run property-based tests: `pytest -m "property" --hypothesis-profile=ci` (1000+ examples per test)
   - Upload coverage reports as artifacts (HTML and XML formats)
   - Job runs on push and pull_request events

8. **Testing Branch Protection**
   - Add testing job to required status checks
   - Configure coverage enforcement as blocking check
   - Document coverage requirements in CONTRIBUTING.md

### Phase 5: Dependency Security CI Job (Weekly)

9. **Dependency Security Workflow Created**
   - Create `.github/workflows/dependency-security.yml` with scheduled security scans
   - Configure schedule: weekly (Sunday at 00:00 UTC)
   - Run `safety scan --json > safety-report.json`
   - Run `pip-audit --format json > pip-audit-report.json`
   - Run `python scripts/check_licenses.py` to verify no GPL-licensed dependencies
   - Upload security reports as artifacts (JSON format)
   - Create GitHub issues for new vulnerabilities detected
   - NON-BLOCKING: Does not block merges, creates issues for remediation

10. **Dependency Security Monitoring**
    - Configure GitHub Actions to create issues for vulnerabilities
    - Add issue template for vulnerability remediation
    - Document vulnerability tracking process in docs/security-audit.md
    - Configure notifications for security scan failures

### Phase 6: Performance Regression CI Job

11. **Performance Regression Workflow Created**
    - Create `.github/workflows/performance.yml` for performance testing
    - Configure trigger: on push to main branch only (after merge)
    - Run benchmarks: `python -m rustybt benchmark --suite backtest --output benchmark-results.json`
    - Run regression check: `python scripts/check_performance_regression.py --threshold=0.20 --baseline=benchmark-baseline.json`
    - Fail if performance degrades >20% from baseline
    - Upload benchmark results as artifacts
    - NON-BLOCKING: Creates issues for regressions but doesn't block merges

12. **Performance Regression Monitoring**
    - Store baseline performance metrics in repository
    - Configure GitHub Actions to create issues for performance regressions
    - Add issue template for performance regression remediation
    - Document performance baseline update process

### Integration Requirements

13. **CI/CD Pipeline Integration**
    - All 6 workflows integrated and operational
    - Parallel execution where possible (code-quality, zero-mock, security can run in parallel)
    - Total CI/CD runtime < 12 minutes for typical PR
    - Clear error messages when checks fail
    - All workflows use uv for dependency installation (10-100x faster than pip)

14. **Developer Experience**
    - Pre-commit hooks mirror CI/CD checks (fast local validation)
    - CI/CD failures provide clear actionable error messages
    - Documentation guides developers through fixing common CI/CD failures
    - IDE integrations work with CI/CD tools (ruff, black, mypy)

15. **PR Template Integration**
    - Create `.github/pull_request_template.md` with comprehensive checklist
    - Checklist includes: all tests pass, zero-mock checks pass, security scans pass, coverage requirements met, documentation updated, CHANGELOG.md entry added
    - Link to CI/CD pipeline documentation
    - Require checklist completion for PR approval

### Quality Requirements

16. **CI/CD Pipeline Tested**
    - All workflows tested with sample PRs
    - Branch protection rules verified to block merges on failures
    - Parallel execution verified for independent jobs
    - Total runtime verified < 12 minutes
    - Error messages verified to be clear and actionable

17. **Documentation Complete**
    - Create `docs/development/ci-cd-pipeline.md` documenting all CI/CD jobs
    - Document workflow triggers, checks, and failure handling
    - Document branch protection configuration
    - Document how to debug CI/CD failures
    - Update CONTRIBUTING.md with CI/CD setup and troubleshooting

18. **No Regression Verified**
    - Existing functionality unchanged
    - Test suite passes with new CI/CD pipeline
    - Pre-commit hooks work correctly
    - CI/CD pipeline green end-to-end

## Tasks / Subtasks

- [ ] **Task 1: Code Quality CI Job** (AC: 1-2)
  - [ ] Create `.github/workflows/code-quality.yml` with ruff, black, mypy, complexity checks
  - [ ] Test workflow with sample PR
  - [ ] Configure branch protection for main branch
  - [ ] Add code-quality job to required status checks
  - [ ] Verify workflow blocks merges on failures

- [ ] **Task 2: Zero-Mock Enforcement CI Job** (AC: 3-4)
  - [ ] Create `.github/workflows/zero-mock-enforcement.yml` with all detection scripts
  - [ ] Test workflow with sample PR
  - [ ] Add zero-mock-enforcement job to required status checks
  - [ ] Verify workflow blocks merges on violations

- [ ] **Task 3: Security CI Job** (AC: 5-6)
  - [ ] Create `.github/workflows/security.yml` with bandit, truffleHog, detect-secrets
  - [ ] Test workflow with sample PR
  - [ ] Add security job to required status checks
  - [ ] Upload security scan results as artifacts
  - [ ] Verify workflow blocks merges on security violations

- [ ] **Task 4: Testing CI Job** (AC: 7-8)
  - [ ] Create `.github/workflows/testing.yml` with unit and property-based tests
  - [ ] Configure coverage thresholds (core ≥90%, financial ≥95%)
  - [ ] Test workflow with sample PR
  - [ ] Upload coverage reports as artifacts (HTML, XML)
  - [ ] Add testing job to required status checks
  - [ ] Verify workflow blocks merges on coverage failures

- [ ] **Task 5: Dependency Security CI Job** (AC: 9-10)
  - [ ] Create `.github/workflows/dependency-security.yml` scheduled weekly
  - [ ] Add safety scan, pip-audit, license check
  - [ ] Upload security reports as artifacts
  - [ ] Configure GitHub Actions to create issues for vulnerabilities
  - [ ] Create issue template for vulnerability remediation
  - [ ] Test workflow manually
  - [ ] Document vulnerability tracking in docs/security-audit.md

- [ ] **Task 6: Performance Regression CI Job** (AC: 11-12)
  - [ ] Create `.github/workflows/performance.yml` triggered on main branch
  - [ ] Add benchmark suite and regression check (20% threshold)
  - [ ] Upload benchmark results as artifacts
  - [ ] Configure GitHub Actions to create issues for regressions
  - [ ] Create issue template for performance regression remediation
  - [ ] Test workflow manually
  - [ ] Document performance baseline update process

- [ ] **Task 7: PR Template Creation** (AC: 15)
  - [ ] Create `.github/pull_request_template.md` with comprehensive checklist
  - [ ] Include links to CI/CD pipeline documentation
  - [ ] Test PR template with sample PR

- [ ] **Task 8: CI/CD Pipeline Testing** (AC: 13-14, 16)
  - [ ] Test all workflows with sample PRs
  - [ ] Verify parallel execution of independent jobs
  - [ ] Measure total CI/CD runtime (verify < 12 minutes)
  - [ ] Verify branch protection blocks merges on failures
  - [ ] Verify error messages are clear and actionable
  - [ ] Test developer experience (pre-commit hooks, IDE integrations)

- [ ] **Task 9: Documentation** (AC: 17)
  - [ ] Create docs/development/ci-cd-pipeline.md
  - [ ] Document all 6 CI/CD workflows (triggers, checks, failure handling)
  - [ ] Document branch protection configuration
  - [ ] Document CI/CD failure debugging guide
  - [ ] Update CONTRIBUTING.md with CI/CD setup and troubleshooting
  - [ ] Update README.md with CI/CD status badges

- [ ] **Task 10: Final Validation** (AC: 18)
  - [ ] Run full test suite with CI/CD pipeline
  - [ ] Verify existing functionality unchanged
  - [ ] Verify CI/CD pipeline green end-to-end
  - [ ] Create summary report of CI/CD pipeline implementation

## Dev Notes

### Architecture Context

**Source:** [docs/architecture/tech-stack.md](../architecture/tech-stack.md)

**CI/CD Infrastructure:**
- GitHub Actions (workflow automation)
- uv 0.5.x+ (fast dependency installation, 10-100x faster than pip)
- Python 3.12+ (runtime environment)

**Code Quality Tools:**
- ruff >= 0.11.12 (fast linter)
- black 24.1+ (code formatter)
- mypy >= 1.10.0 (static type checker)
- bandit (SAST security scanning)
- truffleHog (secrets detection)
- detect-secrets (secrets detection)
- safety (dependency vulnerability scanning)
- pip-audit (dependency vulnerability scanning)

**Testing Tools:**
- pytest >= 8.0 (test framework)
- pytest-cov >= 5.0 (coverage reporting)
- hypothesis >= 6.0 (property-based testing)

**Source:** [docs/architecture/coding-standards.md](../architecture/coding-standards.md)

**Zero-Mock Enforcement (from Story X2.2B):**
- Pre-commit hook scripts must be available: `detect_mocks.py`, `detect_hardcoded_values.py`, `verify_validations.py`, `test_unique_results.py`
- All scripts must support `--strict` and `--fail-on-found` flags
- Zero-mock checks are BLOCKING in CI/CD

**Coverage Requirements:**
- Core modules: ≥90%
- Financial modules (finance/*, analytics/*): ≥95%
- Property-based tests: 1000+ examples per test (hypothesis profile=ci)

**Performance Regression:**
- Baseline stored in `benchmark-baseline.json`
- Threshold: 20% degradation triggers failure
- Only runs on main branch after merge (post-merge validation)

### Technical Implementation Guidance

**Complete CI/CD Workflow Examples:**

**1. Code Quality Workflow:**
```yaml
# .github/workflows/code-quality.yml
name: Code Quality

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  lint-format-type:
    name: Lint, Format, Type Check
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup uv
        uses: astral-sh/setup-uv@v3
        with:
          version: "0.5.x"

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install dependencies
        run: |
          uv sync -E dev -E test

      - name: Run ruff linter (BLOCKING)
        run: |
          uv run ruff check .
        continue-on-error: false

      - name: Run black formatter check (BLOCKING)
        run: |
          uv run black --check .
        continue-on-error: false

      - name: Run mypy type checker (BLOCKING)
        run: |
          uv run python3 -m mypy
        continue-on-error: false

      - name: Check code complexity (BLOCKING)
        run: |
          uv run python scripts/check_complexity.py
        continue-on-error: false

      - name: Upload lint results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: lint-results
          path: |
            .ruff_cache/
            mypy-report/
```

**2. Zero-Mock Enforcement Workflow:**
```yaml
# .github/workflows/zero-mock-enforcement.yml
name: Zero-Mock Enforcement

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  mock-detection:
    name: Detect Mock Patterns
    runs-on: ubuntu-latest
    timeout-minutes: 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup uv
        uses: astral-sh/setup-uv@v3
        with:
          version: "0.5.x"

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install dependencies
        run: |
          uv sync -E dev -E test

      - name: Detect mock patterns (BLOCKING)
        run: |
          uv run python scripts/detect_mocks.py --strict
          if [ $? -ne 0 ]; then
            echo "::error::Mock patterns detected! Real implementations required."
            exit 1
          fi

      - name: Detect hardcoded values (BLOCKING)
        run: |
          uv run python scripts/detect_hardcoded_values.py --fail-on-found
          if [ $? -ne 0 ]; then
            echo "::error::Hardcoded return values detected! Use real calculations."
            exit 1
          fi

      - name: Verify validations work (BLOCKING)
        run: |
          uv run python scripts/verify_validations.py --ensure-real-checks
          if [ $? -ne 0 ]; then
            echo "::error::Validation functions must reject invalid data!"
            exit 1
          fi

      - name: Test result uniqueness (BLOCKING)
        run: |
          uv run python scripts/test_unique_results.py
          if [ $? -ne 0 ]; then
            echo "::error::Functions must produce unique outputs for different inputs!"
            exit 1
          fi

      - name: Upload detection results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: zero-mock-results
          path: |
            mock-detection-report.json
            hardcoded-values-report.json
```

**3. Security Workflow:**
```yaml
# .github/workflows/security.yml
name: Security Scanning

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for truffleHog

      - name: Setup uv
        uses: astral-sh/setup-uv@v3
        with:
          version: "0.5.x"

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install dependencies
        run: |
          uv sync -E dev -E test

      - name: Install security tools
        run: |
          uv pip install bandit truffleHog detect-secrets

      - name: Run bandit SAST scan (BLOCKING)
        run: |
          uv run bandit -r rustybt -ll -i
          if [ $? -ne 0 ]; then
            echo "::error::High/Critical security issues detected!"
            exit 1
          fi

      - name: Run truffleHog secrets scan (BLOCKING)
        run: |
          uv run truffleHog --regex --entropy=False .
          if [ $? -ne 0 ]; then
            echo "::error::Secrets detected in codebase!"
            exit 1
          fi

      - name: Run detect-secrets scan (BLOCKING)
        run: |
          uv run detect-secrets scan --baseline .secrets.baseline
          if [ $? -ne 0 ]; then
            echo "::error::New secrets detected!"
            exit 1
          fi

      - name: Upload security reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: security-scan-results
          path: |
            bandit-report.json
            truffleHog-report.json
            detect-secrets-report.json
```

**4. Testing Workflow:**
```yaml
# .github/workflows/testing.yml
name: Testing

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  unit-tests:
    name: Unit Tests with Coverage
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup uv
        uses: astral-sh/setup-uv@v3
        with:
          version: "0.5.x"

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install dependencies
        run: |
          uv sync -E dev -E test

      - name: Run unit tests with coverage
        run: |
          uv run pytest -m "not memory and not api_integration and not live and not ib_integration" \
            --cov=rustybt \
            --cov-report=term \
            --cov-report=html \
            --cov-report=xml \
            --cov-fail-under=90
        continue-on-error: false

      - name: Upload coverage reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-reports
          path: |
            htmlcov/
            coverage.xml

      - name: Upload coverage to Codecov
        if: always()
        uses: codecov/codecov-action@v4
        with:
          file: ./coverage.xml
          flags: unittests
          name: codecov-rustybt

  property-tests:
    name: Property-Based Tests
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup uv
        uses: astral-sh/setup-uv@v3
        with:
          version: "0.5.x"

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install dependencies
        run: |
          uv sync -E dev -E test

      - name: Run property-based tests
        run: |
          uv run pytest -m "property" --hypothesis-profile=ci
        continue-on-error: false

      - name: Upload hypothesis results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: hypothesis-results
          path: .hypothesis/
```

**5. Dependency Security Workflow (Weekly):**
```yaml
# .github/workflows/dependency-security.yml
name: Dependency Security (Weekly)

on:
  schedule:
    - cron: '0 0 * * 0'  # Sunday at 00:00 UTC
  workflow_dispatch:  # Manual trigger

jobs:
  dependency-scan:
    name: Scan Dependencies for Vulnerabilities
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup uv
        uses: astral-sh/setup-uv@v3
        with:
          version: "0.5.x"

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install dependencies
        run: |
          uv sync -E dev -E test

      - name: Install security tools
        run: |
          uv pip install safety pip-audit

      - name: Run safety scan
        run: |
          uv run safety scan --json > safety-report.json || true
        continue-on-error: true

      - name: Run pip-audit scan
        run: |
          uv run pip-audit --format json > pip-audit-report.json || true
        continue-on-error: true

      - name: Check licenses
        run: |
          uv run python scripts/check_licenses.py
          if [ $? -ne 0 ]; then
            echo "::warning::GPL-licensed dependencies detected!"
          fi
        continue-on-error: true

      - name: Upload security reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: dependency-security-reports
          path: |
            safety-report.json
            pip-audit-report.json
            license-report.json

      - name: Create issue for vulnerabilities
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const safetyReport = JSON.parse(fs.readFileSync('safety-report.json', 'utf8'));
            const pipAuditReport = JSON.parse(fs.readFileSync('pip-audit-report.json', 'utf8'));

            const vulnerabilities = safetyReport.vulnerabilities || [];
            const pipVulns = pipAuditReport.vulnerabilities || [];

            if (vulnerabilities.length > 0 || pipVulns.length > 0) {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `Weekly Dependency Security Scan: ${vulnerabilities.length + pipVulns.length} vulnerabilities detected`,
                body: `## Dependency Security Scan Results\n\n**Date:** ${new Date().toISOString()}\n\n**Vulnerabilities Found:** ${vulnerabilities.length + pipVulns.length}\n\nSee workflow artifacts for detailed reports.`,
                labels: ['security', 'dependencies']
              });
            }
```

**6. Performance Regression Workflow:**
```yaml
# .github/workflows/performance.yml
name: Performance Regression (Main Branch)

on:
  push:
    branches: [main]
  workflow_dispatch:  # Manual trigger

jobs:
  performance-benchmark:
    name: Run Performance Benchmarks
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup uv
        uses: astral-sh/setup-uv@v3
        with:
          version: "0.5.x"

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install dependencies
        run: |
          uv sync -E dev -E test

      - name: Run benchmark suite
        run: |
          uv run python -m rustybt benchmark --suite backtest --output benchmark-results.json
        continue-on-error: true

      - name: Check performance regression
        run: |
          uv run python scripts/check_performance_regression.py \
            --threshold=0.20 \
            --baseline=benchmark-baseline.json \
            --current=benchmark-results.json
        continue-on-error: true

      - name: Upload benchmark results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: benchmark-results
          path: |
            benchmark-results.json
            benchmark-comparison.html

      - name: Create issue for performance regression
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const results = JSON.parse(fs.readFileSync('benchmark-results.json', 'utf8'));

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `Performance Regression Detected: >20% degradation`,
              body: `## Performance Regression\n\n**Date:** ${new Date().toISOString()}\n\n**Threshold:** 20%\n\nSee workflow artifacts for detailed benchmark comparison.`,
              labels: ['performance', 'regression']
            });
```

**Branch Protection Configuration:**
```bash
# Configure branch protection via GitHub CLI (gh)
# Run after workflows are created and tested

gh api repos/:owner/:repo/branches/main/protection \
  --method PUT \
  --field required_status_checks[strict]=true \
  --field required_status_checks[contexts][]=lint-format-type \
  --field required_status_checks[contexts][]=mock-detection \
  --field required_status_checks[contexts][]=security-scan \
  --field required_status_checks[contexts][]=unit-tests \
  --field required_status_checks[contexts][]=property-tests \
  --field enforce_admins=true \
  --field required_linear_history=true \
  --field allow_force_pushes=false \
  --field allow_deletions=false
```

**PR Template:**
```markdown
# .github/pull_request_template.md

## Description
<!-- Provide a clear description of the changes in this PR -->

## Related Story/Issue
<!-- Link to story file or GitHub issue -->
- Story: docs/stories/X.X-story-name.story.md
- Issue: #XXX

## Type of Change
- [ ] Bug fix (non-breaking change that fixes an issue)
- [ ] New feature (non-breaking change that adds functionality)
- [ ] Breaking change (fix or feature that would cause existing functionality to not work as expected)
- [ ] Documentation update
- [ ] Refactoring (no functional changes)
- [ ] Performance improvement

## Pre-Submission Checklist

### Code Quality
- [ ] All tests pass locally (`pytest -m "not memory and not api_integration and not live and not ib_integration"`)
- [ ] Code coverage ≥90% for core modules, ≥95% for financial modules
- [ ] Ruff linter passes (`ruff check .`)
- [ ] Black formatter passes (`black --check .`)
- [ ] Mypy type checker passes (`python3 -m mypy`)
- [ ] Code complexity ≤10 (McCabe)

### Zero-Mock Enforcement
- [ ] Zero-mock detection passes (`python scripts/detect_mocks.py --strict`)
- [ ] No hardcoded values (`python scripts/detect_hardcoded_values.py --fail-on-found`)
- [ ] All validations functional (`python scripts/verify_validations.py --ensure-real-checks`)
- [ ] Unique results verified (`python scripts/test_unique_results.py`)

### Security
- [ ] No secrets committed (checked with `detect-secrets scan`)
- [ ] Security scan passes (`bandit -r rustybt -ll -i`)
- [ ] No new High/Critical vulnerabilities introduced

### Documentation
- [ ] Public APIs have docstrings (Google-style)
- [ ] CHANGELOG.md updated with changes
- [ ] README.md updated if needed
- [ ] Architecture docs updated if needed

### Testing
- [ ] Unit tests added/updated for new functionality
- [ ] Property-based tests added for financial calculations
- [ ] Integration tests added if applicable
- [ ] All test markers correctly applied

## CI/CD Status
<!-- CI/CD checks will be listed here automatically -->
All required CI/CD checks must pass before merge.

See [CI/CD Pipeline Documentation](../docs/development/ci-cd-pipeline.md) for troubleshooting.

## Reviewer Notes
<!-- Any additional context for reviewers -->
```

**CI/CD Pipeline Documentation Outline:**
```markdown
# docs/development/ci-cd-pipeline.md

# CI/CD Pipeline

## Overview
RustyBT uses GitHub Actions for CI/CD automation with 6 comprehensive workflows.

## Workflows

### 1. Code Quality (BLOCKING)
- **Trigger:** Push, Pull Request
- **Duration:** ~5 minutes
- **Checks:**
  - Ruff linter
  - Black formatter
  - Mypy type checker
  - Code complexity (McCabe ≤10)

### 2. Zero-Mock Enforcement (BLOCKING)
- **Trigger:** Push, Pull Request
- **Duration:** ~3 minutes
- **Checks:**
  - Mock pattern detection
  - Hardcoded value detection
  - Validation function verification
  - Result uniqueness testing

### 3. Security (BLOCKING)
- **Trigger:** Push, Pull Request
- **Duration:** ~5 minutes
- **Checks:**
  - Bandit SAST scan
  - TruffleHog secrets detection
  - detect-secrets scan

### 4. Testing (BLOCKING)
- **Trigger:** Push, Pull Request
- **Duration:** ~10 minutes
- **Checks:**
  - Unit tests with coverage
  - Property-based tests (1000+ examples)
  - Coverage thresholds (core ≥90%, financial ≥95%)

### 5. Dependency Security (NON-BLOCKING, Weekly)
- **Trigger:** Scheduled (Sunday 00:00 UTC), Manual
- **Duration:** ~5 minutes
- **Checks:**
  - Safety vulnerability scan
  - pip-audit vulnerability scan
  - License compliance check

### 6. Performance Regression (NON-BLOCKING, Main Branch Only)
- **Trigger:** Push to main, Manual
- **Duration:** ~20 minutes
- **Checks:**
  - Benchmark suite execution
  - Performance regression check (20% threshold)

## Branch Protection
- **Main branch protected**
- **Required checks:** Code Quality, Zero-Mock, Security, Testing
- **Linear history enforced**
- **Force pushes disabled**

## Debugging CI/CD Failures
[Detailed troubleshooting guide...]

## Local Pre-Commit Setup
[Setup instructions...]
```

### Testing

**CI/CD Workflow Testing Commands:**
```bash
# Test code quality workflow locally
ruff check .
black --check .
python3 -m mypy
python scripts/check_complexity.py

# Test zero-mock enforcement workflow locally
python scripts/detect_mocks.py --strict
python scripts/detect_hardcoded_values.py --fail-on-found
python scripts/verify_validations.py --ensure-real-checks
python scripts/test_unique_results.py

# Test security workflow locally
bandit -r rustybt -ll -i
truffleHog --regex --entropy=False .
detect-secrets scan

# Test testing workflow locally
pytest -m "not memory and not api_integration and not live and not ib_integration" \
  --cov=rustybt --cov-report=term --cov-report=html --cov-fail-under=90
pytest -m "property" --hypothesis-profile=ci

# Test dependency security workflow locally
safety scan --json
pip-audit --format json
python scripts/check_licenses.py

# Test performance workflow locally
python -m rustybt benchmark --suite backtest --output benchmark-results.json
python scripts/check_performance_regression.py --threshold=0.20 --baseline=benchmark-baseline.json
```

**Branch Protection Testing:**
```bash
# Test branch protection with GitHub CLI
gh pr create --title "Test PR" --body "Testing CI/CD pipeline"
# Verify required checks appear
gh pr checks

# Attempt merge before checks pass (should fail)
gh pr merge --auto

# Wait for checks to pass
gh pr checks --watch

# Merge after checks pass
gh pr merge --squash
```

## Change Log

| Date       | Version | Description                            | Author       |
|------------|---------|----------------------------------------|--------------|
| 2025-10-11 | 1.0     | Split from X2.2 per Epic X2 structure  | PO (Sarah)   |

## Dev Agent Record

*This section will be populated by the development agent during implementation.*

### Agent Model Used

*To be filled by dev agent*

### Debug Log References

*To be filled by dev agent*

### Completion Notes List

*To be filled by dev agent*

### File List

*To be filled by dev agent*

## QA Results

*This section will be populated by the QA agent after story completion.*
