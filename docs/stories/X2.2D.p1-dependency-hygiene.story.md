# Story X2.2D: Dependency Hygiene

## Status
Draft

## Story

**As a** Software Engineer maintaining RustyBT's dependency security and supply chain integrity,
**I want** clean production/dev dependency separation with comprehensive vulnerability remediation and license compliance verification,
**so that** the production environment has minimal attack surface, zero High/Critical vulnerabilities, and all dependencies are legally compliant.

## Acceptance Criteria

### Phase 1: Production vs Dev Dependency Split

1. **Dev Dependencies Extra Created**
   - Create `[project.optional-dependencies].dev` extra in pyproject.toml
   - Move Jupyter/notebook tools to dev extra: `jupyter`, `jupyterlab`, `notebook`
   - Move type stubs to dev extra: `pandas-stubs`, `types-networkx`, `types-requests`, `types-PyYAML`
   - Move heavy dev tools to dev extra: `streamlit` (if used in examples/)
   - Move torch to dev extra if present (used only in examples)
   - Verify core dependencies remain in `[project.dependencies]`

2. **Production Dependency Count Reduced**
   - Production dependencies reduced from ~50+ to ~40 (dev moved to extras)
   - Verify all runtime-required dependencies remain in production
   - Verify no dev-only dependencies in production
   - Document installation commands: `uv sync` (prod) vs. `uv sync -E dev -E test` (dev)

3. **Installation Documentation Updated**
   - Update README.md with production installation: `uv sync`
   - Update README.md with development installation: `uv sync -E dev -E test`
   - Update CONTRIBUTING.md with dev setup instructions
   - Document when to use production vs. dev installation

### Phase 2: Vulnerability Remediation

4. **Vulnerability Assessment Completed**
   - Run `safety scan` to identify all vulnerable packages
   - Run `pip-audit` to cross-validate vulnerability findings
   - Categorize vulnerabilities by severity: Critical, High, Medium, Low
   - Document all 44 vulnerabilities with package names, versions, and CVE IDs
   - Prioritize High/Critical vulnerabilities for immediate remediation

5. **High/Critical Vulnerabilities Remediated**
   - Upgrade all packages with High/Critical vulnerabilities to patched versions
   - Test suite passes with upgraded packages (`uv sync -E test && pytest`)
   - Verify no breaking changes from upgrades
   - Pin packages with known vulnerabilities if upgrade breaks compatibility
   - Document pinned packages with justification and mitigation plan
   - High/Critical vulnerabilities in production: 44 → 0

6. **Medium/Low Vulnerabilities Triaged**
   - Upgrade Medium/Low vulnerable packages where possible
   - Document unresolved Medium/Low vulnerabilities with justification
   - Create tracking issues for unresolved vulnerabilities
   - Document mitigation strategies for unresolved vulnerabilities
   - Verify production extras exclude dev-only vulnerable packages

### Phase 3: Lockfile Verification & License Compliance

7. **Lockfile Updated and Verified**
   - Run `uv lock` to update lockfile with new dependency versions
   - Verify `uv.lock` includes all production and optional dependencies
   - Run test suite with new lockfile: `uv sync -E test && pytest`
   - Verify no dependency resolution conflicts
   - Verify lockfile determinism (repeated `uv lock` produces same result)
   - Commit updated `uv.lock` with story changes

8. **License Compliance Script Created**
   - Create `scripts/check_licenses.py` to scan dependency licenses
   - Script extracts license information from package metadata
   - Script flags GPL-licensed dependencies (Apache 2.0/MIT required)
   - Script outputs JSON report with all dependency licenses
   - Script exits with code 1 if GPL dependencies detected
   - Script supports `--fail-on-gpl` flag for CI/CD integration

9. **License Compliance Verified**
   - Run `python scripts/check_licenses.py` → 0 GPL dependencies detected
   - Verify all production dependencies use Apache 2.0, MIT, BSD, or compatible licenses
   - Document any license exceptions with legal justification
   - Create `license-report.json` with all dependency licenses
   - Update docs/security-audit.md with license compliance section

### Phase 4: Weekly Security Scanning Integration

10. **Weekly Security Scan Integration**
    - Integrate weekly security scans in CI/CD (from Story X2.2C)
    - Verify dependency-security.yml workflow includes `check_licenses.py`
    - Configure automatic issue creation for new vulnerabilities
    - Document vulnerability tracking process in docs/security-audit.md
    - Test weekly scan workflow manually

### Integration Requirements

11. **Existing Functionality Unchanged**
    - Full test suite passes after dependency changes: `pytest -m "not memory and not api_integration and not live and not ib_integration"`
    - Smoke test: bundle ingestion, backtest execution, report generation
    - Manual verification: paper trading starts successfully
    - No breaking changes from dependency upgrades

12. **Development Workflow Integration**
    - Dev extras installation works: `uv sync -E dev -E test`
    - Production installation works: `uv sync`
    - Test suite works with both installation modes
    - Documentation clearly explains when to use each installation mode

### Quality Requirements

13. **Changes Covered by Tests**
    - Test suite passes with new dependency versions
    - No new untested code introduced
    - Vulnerability remediation tested with full test suite
    - License compliance script tested with sample dependencies

14. **Documentation Updated**
    - README.md updated with installation commands
    - CONTRIBUTING.md updated with dev setup
    - docs/security-audit.md updated with vulnerability tracking
    - docs/security-audit.md updated with license compliance section
    - CHANGELOG.md updated with dependency changes

15. **No Regression Verified**
    - Full test suite passes: `pytest -m "not memory and not api_integration and not live and not ib_integration"`
    - Coverage remains ≥90% for core modules
    - No functionality changes from dependency updates
    - Lockfile determinism verified

## Tasks / Subtasks

- [ ] **Task 1: Production/Dev Dependency Split** (AC: 1-3)
  - [ ] Create `[project.optional-dependencies].dev` extra in pyproject.toml
  - [ ] Move jupyter/jupyterlab/notebook to dev extra
  - [ ] Move type stubs (pandas-stubs, types-*) to dev extra
  - [ ] Move streamlit to dev extra (if present)
  - [ ] Move torch to dev extra (if present)
  - [ ] Verify production dependency count reduced (~50+ → ~40)
  - [ ] Test production installation: `uv sync`
  - [ ] Test dev installation: `uv sync -E dev -E test`
  - [ ] Update README.md with installation commands
  - [ ] Update CONTRIBUTING.md with dev setup

- [ ] **Task 2: Vulnerability Assessment** (AC: 4)
  - [ ] Run `safety scan` to identify vulnerabilities
  - [ ] Run `pip-audit` to cross-validate findings
  - [ ] Document all 44 vulnerabilities (package, version, CVE, severity)
  - [ ] Categorize by severity: Critical, High, Medium, Low
  - [ ] Create vulnerability remediation plan

- [ ] **Task 3: High/Critical Vulnerability Remediation** (AC: 5)
  - [ ] Upgrade all High/Critical vulnerable packages
  - [ ] Test suite passes with upgrades: `uv sync -E test && pytest`
  - [ ] Verify no breaking changes
  - [ ] Pin incompatible packages with justification
  - [ ] Document pinned packages in docs/security-audit.md
  - [ ] Verify High/Critical vulnerabilities: 44 → 0

- [ ] **Task 4: Medium/Low Vulnerability Triage** (AC: 6)
  - [ ] Upgrade Medium/Low vulnerable packages where possible
  - [ ] Document unresolved vulnerabilities with justification
  - [ ] Create tracking issues for unresolved vulnerabilities
  - [ ] Document mitigation strategies
  - [ ] Verify production excludes dev-only vulnerabilities

- [ ] **Task 5: Lockfile Update and Verification** (AC: 7)
  - [ ] Run `uv lock` to update lockfile
  - [ ] Test suite passes: `uv sync -E test && pytest`
  - [ ] Verify no dependency resolution conflicts
  - [ ] Verify lockfile determinism (repeated `uv lock`)
  - [ ] Commit updated `uv.lock`

- [ ] **Task 6: License Compliance Script** (AC: 8-9)
  - [ ] Create `scripts/check_licenses.py` (see complete implementation below)
  - [ ] Test script with sample dependencies
  - [ ] Run `python scripts/check_licenses.py` → 0 GPL dependencies
  - [ ] Verify all production dependencies use Apache 2.0/MIT/BSD
  - [ ] Document any license exceptions
  - [ ] Create `license-report.json`
  - [ ] Update docs/security-audit.md with license compliance

- [ ] **Task 7: Weekly Security Scan Integration** (AC: 10)
  - [ ] Verify dependency-security.yml includes `check_licenses.py` (from Story X2.2C)
  - [ ] Test weekly scan workflow manually
  - [ ] Document vulnerability tracking in docs/security-audit.md

- [ ] **Task 8: Integration Testing** (AC: 11-12)
  - [ ] Run full test suite after all changes
  - [ ] Run smoke tests: bundle ingestion, backtest, report generation
  - [ ] Verify paper trading starts successfully
  - [ ] Test dev extras installation
  - [ ] Test production installation
  - [ ] Verify documentation clarity

- [ ] **Task 9: Documentation Updates** (AC: 14)
  - [ ] Update README.md with installation commands
  - [ ] Update CONTRIBUTING.md with dev setup
  - [ ] Update docs/security-audit.md with vulnerability tracking
  - [ ] Update docs/security-audit.md with license compliance
  - [ ] Update CHANGELOG.md with dependency changes

- [ ] **Task 10: Final Validation** (AC: 15)
  - [ ] Run full test suite → all pass
  - [ ] Verify coverage ≥90% for core modules
  - [ ] Verify no functionality changes
  - [ ] Verify lockfile determinism
  - [ ] Create summary report of dependency hygiene improvements

## Dev Notes

### Architecture Context

**Source:** [docs/architecture/tech-stack.md](../architecture/tech-stack.md)

**Package Manager:**
- uv 0.5.x+ (fast Python package installer, 10-100x faster than pip)
- Lockfile-based dependency resolution (`uv.lock`)
- Support for extras: test, dev

**Python Version:** 3.12+ required

**Dependency Security Tools:**
- safety (dependency vulnerability scanning)
- pip-audit (dependency vulnerability scanning)
- Custom license checker (scripts/check_licenses.py)

**Source:** [docs/architecture/coding-standards.md](../architecture/coding-standards.md)

**Dependency Management:**
- Pin exact versions in `pyproject.toml`
- Weekly `pip-audit` security scan in CI/CD
- Quarterly dependency update review
- No GPL-licensed dependencies (Apache 2.0/MIT only)

**Vulnerability Remediation Priority:**
- Critical: Immediate upgrade required
- High: Upgrade within 1 week
- Medium: Upgrade within 1 month
- Low: Upgrade on quarterly review

### Technical Implementation Guidance

**Production/Dev Dependency Split:**
```toml
# pyproject.toml
[project.dependencies]
# Core runtime dependencies only (production)
polars = "^1.0"
pyarrow = "^18.0"
sqlalchemy = "^2.0"
exchange-calendars = "^4.2.4"
scipy = "^1.12"
statsmodels = "^0.14"
empyrical-reloaded = "^0.5.7"
click = "^8.1"
ccxt = "^4.0"
ib_async = "^1.0"
yfinance = "^0.2"
fastapi = "^0.115"
websockets = "^14.0"
asyncio = "*"
apscheduler = "^3.10"
pydantic = "^2.0"
structlog = "^24.0"
# ... other production dependencies

[project.optional-dependencies]
test = [
    "pytest>=8.0",
    "pytest-cov>=5.0",
    "pytest-xdist>=2.5",
    "freezegun",
    "responses",
    "hypothesis>=6.0",
]

dev = [
    # Jupyter/notebook tools (dev-time only)
    "jupyter>=1.0",
    "jupyterlab>=4.0",
    "notebook>=7.0",

    # Type stubs (dev-time only)
    "pandas-stubs>=2.0",
    "types-networkx>=3.0",
    "types-requests>=2.31",
    "types-PyYAML>=6.0",

    # Heavy dev tools
    "streamlit>=1.30",  # Only if used in examples/
    "torch>=2.0",  # Only if used in examples/

    # Code quality tools
    "ruff>=0.11.12",
    "black>=24.1",
    "mypy>=1.10",
    "bandit>=1.7",

    # Documentation tools
    "sphinx>=7.0",
    "sphinx-rtd-theme>=2.0",
]
```

**Installation Commands:**
```bash
# Production installation (minimal dependencies)
uv sync

# Development installation (all extras)
uv sync -E dev -E test

# Test-only installation (for CI)
uv sync -E test
```

**Vulnerability Assessment Commands:**
```bash
# Run safety scan
safety scan --json > safety-report.json

# Run pip-audit scan
pip-audit --format json > pip-audit-report.json

# Parse and categorize vulnerabilities
python scripts/parse_vulnerabilities.py safety-report.json pip-audit-report.json
```

**Vulnerability Remediation Strategy:**
```bash
# 1. Identify vulnerable packages
safety scan

# 2. Check available upgrades
uv pip list --outdated

# 3. Upgrade packages incrementally
uv pip install --upgrade <package>

# 4. Run test suite after each upgrade
uv sync -E test && pytest

# 5. If upgrade breaks compatibility, pin and document
# pyproject.toml: package = "==1.2.3"  # Pinned due to breaking change in 1.3.0
```

**Lockfile Update and Verification:**
```bash
# Update lockfile with new versions
uv lock

# Verify lockfile includes all dependencies
uv pip list

# Test suite with new lockfile
uv sync -E test && pytest

# Verify lockfile determinism
uv lock && git diff uv.lock  # Should show no changes
```

**Complete License Compliance Script:**
```python
#!/usr/bin/env python3
# scripts/check_licenses.py
"""
Check dependency licenses for compliance.

Ensures no GPL-licensed dependencies in production (Apache 2.0/MIT/BSD only).
"""

import json
import sys
from importlib.metadata import distributions
from pathlib import Path
from typing import Dict, List, Set

# Approved licenses (compatible with Apache 2.0)
APPROVED_LICENSES = {
    "Apache-2.0",
    "Apache Software License",
    "MIT",
    "MIT License",
    "BSD",
    "BSD License",
    "BSD-3-Clause",
    "BSD-2-Clause",
    "ISC",
    "ISC License",
    "Python Software Foundation License",
    "PSF",
    "Public Domain",
    "Unlicense",
}

# GPL licenses (NOT allowed in production)
GPL_LICENSES = {
    "GPL",
    "GPLv2",
    "GPLv3",
    "GNU General Public License",
    "GNU Lesser General Public License",
    "LGPL",
    "LGPLv2",
    "LGPLv3",
    "AGPL",
    "AGPLv3",
}


def get_package_license(dist) -> str:
    """Extract license from package metadata."""
    # Try License field
    if dist.metadata.get("License"):
        return dist.metadata["License"]

    # Try License classifier
    classifiers = dist.metadata.get_all("Classifier") or []
    for classifier in classifiers:
        if classifier.startswith("License ::"):
            # Extract license name from classifier
            # "License :: OSI Approved :: MIT License" → "MIT License"
            return classifier.split("::")[-1].strip()

    # Try license file
    try:
        if dist.files:
            for file in dist.files:
                if file.name.lower() in ("license", "license.txt", "license.md"):
                    license_text = (dist.locate_file(file)).read_text()
                    # Heuristic detection
                    if "MIT" in license_text:
                        return "MIT License"
                    elif "Apache" in license_text:
                        return "Apache-2.0"
                    elif "BSD" in license_text:
                        return "BSD License"
    except Exception:
        pass

    return "UNKNOWN"


def check_licenses(fail_on_gpl: bool = True) -> Dict[str, List[Dict]]:
    """
    Check all installed packages for license compliance.

    Args:
        fail_on_gpl: Exit with code 1 if GPL dependencies detected

    Returns:
        Dictionary with categorized packages
    """
    results = {
        "approved": [],
        "gpl": [],
        "unknown": [],
        "total_count": 0,
    }

    for dist in distributions():
        package_name = dist.metadata["Name"]
        package_version = dist.metadata["Version"]
        license_name = get_package_license(dist)

        package_info = {
            "name": package_name,
            "version": package_version,
            "license": license_name,
        }

        results["total_count"] += 1

        # Categorize by license
        if any(gpl in license_name for gpl in GPL_LICENSES):
            results["gpl"].append(package_info)
        elif license_name in APPROVED_LICENSES:
            results["approved"].append(package_info)
        else:
            results["unknown"].append(package_info)

    return results


def main():
    """Main entry point."""
    import argparse

    parser = argparse.ArgumentParser(description="Check dependency licenses")
    parser.add_argument(
        "--fail-on-gpl",
        action="store_true",
        default=True,
        help="Exit with code 1 if GPL dependencies detected (default: True)",
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=Path("license-report.json"),
        help="Output file for JSON report (default: license-report.json)",
    )
    parser.add_argument(
        "--verbose",
        action="store_true",
        help="Print detailed report to stdout",
    )

    args = parser.parse_args()

    # Check licenses
    results = check_licenses(fail_on_gpl=args.fail_on_gpl)

    # Write JSON report
    with open(args.output, "w") as f:
        json.dump(results, f, indent=2)

    # Print summary
    print(f"License Compliance Report")
    print(f"{'='*60}")
    print(f"Total packages: {results['total_count']}")
    print(f"Approved licenses: {len(results['approved'])}")
    print(f"GPL licenses: {len(results['gpl'])}")
    print(f"Unknown licenses: {len(results['unknown'])}")
    print(f"{'='*60}")

    # Print GPL violations
    if results["gpl"]:
        print(f"\n❌ GPL-licensed dependencies detected:")
        for pkg in results["gpl"]:
            print(f"  - {pkg['name']} {pkg['version']} ({pkg['license']})")

    # Print unknown licenses (warning)
    if results["unknown"]:
        print(f"\n⚠️  Unknown licenses detected (manual review required):")
        for pkg in results["unknown"]:
            print(f"  - {pkg['name']} {pkg['version']} ({pkg['license']})")

    # Print verbose output
    if args.verbose:
        print(f"\n✅ Approved licenses:")
        for pkg in results["approved"]:
            print(f"  - {pkg['name']} {pkg['version']} ({pkg['license']})")

    # Write JSON report location
    print(f"\nDetailed report: {args.output}")

    # Exit code
    if args.fail_on_gpl and results["gpl"]:
        print(f"\n❌ FAIL: GPL dependencies detected!")
        sys.exit(1)
    elif results["unknown"]:
        print(f"\n⚠️  WARNING: Unknown licenses require manual review")
        sys.exit(0)
    else:
        print(f"\n✅ PASS: All licenses compliant")
        sys.exit(0)


if __name__ == "__main__":
    main()
```

**License Check Usage:**
```bash
# Run license check
python scripts/check_licenses.py

# Run with verbose output
python scripts/check_licenses.py --verbose

# Run without failing on GPL (warning only)
python scripts/check_licenses.py --no-fail-on-gpl

# Custom output file
python scripts/check_licenses.py --output custom-report.json
```

**Vulnerability Tracking Documentation Template:**
```markdown
# docs/security-audit.md

# Security Audit

## Vulnerability Tracking

### Current Status
- **Last Scan:** 2025-10-11
- **Total Vulnerabilities:** 0 (High/Critical)
- **Production Dependencies:** ~40
- **Dev Dependencies:** ~30

### Vulnerability History

#### 2025-10-11: Story X2.2D Remediation
- **Initial:** 44 vulnerabilities (12 High, 32 Medium/Low)
- **Remediated:** All 44 vulnerabilities
- **Actions:**
  - Upgraded `package-a` from 1.2.0 to 1.3.5 (CVE-2024-XXXX)
  - Upgraded `package-b` from 2.1.0 to 2.2.0 (CVE-2024-YYYY)
  - Pinned `package-c` at 3.4.5 (breaking change in 3.5.0, CVE-2024-ZZZZ mitigated)

### Unresolved Vulnerabilities

#### package-c: CVE-2024-ZZZZ (Medium)
- **Severity:** Medium
- **CVSS Score:** 5.3
- **Affected Version:** 3.4.5 (pinned)
- **Fixed Version:** 3.5.0 (breaking changes)
- **Justification:** Upgrade to 3.5.0 breaks API compatibility
- **Mitigation:** Input sanitization implemented, attack vector not exposed
- **Remediation Plan:** Upgrade during next major release (v2.0)
- **Tracking Issue:** #XXX

## License Compliance

### Current Status
- **Last Check:** 2025-10-11
- **GPL Dependencies:** 0
- **Approved Licenses:** 40 production, 30 dev
- **Unknown Licenses:** 0

### License Policy
RustyBT requires Apache 2.0, MIT, BSD, or compatible licenses for all dependencies.
GPL-licensed dependencies are NOT permitted due to copyleft restrictions.

### Approved Licenses
- Apache-2.0
- MIT
- BSD (2-Clause, 3-Clause)
- ISC
- Python Software Foundation License

### License Exceptions
None currently.
```

### Testing

**Dependency Hygiene Testing Commands:**
```bash
# Test production installation
uv sync
python -c "import rustybt; print('Production install OK')"

# Test dev installation
uv sync -E dev -E test
python -c "import jupyter; print('Dev install OK')"

# Test suite with new dependencies
uv sync -E test && pytest -m "not memory and not api_integration and not live and not ib_integration"

# Vulnerability scanning
safety scan
pip-audit --format json

# License compliance check
python scripts/check_licenses.py --verbose

# Lockfile verification
uv lock && git diff uv.lock  # Should show no changes

# Lockfile determinism test
rm uv.lock && uv lock && uv lock && git diff uv.lock  # Should show no changes
```

**Integration Testing:**
```bash
# Full test suite
pytest -m "not memory and not api_integration and not live and not ib_integration" \
  --cov=rustybt --cov-report=term --cov-fail-under=90

# Smoke tests
python -m rustybt ingest -b quandl-sample
python -m rustybt run -f examples/buy_and_hold.py --start 2020-01-01 --end 2020-12-31
python examples/generate_backtest_report.py

# Paper trading startup
python -m rustybt live --broker paper --strategy examples/simple_strategy.py
```

## Change Log

| Date       | Version | Description                            | Author       |
|------------|---------|----------------------------------------|--------------|
| 2025-10-11 | 1.0     | Split from X2.2 per Epic X2 structure  | PO (Sarah)   |

## Dev Agent Record

*This section will be populated by the development agent during implementation.*

### Agent Model Used

*To be filled by dev agent*

### Debug Log References

*To be filled by dev agent*

### Completion Notes List

*To be filled by dev agent*

### File List

*To be filled by dev agent*

## QA Results

*This section will be populated by the QA agent after story completion.*
