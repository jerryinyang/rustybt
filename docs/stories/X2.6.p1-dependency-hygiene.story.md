# Story X2.6: P1 Dependency Hygiene

## Status
Approved for development

## Story

**As a** Software Engineer maintaining supply chain security,
**I want** clean production/dev dependency split, vulnerability remediation, and license compliance enforcement,
**so that** production deployments have minimal attack surface, 0 High/Critical vulnerabilities, and only approved licenses.

## Acceptance Criteria

### Dependency Split

1. **Production vs Dev Split**
   - Create `[project.optional-dependencies].dev` extra for development-only packages
   - Move to dev extra: `jupyter`, `jupyterlab`, `streamlit`, `torch` (if present)
   - Move to dev extra: Type stubs (`pandas-stubs`, `types-*`)
   - Verify core dependencies remain in `[project.dependencies]`
   - Document installation: `uv sync` (prod) vs. `uv sync -E dev -E test` (dev)

### Vulnerability Remediation

2. **Vulnerability Remediation**
   - Run `safety scan` to identify vulnerable packages
   - Prioritize High/Critical vulnerabilities for immediate upgrade
   - Upgrade packages to patched versions where available
   - Pin packages with known vulnerabilities if upgrade breaks compatibility
   - Document unresolved vulnerabilities with justification and mitigation plan
   - Verify production extras exclude dev-only vulnerable packages

3. **Lockfile Verification**
   - Run `uv lock` to update lock file with new versions
   - Verify `uv.lock` includes vulnerability metadata (if supported)
   - Run test suite with new lockfile: `uv sync -E test && pytest`
   - Verify no dependency resolution conflicts
   - Commit updated `uv.lock` with story changes

### License Compliance

4. **License Compliance Check**
   - Create `scripts/check_licenses.py` to scan dependency licenses
   - Ensure no GPL-licensed dependencies (Apache 2.0/MIT only)
   - Document any exceptions with justification
   - Integrate with CI (weekly dependency-security workflow from Story X2.5)

### Integration Requirements

5. **Weekly Security Scan Integration**
   - Verify dependency-security workflow includes `check_licenses.py`
   - Verify safety scan runs weekly
   - Verify pip-audit runs weekly
   - Reports uploaded as artifacts

### Quality Requirements

6. **Documentation Updated**
   - README.md updated with dev extras installation
   - `docs/security-audit.md` updated with vulnerability tracking
   - Document dependency upgrade policy
   - Document license compliance requirements

7. **No Regression Verified**
   - Full test suite passes with new dependencies
   - No dependency resolution conflicts
   - Production dependencies reduced (moved dev tools to extras)

## Tasks / Subtasks

- [ ] **Task 1: Split Dependencies** (AC: 1)
  - [ ] Review current `[project.dependencies]` in pyproject.toml
  - [ ] Identify dev-only packages: jupyter, jupyterlab, streamlit, torch
  - [ ] Identify type stubs: pandas-stubs, types-*
  - [ ] Create `[project.optional-dependencies].dev` section
  - [ ] Move dev tools to dev extra
  - [ ] Move type stubs to dev extra
  - [ ] Verify core dependencies remain in `[project.dependencies]`
  - [ ] Test production install: `rm -rf .venv && uv sync`
  - [ ] Verify jupyter NOT available in production: `uv run python -c "import jupyter"`
  - [ ] Test dev install: `rm -rf .venv && uv sync -E dev -E test`
  - [ ] Verify jupyter available in dev: `uv run python -c "import jupyter"`
  - [ ] Document installation commands in README.md

- [ ] **Task 2: Remediate Vulnerabilities** (AC: 2)
  - [ ] Run safety scan: `uv run safety scan --json > safety-report.json`
  - [ ] Run pip-audit: `uv run pip-audit --format json > pip-audit-report.json`
  - [ ] Review reports and categorize vulnerabilities by severity
  - [ ] Prioritize High/Critical vulnerabilities in production dependencies
  - [ ] For each vulnerability:
    - [ ] Check if upgrade available
    - [ ] Upgrade to patched version if available
    - [ ] Test compatibility after upgrade
    - [ ] If no patch available, document in docs/security-audit.md
  - [ ] Verify production extras exclude dev-only vulnerable packages
  - [ ] Document any accepted risks with justification

- [ ] **Task 3: Update Lockfile** (AC: 3)
  - [ ] Run `uv lock` to update lock file with new versions
  - [ ] Review lockfile diff to verify changes are expected
  - [ ] Verify no dependency resolution conflicts
  - [ ] Test production install: `uv sync`
  - [ ] Test dev install: `uv sync -E dev -E test`
  - [ ] Run full test suite: `uv run pytest`
  - [ ] Verify all tests pass with new dependencies
  - [ ] Commit updated `uv.lock` with story changes

- [ ] **Task 4: Create License Check Script** (AC: 4)
  - [ ] Create `scripts/check_licenses.py`
  - [ ] Implement package license detection (using pip-licenses)
  - [ ] Define forbidden licenses: GPL, AGPL, LGPL, SSPL
  - [ ] Define allowed licenses: MIT, Apache, BSD, ISC, Python
  - [ ] Implement license checking logic
  - [ ] Test with known GPL package (should fail)
  - [ ] Test with current dependencies (should pass)
  - [ ] Document any license exceptions with justification
  - [ ] Verify script exits with code 1 if forbidden licenses found

- [ ] **Task 5: Verify CI Integration** (AC: 5)
  - [ ] Verify dependency-security workflow exists from X2.5
  - [ ] Verify workflow includes `check_licenses.py`
  - [ ] Verify safety scan runs weekly
  - [ ] Verify pip-audit runs weekly
  - [ ] Verify reports uploaded as artifacts
  - [ ] Test workflow manually: `gh workflow run dependency-security.yml`
  - [ ] Verify workflow creates issue on failure

- [ ] **Task 6: Update Documentation** (AC: 6)
  - [ ] Update README.md with dev extras installation: `uv sync -E dev -E test`
  - [ ] Update `docs/security-audit.md` with vulnerability tracking section
  - [ ] Add vulnerability tracking table
  - [ ] Add accepted risks table
  - [ ] Add weekly scan results section
  - [ ] Document dependency upgrade policy
  - [ ] Document license compliance requirements

- [ ] **Task 7: Final Validation** (AC: 7)
  - [ ] Fresh install test (production): `rm -rf .venv && uv sync`
  - [ ] Verify jupyter NOT available
  - [ ] Fresh install test (dev): `rm -rf .venv && uv sync -E dev -E test`
  - [ ] Verify jupyter available
  - [ ] Run full test suite: `uv run pytest`
  - [ ] Verify all tests pass
  - [ ] Verify no dependency resolution conflicts
  - [ ] Verify production dependencies reduced (count before/after)
  - [ ] Run license check: `python scripts/check_licenses.py`
  - [ ] Verify 0 forbidden licenses

## Dev Notes

### Architecture Context

**Source:** [docs/architecture/coding-standards.md](../architecture/coding-standards.md)

**Dependency Management:**
- Pin exact versions in `pyproject.toml`
- Weekly `pip-audit` security scan in CI/CD
- No GPL-licensed dependencies (Apache 2.0/MIT only)

**Relevant Source Locations:**
- Configuration: `pyproject.toml` ([project.dependencies], [project.optional-dependencies])
- Lockfile: `uv.lock`
- Scripts: `scripts/check_licenses.py`
- Documentation: `docs/security-audit.md`, `README.md`

### Technical Implementation Guidance

**Dependency Split Strategy:**

**Current Structure (pyproject.toml):**
```toml
[project]
dependencies = [
    # Core dependencies (production-required)
    "pandas>=2.0.0",
    "numpy>=1.24.0",
    "polars>=0.20.0",
    "ccxt>=4.0.0",
    # ... many more including dev tools
]
```

**Target Structure:**
```toml
[project]
dependencies = [
    # Production-only dependencies
    "pandas>=2.0.0",
    "numpy>=1.24.0",
    "polars>=0.20.0",
    "ccxt>=4.0.0",
    "ib-insync>=0.9.86",
    "yfinance>=0.2.0",
    "structlog>=23.0.0",
    "pydantic>=2.0.0",
    # ... core only
]

[project.optional-dependencies]
dev = [
    # Development tools
    "jupyter>=1.0.0",
    "jupyterlab>=4.0.0",
    "ipython>=8.0.0",
    "streamlit>=1.30.0",
    # Type stubs
    "pandas-stubs>=2.0.0",
    "types-requests>=2.31.0",
    "types-PyYAML>=6.0.1",
    "types-networkx>=3.1.0",
    # Documentation
    "mkdocs>=1.5.0",
    "mkdocs-material>=9.0.0",
]

test = [
    # Testing tools (from X2.1)
    "pytest>=7.2.0",
    "pytest-cov>=3.0.0",
    "pytest-xdist>=2.5.0",
    "freezegun>=1.2.0",
    "responses>=0.23.0",
    "hypothesis>=6.0.0",
]
```

**Installation Commands:**
```bash
# Production only
uv sync

# Development
uv sync -E dev -E test

# Testing only
uv sync -E test
```

---

**Vulnerability Remediation Process:**

**Step 1: Identify Vulnerabilities**
```bash
# Run safety scan
uv run safety scan --json > safety-report.json

# Run pip-audit
uv run pip-audit --format json > pip-audit-report.json

# Review reports
cat safety-report.json | jq '.vulnerabilities[]'
cat pip-audit-report.json | jq '.vulnerabilities[]'
```

**Step 2: Prioritize Remediation**
```
Priority 1: High/Critical vulnerabilities in production dependencies
Priority 2: Medium vulnerabilities in production dependencies
Priority 3: High/Critical vulnerabilities in dev dependencies
Priority 4: Low/Medium vulnerabilities in dev dependencies
```

**Step 3: Upgrade or Pin**
```bash
# For upgradeable packages
uv add "package>=fixed_version"

# For packages without patches
# Option A: Pin to secure version if downgrade acceptable
uv add "package==last_secure_version"

# Option B: Document risk if upgrade breaks compatibility
# Add to docs/security-audit.md:
# - Package: package_name
# - Vulnerability: CVE-XXXX-XXXX
# - Severity: Medium
# - Status: Accepted (no patch available)
# - Mitigation: Not using vulnerable functionality
# - Review Date: 2025-Q2
```

**Step 4: Update Lockfile**
```bash
# Regenerate lockfile with new versions
uv lock

# Verify resolution succeeds
uv sync -E dev -E test

# Run test suite to verify compatibility
uv run pytest
```

---

**License Compliance Script:**

**Purpose:** Ensure no GPL-licensed dependencies (Apache 2.0/MIT only).

**Implementation:**
```python
# scripts/check_licenses.py
import json
import subprocess
import sys
from pathlib import Path
from typing import Dict, List

FORBIDDEN_LICENSES = ['GPL', 'AGPL', 'LGPL', 'SSPL']
ALLOWED_LICENSES = ['MIT', 'Apache', 'BSD', '3-Clause', '2-Clause', 'ISC', 'Python']

def get_installed_packages() -> List[str]:
    """Get list of installed packages."""
    result = subprocess.run(
        ['uv', 'pip', 'list', '--format=json'],
        capture_output=True,
        text=True
    )
    packages = json.loads(result.stdout)
    return [pkg['name'] for pkg in packages]

def get_package_license(package_name: str) -> str:
    """Get license for a package using pip-licenses."""
    result = subprocess.run(
        ['uv', 'run', 'pip-licenses', '--packages', package_name, '--format=json'],
        capture_output=True,
        text=True
    )
    try:
        licenses = json.loads(result.stdout)
        if licenses:
            return licenses[0].get('License', 'UNKNOWN')
    except:
        pass
    return 'UNKNOWN'

def check_license(license_str: str) -> bool:
    """Check if license is allowed."""
    license_upper = license_str.upper()

    # Check for forbidden licenses
    for forbidden in FORBIDDEN_LICENSES:
        if forbidden in license_upper:
            return False

    # Check for allowed licenses
    for allowed in ALLOWED_LICENSES:
        if allowed.upper() in license_upper:
            return True

    # Unknown or uncommon license - warn
    return None

def main():
    """Check all package licenses."""
    print("Checking dependency licenses...")

    # Install pip-licenses if not available
    subprocess.run(['uv', 'pip', 'install', 'pip-licenses'], capture_output=True)

    packages = get_installed_packages()

    forbidden_packages = []
    unknown_packages = []

    for package in packages:
        license_str = get_package_license(package)
        result = check_license(license_str)

        if result is False:
            forbidden_packages.append((package, license_str))
        elif result is None:
            unknown_packages.append((package, license_str))

    # Report results
    if forbidden_packages:
        print("\n❌ FORBIDDEN LICENSES DETECTED:")
        for package, license_str in forbidden_packages:
            print(f"  - {package}: {license_str}")
        sys.exit(1)

    if unknown_packages:
        print("\n⚠️ UNKNOWN LICENSES (review required):")
        for package, license_str in unknown_packages:
            print(f"  - {package}: {license_str}")

    print("\n✅ All dependencies use allowed licenses")
    sys.exit(0)

if __name__ == '__main__':
    main()
```

**Usage:**
```bash
# Check licenses (CI integration)
python scripts/check_licenses.py
```

---

**Dependency Security Documentation:**

**File:** `docs/security-audit.md`

**Add Section:**
```markdown
## Dependency Security

**Last Updated:** 2025-10-12

### Vulnerability Tracking

| Package | Version | Vulnerability | Severity | Status | Mitigation |
|---------|---------|---------------|----------|--------|------------|
| (example) requests | 2.28.0 | CVE-2023-XXXXX | Medium | Upgraded to 2.31.0 | N/A |

### Accepted Risks

| Package | Vulnerability | Severity | Justification | Review Date |
|---------|---------------|----------|---------------|-------------|
| (example) package_name | CVE-2023-XXXXX | Low | Not using vulnerable functionality | 2025-Q2 |

### Weekly Scan Results

Automated security scans run every Monday at 2 AM UTC via GitHub Actions workflow:
`.github/workflows/dependency-security.yml`

Reports uploaded as artifacts to workflow runs.

### Upgrade Policy

**Immediate Upgrade (within 24 hours):**
- Critical vulnerabilities in production dependencies
- High vulnerabilities in production dependencies with active exploits

**Planned Upgrade (within 1 week):**
- High vulnerabilities in production dependencies
- Critical vulnerabilities in dev dependencies

**Scheduled Upgrade (next sprint):**
- Medium vulnerabilities in production dependencies
- High vulnerabilities in dev dependencies

**Monitored:**
- Low vulnerabilities (upgrade during regular dependency updates)
```

---

**Integration with CI/CD (from X2.5):**

The dependency security workflow from X2.5 will run weekly:

```yaml
# .github/workflows/dependency-security.yml
# (Created in X2.5, references scripts from X2.6)
name: Dependency Security

on:
  schedule:
    - cron: '0 2 * * 1'  # Monday 2 AM UTC
  workflow_dispatch:

jobs:
  dependency-security:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'

      - name: Install uv
        run: |
          curl -LsSf https://astral.sh/uv/install.sh | sh
          echo "$HOME/.cargo/bin" >> $GITHUB_PATH

      - name: Install dependencies
        run: |
          uv sync -E dev -E test

      - name: Run safety scan
        run: |
          uv run safety scan --json > safety-report.json || true

      - name: Run pip-audit
        run: |
          uv run pip-audit --format json > pip-audit-report.json || true

      - name: Check licenses (BLOCKING)
        run: |
          uv run python scripts/check_licenses.py

      - name: Upload security reports
        uses: actions/upload-artifact@v3
        with:
          name: security-reports
          path: |
            safety-report.json
            pip-audit-report.json
```

### Testing

**Source:** [docs/architecture/testing-strategy.md](../architecture/testing-strategy.md)

**Test Standards:**
- Dependency split tested with fresh install
- Vulnerability remediation verified with security scans
- License check tested with known GPL package (should fail)
- Lockfile resolution verified with uv sync

**Testing Commands:**

```bash
# Test production dependencies only
rm -rf .venv
uv sync  # Should install only production deps
uv run python -c "import jupyter" # Should fail

# Test dev dependencies
rm -rf .venv
uv sync -E dev -E test
uv run python -c "import jupyter" # Should succeed

# Test license check
python scripts/check_licenses.py

# Test vulnerability scans
uv run safety scan
uv run pip-audit

# Test lockfile
uv lock
uv sync -E dev -E test
uv run pytest  # All tests should pass
```

**Regression Tests:**

```bash
# Verify full test suite still passes
uv sync -E test
uv run pytest -m "not memory and not api_integration and not live and not ib_integration"

# Verify coverage maintained
uv run pytest --cov=rustybt --cov-report=term

# Verify no dependency resolution conflicts
uv lock --verbose
```

## Change Log

| Date       | Version | Description                          | Author    |
|------------|---------|--------------------------------------|-----------|
| 2025-10-11 | 1.0     | Initial story creation, renumbered   | SM (Bob)  |

## Dev Agent Record

*This section will be populated by the development agent during implementation.*

### Agent Model Used

*To be filled by dev agent*

### Debug Log References

*To be filled by dev agent*

### Completion Notes List

*To be filled by dev agent*

### File List

*To be filled by dev agent*

## QA Results

*This section will be populated by the QA agent after story completion.*
